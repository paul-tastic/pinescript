//mach2fx
//@version=5
strategy("Superman S&D Reversal Strategy", overlay=true, max_boxes_count=500, max_labels_count=500)

// ============================================================================
// INPUTS
// ============================================================================

// HTF Zone Settings
htf = input.timeframe("60", "Higher Timeframe for S/D Zones", tooltip="Select higher timeframe for supply/demand zones")
zone_strength = input.int(3, "Zone Strength (Pivot Bars)", minval=1, maxval=10, group="Zone Settings")
max_zones = input.int(5, "Max Zones to Display", minval=1, maxval=20, group="Zone Settings")
rbd_lookback = input.int(5, "RBD/DBR Lookback Bars", minval=2, maxval=20, group="Zone Settings", tooltip="How many bars to check for rally/drop before base")

// Visual Settings
supply_color = input.color(color.new(color.red, 85), "Supply Zone Color", group="Visual")
demand_color = input.color(color.new(color.green, 85), "Demand Zone Color", group="Visual")
show_extended_zones = input.bool(true, "Show Extended Trade Zones", group="Visual", tooltip="Show the 2x extended zones where trades can be taken")
extended_supply_color = input.color(color.new(color.red, 93), "Extended Supply Zone Color", group="Visual")
extended_demand_color = input.color(color.new(color.green, 93), "Extended Demand Zone Color", group="Visual")
show_debug = input.bool(true, "Show Debug Table", group="Visual")
show_swing_labels = input.bool(true, "Show Swing Candle Labels", group="Visual", tooltip="Annotate the swing candle that entered the zone")

// Risk Management
risk_reward = input.float(2.0, "Risk:Reward Ratio", minval=0.5, maxval=10, step=0.1, group="Risk Management")
risk_per_trade = input.float(500, "Risk Per Trade ($)", minval=10, step=10, group="Risk Management")
max_contracts = input.int(10, "Max Contracts Per Trade", minval=1, maxval=100, group="Risk Management")
max_trades_per_zone = input.int(1, "Max Trades Per Zone", minval=1, maxval=10, group="Risk Management", tooltip="Maximum number of trades allowed per supply/demand zone")

// Session Settings
use_session_filter = input.bool(true, "Use Session Time Filter", group="Session")
session_start = input.string("0930", "Session Start (HHMM)", group="Session")
session_end = input.string("1645", "Session End (HHMM)", group="Session")
close_outside_session = input.bool(true, "Close Trades Outside Session", group="Session")

// ============================================================================
// VARIABLES
// ============================================================================

var box[] supply_zones = array.new_box()
var box[] demand_zones = array.new_box()
var box[] extended_supply_zones = array.new_box()  // 2x extended zones below supply
var box[] extended_demand_zones = array.new_box()  // 2x extended zones above demand
var int[] supply_zone_trade_count = array.new_int()  // Track trades taken per supply zone
var int[] demand_zone_trade_count = array.new_int()  // Track trades taken per demand zone
var int[] supply_zone_start_time = array.new_int()  // Track when each supply zone was created
var int[] demand_zone_start_time = array.new_int()  // Track when each demand zone was created

// Track the last pivot values to detect new pivots (prevent duplicate zones on LTF)
var float last_swing_high = na
var float last_swing_low = na

var label swing_label = na

// Trade state tracking
var bool in_supply_zone = false
var bool in_demand_zone = false
var int active_supply_zone_idx = -1
var int active_demand_zone_idx = -1
var bool extended_zone_activated = false  // Track if original zone was entered first

// Order block tracking
var float ob_high = na  // Highest point of order block
var float ob_low = na   // Lowest point of order block
var int ob_start_bar = na
var int ob_end_bar = na
var bool ob_formed = false  // Order block has formed

// Entry candle tracking (lowest/highest candle in order block)
var float entry_candle_high = na
var float entry_candle_low = na
var int entry_candle_bar = na

var bool hurdle2_complete = false  // Price pierced and reversed through order block
var float hurdle2_pierce_level = na  // The blue line level that needs to be pierced

// Entry tracking
var bool waiting_for_retrace = false
var string trade_direction = na

// Invalidation tracking
var bool setup_invalid = false
var string invalidation_reason = na

var line entry_line = na
var line stop_line = na
var line tp_line = na
var label trade_label = na

// Visual elements for current active setup
var box order_block_box = na  // Yellow box showing the entry candle
var line hurdle2_pierce_line = na  // Blue dotted line showing where price needs to pierce
var line entry_trigger_line = na   // Line showing exact entry price
var int blue_line_start_bar = na  // Track when blue line was created for 10-bar limit

// Tick calculations
tick_size = syminfo.mintick
two_ticks = tick_size * 2

// Session time functions
get_session_hour(session_str) =>
    int(str.tonumber(str.substring(session_str, 0, 2)))

get_session_minute(session_str) =>
    int(str.tonumber(str.substring(session_str, 2, 4)))

// Check if current time is within session
in_session = true
if use_session_filter
    current_hour = hour(time)
    current_minute = minute(time)
    start_hour = get_session_hour(session_start)
    start_minute = get_session_minute(session_start)
    end_hour = get_session_hour(session_end)
    end_minute = get_session_minute(session_end)

    current_time_minutes = current_hour * 60 + current_minute
    start_time_minutes = start_hour * 60 + start_minute
    end_time_minutes = end_hour * 60 + end_minute

    in_session := current_time_minutes >= start_time_minutes and current_time_minutes <= end_time_minutes

// ============================================================================
// HTF SUPPLY/DEMAND ZONE DETECTION
// ============================================================================

// Request HTF pivot data
htf_swing_high = request.security(syminfo.tickerid, htf, ta.pivothigh(high, zone_strength, zone_strength), barmerge.gaps_off, barmerge.lookahead_off)
htf_swing_low = request.security(syminfo.tickerid, htf, ta.pivotlow(low, zone_strength, zone_strength), barmerge.gaps_off, barmerge.lookahead_off)
htf_pivot_high_price = request.security(syminfo.tickerid, htf, high[zone_strength], barmerge.gaps_off, barmerge.lookahead_off)
htf_pivot_low_price = request.security(syminfo.tickerid, htf, low[zone_strength], barmerge.gaps_off, barmerge.lookahead_off)

// Get HTF data for Rally-Base-Drop / Drop-Base-Rally pattern detection
// For SUPPLY: Check for rally BEFORE the pivot (base), then drop AFTER
htf_low_before_pivot = request.security(syminfo.tickerid, htf, ta.lowest(low, rbd_lookback)[zone_strength + rbd_lookback], barmerge.gaps_off, barmerge.lookahead_off)
htf_high_after_pivot = request.security(syminfo.tickerid, htf, ta.highest(high, rbd_lookback)[zone_strength - rbd_lookback], barmerge.gaps_off, barmerge.lookahead_off)
htf_low_after_pivot = request.security(syminfo.tickerid, htf, ta.lowest(low, rbd_lookback)[zone_strength - rbd_lookback], barmerge.gaps_off, barmerge.lookahead_off)

// For DEMAND: Check for drop BEFORE the pivot (base), then rally AFTER
htf_high_before_pivot = request.security(syminfo.tickerid, htf, ta.highest(high, rbd_lookback)[zone_strength + rbd_lookback], barmerge.gaps_off, barmerge.lookahead_off)

// Create SUPPLY zone when HTF swing high is detected (price rejected from above - sellers present)
// Only create once when pivot first appears (check if it's a new pivot)
// Use the pivot price to detect new pivots, not the pivot value itself
// RALLY-BASE-DROP PATTERN:
//   1. RALLY: Price rallied up into the pivot (from lower prices)
//   2. BASE: The pivot represents consolidation (the base)
//   3. DROP: Price dropped sharply after the pivot (sellers overwhelm buyers)
is_new_swing_high = not na(htf_swing_high) and (na(last_swing_high) or htf_pivot_high_price != last_swing_high)
if is_new_swing_high
    last_swing_high := htf_pivot_high_price

    // Zone is the range of the pivot candle where the move originated from (the BASE)
    zone_top = htf_pivot_high_price
    zone_bottom = htf_pivot_low_price

    // RALLY-BASE-DROP VALIDATION:
    // 1. RALLY: Price rallied INTO the base (low before pivot is significantly below pivot low)
    has_rally = not na(htf_low_before_pivot) and htf_low_before_pivot < zone_bottom

    // 2. BASE: The pivot itself is the base (consolidation area)

    // 3. DROP: Price dropped sharply AFTER the base (low after pivot is significantly below pivot low)
    has_drop = not na(htf_low_after_pivot) and htf_low_after_pivot < zone_bottom

    // Valid supply zone requires Rally-Base-Drop pattern
    valid_supply_zone = has_rally and has_drop

    // Only create zone if it follows Rally-Base-Drop pattern
    if valid_supply_zone
        // Check if zone overlaps with existing zones
        is_duplicate = false
        if array.size(supply_zones) > 0
            for i = 0 to array.size(supply_zones) - 1
                existing_zone = array.get(supply_zones, i)
                existing_top = box.get_top(existing_zone)
                existing_bottom = box.get_bottom(existing_zone)

                // Check for overlap
                if not (zone_bottom > existing_top or zone_top < existing_bottom)
                    is_duplicate := true
                    break

        if not is_duplicate
            // Remove oldest zone if at max capacity
            if array.size(supply_zones) >= max_zones
                old_box = array.shift(supply_zones)
                box.delete(old_box)
                old_extended_box = array.shift(extended_supply_zones)
                box.delete(old_extended_box)
                array.shift(supply_zone_trade_count)  // Remove trade count for oldest zone
                array.shift(supply_zone_start_time)  // Remove start time for oldest zone

            // Create new supply zone
            zone_box = box.new(time, zone_top, time, zone_bottom,
                              xloc=xloc.bar_time, extend=extend.right,
                              border_color=supply_color, bgcolor=supply_color,
                              border_width=1)
            array.push(supply_zones, zone_box)
            array.push(supply_zone_trade_count, 0)  // Initialize trade count to 0
            array.push(supply_zone_start_time, time)  // Store zone creation time

            // Create extended supply zone (same height below the original zone)
            zone_height = zone_top - zone_bottom
            extended_zone_top = zone_bottom
            extended_zone_bottom = zone_bottom - zone_height

            if show_extended_zones
                extended_box = box.new(time, extended_zone_top, time, extended_zone_bottom,
                                      xloc=xloc.bar_time, extend=extend.right,
                                      border_color=extended_supply_color, bgcolor=extended_supply_color,
                                      border_width=1, border_style=line.style_dashed)
                array.push(extended_supply_zones, extended_box)
            else
                // Still need to push a placeholder to keep arrays synchronized
                array.push(extended_supply_zones, na)

            // Invalidate any DEMAND zones that overlap with this new SUPPLY zone
            if array.size(demand_zones) > 0
                for i = array.size(demand_zones) - 1 to 0
                    demand_zone = array.get(demand_zones, i)
                    demand_top = box.get_top(demand_zone)
                    demand_bottom = box.get_bottom(demand_zone)

                    // Check for overlap
                    if not (zone_bottom > demand_top or zone_top < demand_bottom)
                        // Zones overlap - invalidate the demand zone
                        box.delete(demand_zone)
                        array.remove(demand_zones, i)
                        // Delete extended zone if it exists
                        extended_demand_box = array.get(extended_demand_zones, i)
                        if not na(extended_demand_box)
                            box.delete(extended_demand_box)
                        array.remove(extended_demand_zones, i)
                        array.remove(demand_zone_trade_count, i)
                        array.remove(demand_zone_start_time, i)

// Create DEMAND zone when HTF swing low is detected (price rejected from below - buyers present)
// Only create once when pivot first appears (check if it's a new pivot)
// Use the pivot price to detect new pivots, not the pivot value itself
// DROP-BASE-RALLY PATTERN:
//   1. DROP: Price dropped down into the pivot (from higher prices)
//   2. BASE: The pivot represents consolidation (the base)
//   3. RALLY: Price rallied sharply after the pivot (buyers overwhelm sellers)
is_new_swing_low = not na(htf_swing_low) and (na(last_swing_low) or htf_pivot_low_price != last_swing_low)
if is_new_swing_low
    last_swing_low := htf_pivot_low_price

    // Zone is the range of the pivot candle where the move originated from (the BASE)
    zone_top = htf_pivot_high_price
    zone_bottom = htf_pivot_low_price

    // DROP-BASE-RALLY VALIDATION:
    // 1. DROP: Price dropped INTO the base (high before pivot is significantly above pivot high)
    has_drop = not na(htf_high_before_pivot) and htf_high_before_pivot > zone_top

    // 2. BASE: The pivot itself is the base (consolidation area)

    // 3. RALLY: Price rallied sharply AFTER the base (high after pivot is significantly above pivot high)
    has_rally = not na(htf_high_after_pivot) and htf_high_after_pivot > zone_top

    // Valid demand zone requires Drop-Base-Rally pattern
    valid_demand_zone = has_drop and has_rally

    // Only create zone if it follows Drop-Base-Rally pattern
    if valid_demand_zone
        // Check if zone overlaps with existing zones
        is_duplicate = false
        if array.size(demand_zones) > 0
            for i = 0 to array.size(demand_zones) - 1
                existing_zone = array.get(demand_zones, i)
                existing_top = box.get_top(existing_zone)
                existing_bottom = box.get_bottom(existing_zone)

                // Check for overlap
                if not (zone_bottom > existing_top or zone_top < existing_bottom)
                    is_duplicate := true
                    break

        if not is_duplicate
            // Remove oldest zone if at max capacity
            if array.size(demand_zones) >= max_zones
                old_box = array.shift(demand_zones)
                box.delete(old_box)
                old_extended_box = array.shift(extended_demand_zones)
                box.delete(old_extended_box)
                array.shift(demand_zone_trade_count)  // Remove trade count for oldest zone
                array.shift(demand_zone_start_time)  // Remove start time for oldest zone

            // Create new demand zone
            zone_box = box.new(time, zone_top, time, zone_bottom,
                              xloc=xloc.bar_time, extend=extend.right,
                              border_color=demand_color, bgcolor=demand_color,
                              border_width=1)
            array.push(demand_zones, zone_box)
            array.push(demand_zone_trade_count, 0)  // Initialize trade count to 0
            array.push(demand_zone_start_time, time)  // Store zone creation time

            // Create extended demand zone (same height above the original zone)
            zone_height = zone_top - zone_bottom
            extended_zone_bottom = zone_top
            extended_zone_top = zone_top + zone_height

            if show_extended_zones
                extended_box = box.new(time, extended_zone_top, time, extended_zone_bottom,
                                      xloc=xloc.bar_time, extend=extend.right,
                                      border_color=extended_demand_color, bgcolor=extended_demand_color,
                                      border_width=1, border_style=line.style_dashed)
                array.push(extended_demand_zones, extended_box)
            else
                // Still need to push a placeholder to keep arrays synchronized
                array.push(extended_demand_zones, na)

            // Invalidate any SUPPLY zones that overlap with this new DEMAND zone
            if array.size(supply_zones) > 0
                for i = array.size(supply_zones) - 1 to 0
                    supply_zone = array.get(supply_zones, i)
                    supply_top = box.get_top(supply_zone)
                    supply_bottom = box.get_bottom(supply_zone)

                    // Check for overlap
                    if not (zone_bottom > supply_top or zone_top < supply_bottom)
                        // Zones overlap - invalidate the supply zone
                        box.delete(supply_zone)
                        array.remove(supply_zones, i)
                        // Delete extended zone if it exists
                        extended_supply_box = array.get(extended_supply_zones, i)
                        if not na(extended_supply_box)
                            box.delete(extended_supply_box)
                        array.remove(extended_supply_zones, i)
                        array.remove(supply_zone_trade_count, i)
                        array.remove(supply_zone_start_time, i)

// ============================================================================
// ZONE INVALIDATION - HTF CLOSES THROUGH ZONES
// ============================================================================

// Get HTF close price for invalidation checks
htf_close = request.security(syminfo.tickerid, htf, close, barmerge.gaps_off, barmerge.lookahead_off)

// Invalidate demand zones if HTF closes below them
if array.size(demand_zones) > 0
    for i = array.size(demand_zones) - 1 to 0
        zone_box = array.get(demand_zones, i)
        zone_bottom = box.get_bottom(zone_box)

        // If HTF closed below the demand zone, invalidate it
        if htf_close < zone_bottom
            box.delete(zone_box)
            array.remove(demand_zones, i)
            // Delete extended zone if it exists
            extended_box = array.get(extended_demand_zones, i)
            if not na(extended_box)
                box.delete(extended_box)
            array.remove(extended_demand_zones, i)
            array.remove(demand_zone_trade_count, i)  // Remove trade count
            array.remove(demand_zone_start_time, i)  // Remove start time

// Invalidate supply zones if HTF closes above them
if array.size(supply_zones) > 0
    for i = array.size(supply_zones) - 1 to 0
        zone_box = array.get(supply_zones, i)
        zone_top = box.get_top(zone_box)

        // If HTF closed above the supply zone, invalidate it
        if htf_close > zone_top
            box.delete(zone_box)
            array.remove(supply_zones, i)
            // Delete extended zone if it exists
            extended_box = array.get(extended_supply_zones, i)
            if not na(extended_box)
                box.delete(extended_box)
            array.remove(extended_supply_zones, i)
            array.remove(supply_zone_trade_count, i)  // Remove trade count
            array.remove(supply_zone_start_time, i)  // Remove start time

// ============================================================================
// ZONE INTERACTION DETECTION (HURDLE #1)
// ============================================================================

// Check if price is in any supply zone (including extended zone for trades)
// IMPORTANT: Extended zones only become active AFTER price enters original zone first
// IMPORTANT: Only detect zones AFTER they were created (check timestamp)
current_in_supply = false
current_supply_idx = -1
current_in_original_supply = false  // Track if in original zone (not extended)
if array.size(supply_zones) > 0
    for i = 0 to array.size(supply_zones) - 1
        zone_box = array.get(supply_zones, i)
        zone_top = box.get_top(zone_box)
        zone_bottom = box.get_bottom(zone_box)
        zone_start = array.get(supply_zone_start_time, i)

        // Only check zones that were created BEFORE or AT the current bar
        if time >= zone_start
            // First check if in ORIGINAL zone (activates extended zone)
            if high >= zone_bottom and low <= zone_top
                current_in_supply := true
                current_supply_idx := i
                current_in_original_supply := true
                break

            // Only check extended zone if this setup already activated extended zones
            if in_supply_zone and extended_zone_activated and active_supply_zone_idx == i
                zone_height = zone_top - zone_bottom
                extended_zone_bottom = zone_bottom - zone_height

                // Check if current bar is within the extended zone
                if high >= extended_zone_bottom and low < zone_bottom
                    current_in_supply := true
                    current_supply_idx := i
                    break

// Check if price is in any demand zone (including extended zone for trades)
// IMPORTANT: Extended zones only become active AFTER price enters original zone first
// IMPORTANT: Only detect zones AFTER they were created (check timestamp)
current_in_demand = false
current_demand_idx = -1
current_in_original_demand = false  // Track if in original zone (not extended)
if array.size(demand_zones) > 0
    for i = 0 to array.size(demand_zones) - 1
        zone_box = array.get(demand_zones, i)
        zone_top = box.get_top(zone_box)
        zone_bottom = box.get_bottom(zone_box)
        zone_start = array.get(demand_zone_start_time, i)

        // Only check zones that were created BEFORE or AT the current bar
        if time >= zone_start
            // First check if in ORIGINAL zone (activates extended zone)
            if high >= zone_bottom and low <= zone_top
                current_in_demand := true
                current_demand_idx := i
                current_in_original_demand := true
                break

            // Only check extended zone if this setup already activated extended zones
            if in_demand_zone and extended_zone_activated and active_demand_zone_idx == i
                zone_height = zone_top - zone_bottom
                extended_zone_top = zone_top + zone_height

                // Check if current bar is within the extended zone
                if low <= extended_zone_top and high > zone_top
                    current_in_demand := true
                    current_demand_idx := i
                    break

// ============================================================================
// SETUP INVALIDATION CHECKS
// ============================================================================

// Reset invalidation at start of each bar
setup_invalid := false
invalidation_reason := na

// INVALIDATION #1: Exited zone AND within one zone width of opposite zone
// For SUPPLY zone setups: Check if price exited supply zone and is near a demand zone
if in_supply_zone and active_supply_zone_idx >= 0 and active_supply_zone_idx < array.size(supply_zones)
    // Get active supply zone dimensions
    active_supply_box = array.get(supply_zones, active_supply_zone_idx)
    supply_top = box.get_top(active_supply_box)
    supply_bottom = box.get_bottom(active_supply_box)
    supply_zone_height = supply_top - supply_bottom

    // Check if price has EXITED the supply zone (including extended zone if activated)
    exited_supply_zone = false
    if extended_zone_activated
        // If extended zone is activated, check if price is outside both zones
        extended_bottom = supply_bottom - supply_zone_height
        if close < extended_bottom or close > supply_top
            exited_supply_zone := true
    else
        // If extended zone not activated, just check original zone
        if close < supply_bottom or close > supply_top
            exited_supply_zone := true

    // If exited, check if within one zone width of ANY demand zone
    if exited_supply_zone and array.size(demand_zones) > 0
        for i = 0 to array.size(demand_zones) - 1
            demand_box = array.get(demand_zones, i)
            demand_top = box.get_top(demand_box)
            demand_bottom = box.get_bottom(demand_box)

            // Calculate distance from current price to demand zone
            distance_to_demand = demand_bottom > close ? demand_bottom - close : close - demand_top

            // Invalidate if within one supply zone width of the demand zone
            if distance_to_demand <= supply_zone_height
                setup_invalid := true
                invalidation_reason := "Exited zone and within 1 zone width of opposite zone"
                in_supply_zone := false
                extended_zone_activated := false
                hurdle2_complete := false
                waiting_for_retrace := false
                trade_direction := na
                break

// For DEMAND zone setups: Check if price exited demand zone and is near a supply zone
if in_demand_zone and active_demand_zone_idx >= 0 and active_demand_zone_idx < array.size(demand_zones)
    // Get active demand zone dimensions
    active_demand_box = array.get(demand_zones, active_demand_zone_idx)
    demand_top = box.get_top(active_demand_box)
    demand_bottom = box.get_bottom(active_demand_box)
    demand_zone_height = demand_top - demand_bottom

    // Check if price has EXITED the demand zone (including extended zone if activated)
    exited_demand_zone = false
    if extended_zone_activated
        // If extended zone is activated, check if price is outside both zones
        extended_top = demand_top + demand_zone_height
        if close > extended_top or close < demand_bottom
            exited_demand_zone := true
    else
        // If extended zone not activated, just check original zone
        if close > demand_top or close < demand_bottom
            exited_demand_zone := true

    // If exited, check if within one zone width of ANY supply zone
    if exited_demand_zone and array.size(supply_zones) > 0
        for i = 0 to array.size(supply_zones) - 1
            supply_box = array.get(supply_zones, i)
            supply_top = box.get_top(supply_box)
            supply_bottom = box.get_bottom(supply_box)

            // Calculate distance from current price to supply zone
            distance_to_supply = supply_bottom > close ? supply_bottom - close : close - supply_top

            // Invalidate if within one demand zone width of the supply zone
            if distance_to_supply <= demand_zone_height
                setup_invalid := true
                invalidation_reason := "Exited zone and within 1 zone width of opposite zone"
                in_demand_zone := false
                extended_zone_activated := false
                hurdle2_complete := false
                waiting_for_retrace := false
                trade_direction := na
                break

// INVALIDATION #2: Zones too close - insufficient room for 2:1 R:R
// Check if active setup has enough room for target before hitting opposite zone
if in_supply_zone and not na(entry_candle_low) and array.size(demand_zones) > 0
    // Find nearest demand zone
    nearest_demand_top = 0.0
    for i = 0 to array.size(demand_zones) - 1
        zone_box = array.get(demand_zones, i)
        zone_top = box.get_top(zone_box)
        if zone_top < entry_candle_low and (nearest_demand_top == 0.0 or zone_top > nearest_demand_top)
            nearest_demand_top := zone_top

    // Calculate required room for 2:1 R:R
    if nearest_demand_top > 0.0
        stop_distance = two_ticks
        required_target_distance = stop_distance * risk_reward
        available_distance = entry_candle_low - nearest_demand_top

        if available_distance < required_target_distance
            setup_invalid := true
            invalidation_reason := "Zones too close for " + str.tostring(risk_reward, "#.#") + ":1 R:R"
            in_supply_zone := false
            extended_zone_activated := false
            hurdle2_complete := false
            waiting_for_retrace := false
            trade_direction := na

if in_demand_zone and not na(entry_candle_high) and array.size(supply_zones) > 0
    // Find nearest supply zone
    nearest_supply_bottom = 999999.0
    for i = 0 to array.size(supply_zones) - 1
        zone_box = array.get(supply_zones, i)
        zone_bottom = box.get_bottom(zone_box)
        if zone_bottom > entry_candle_high and (nearest_supply_bottom == 999999.0 or zone_bottom < nearest_supply_bottom)
            nearest_supply_bottom := zone_bottom

    // Calculate required room for 2:1 R:R
    if nearest_supply_bottom < 999999.0
        stop_distance = two_ticks
        required_target_distance = stop_distance * risk_reward
        available_distance = nearest_supply_bottom - entry_candle_high

        if available_distance < required_target_distance
            setup_invalid := true
            invalidation_reason := "Zones too close for " + str.tostring(risk_reward, "#.#") + ":1 R:R"
            in_demand_zone := false
            extended_zone_activated := false
            hurdle2_complete := false
            waiting_for_retrace := false
            trade_direction := na

// INVALIDATION #3: Extended zones overlap - no trade area
// Check if active supply zone's extended zone overlaps with any demand zone's extended zone
if in_supply_zone and active_supply_zone_idx >= 0 and active_supply_zone_idx < array.size(supply_zones)
    // Get active supply zone and its extended zone boundaries
    active_supply_box = array.get(supply_zones, active_supply_zone_idx)
    supply_top = box.get_top(active_supply_box)
    supply_bottom = box.get_bottom(active_supply_box)
    supply_zone_height = supply_top - supply_bottom
    supply_extended_bottom = supply_bottom - supply_zone_height
    supply_extended_top = supply_bottom

    // Check all demand zones for extended zone overlap
    if array.size(demand_zones) > 0
        for i = 0 to array.size(demand_zones) - 1
            demand_box = array.get(demand_zones, i)
            demand_top = box.get_top(demand_box)
            demand_bottom = box.get_bottom(demand_box)
            demand_zone_height = demand_top - demand_bottom
            demand_extended_top = demand_top + demand_zone_height
            demand_extended_bottom = demand_top

            // Check if extended zones overlap
            if not (supply_extended_bottom > demand_extended_top or supply_extended_top < demand_extended_bottom)
                setup_invalid := true
                invalidation_reason := "Extended zones overlap - no trade area"
                in_supply_zone := false
                extended_zone_activated := false
                hurdle2_complete := false
                waiting_for_retrace := false
                trade_direction := na
                break

// Check if active demand zone's extended zone overlaps with any supply zone's extended zone
if in_demand_zone and active_demand_zone_idx >= 0 and active_demand_zone_idx < array.size(demand_zones)
    // Get active demand zone and its extended zone boundaries
    active_demand_box = array.get(demand_zones, active_demand_zone_idx)
    demand_top = box.get_top(active_demand_box)
    demand_bottom = box.get_bottom(active_demand_box)
    demand_zone_height = demand_top - demand_bottom
    demand_extended_top = demand_top + demand_zone_height
    demand_extended_bottom = demand_top

    // Check all supply zones for extended zone overlap
    if array.size(supply_zones) > 0
        for i = 0 to array.size(supply_zones) - 1
            supply_box = array.get(supply_zones, i)
            supply_top = box.get_top(supply_box)
            supply_bottom = box.get_bottom(supply_box)
            supply_zone_height = supply_top - supply_bottom
            supply_extended_bottom = supply_bottom - supply_zone_height
            supply_extended_top = supply_bottom

            // Check if extended zones overlap
            if not (demand_extended_bottom > supply_extended_top or demand_extended_top < supply_extended_bottom)
                setup_invalid := true
                invalidation_reason := "Extended zones overlap - no trade area"
                in_demand_zone := false
                extended_zone_activated := false
                hurdle2_complete := false
                waiting_for_retrace := false
                trade_direction := na
                break

// ============================================================================
// HURDLE #1: ENTERING HTF ZONE
// ============================================================================

// Entering supply zone for first time (HURDLE #1 for shorts)
// IMPORTANT: Must enter ORIGINAL zone, not extended zone
// Once activated, stays active until invalidated by other conditions
// Check if max trades per zone has been reached
zone_trade_count_ok = true
if current_in_original_supply and current_supply_idx >= 0
    zone_trade_count_ok := array.get(supply_zone_trade_count, current_supply_idx) < max_trades_per_zone

// Only trigger Hurdle #1 when entering the ORIGINAL zone (not extended)
if current_in_original_supply and not in_supply_zone and not setup_invalid and zone_trade_count_ok
    in_supply_zone := true
    active_supply_zone_idx := current_supply_idx
    extended_zone_activated := false  // Reset - will activate when price enters original zone
    hurdle2_complete := false
    waiting_for_retrace := false
    ob_formed := false
    ob_high := na
    ob_low := na
    ob_start_bar := na
    ob_end_bar := na
    entry_candle_high := na
    entry_candle_low := na
    entry_candle_bar := na
    hurdle2_pierce_level := na
    trade_direction := "short_setup"
    invalidation_reason := na

// Activate extended zone when price enters original supply zone
if in_supply_zone and current_in_original_supply
    extended_zone_activated := true

// Entering demand zone for first time (HURDLE #1 for longs)
// IMPORTANT: Must enter ORIGINAL zone, not extended zone
// Once activated, stays active until invalidated by other conditions
// Check if max trades per zone has been reached
zone_trade_count_ok := true
if current_in_original_demand and current_demand_idx >= 0
    zone_trade_count_ok := array.get(demand_zone_trade_count, current_demand_idx) < max_trades_per_zone

// Only trigger Hurdle #1 when entering the ORIGINAL zone (not extended)
if current_in_original_demand and not in_demand_zone and not setup_invalid and zone_trade_count_ok
    in_demand_zone := true
    active_demand_zone_idx := current_demand_idx
    extended_zone_activated := false  // Reset - will activate when price enters original zone
    hurdle2_complete := false
    waiting_for_retrace := false
    ob_formed := false
    ob_high := na
    ob_low := na
    ob_start_bar := na
    ob_end_bar := na
    entry_candle_high := na
    entry_candle_low := na
    entry_candle_bar := na
    hurdle2_pierce_level := na
    trade_direction := "long_setup"
    invalidation_reason := na

// Activate extended zone when price enters original demand zone
if in_demand_zone and current_in_original_demand
    extended_zone_activated := true

// NOTE: Hurdle #1 stays active even if price leaves the zone temporarily
// It will only be invalidated by specific conditions (to be added later)
// DO NOT reset in_supply_zone or in_demand_zone here

// ============================================================================
// ORDER BLOCK FORMATION & HURDLE #2
// ============================================================================

// FOR SHORTS: Track bullish order block formation, then wait for reversal below it
if in_supply_zone and not hurdle2_complete
    is_bullish = close > open

    // Build the order block with consecutive bullish candles
    if is_bullish
        if na(ob_start_bar)
            // Start tracking order block - draw blue line at first bullish candle's low
            ob_start_bar := bar_index
            ob_high := high
            ob_low := low
            entry_candle_high := high  // Track the highest candle
            entry_candle_low := low
            entry_candle_bar := bar_index
            hurdle2_pierce_level := low  // Store the pierce level (blue line)
            blue_line_start_bar := bar_index  // Track when blue line was created

            // Draw blue dotted line at the low of the FIRST bullish candle
            // Don't delete old ones - they stay on chart as history
            hurdle2_pierce_line := line.new(time, low, time + (time - time[1]) * 10, low, xloc=xloc.bar_time, color=color.new(color.blue, 0), width=2, style=line.style_dotted, extend=extend.none)
        else
            // Extend order block
            ob_high := math.max(ob_high, high)
            ob_low := math.min(ob_low, low)

            // Update entry candle to be the one with the highest high (regardless of color)
            if high > entry_candle_high
                entry_candle_high := high
                entry_candle_low := low
                entry_candle_bar := bar_index

        ob_end_bar := bar_index
        ob_formed := true

        // Update yellow box on entry candle only
        // Delete and recreate to update position, but old setups' boxes stay on chart
        if not na(order_block_box)
            box.delete(order_block_box)

        // Draw yellow box on the entry candle (highest candle)
        entry_candle_time = time[bar_index - entry_candle_bar]
        order_block_box := box.new(entry_candle_time, entry_candle_high, time, entry_candle_low, xloc=xloc.bar_time, border_color=color.new(color.yellow, 30), bgcolor=color.new(color.yellow, 90), border_width=2, border_style=line.style_solid, extend=extend.none)
    else
        // Non-bullish candle - check if it should still be part of the order block range
        if not na(ob_start_bar)
            // Extend the range if this bar overlaps
            ob_high := math.max(ob_high, high)
            ob_low := math.min(ob_low, low)

            // Update entry candle if this has the highest high
            if high > entry_candle_high
                entry_candle_high := high
                entry_candle_low := low
                entry_candle_bar := bar_index

                // Update yellow box to new entry candle
                if not na(order_block_box)
                    box.delete(order_block_box)

                entry_candle_time = time[bar_index - entry_candle_bar]
                order_block_box := box.new(entry_candle_time, entry_candle_high, time, entry_candle_low, xloc=xloc.bar_time, border_color=color.new(color.yellow, 30), bgcolor=color.new(color.yellow, 90), border_width=2, border_style=line.style_solid, extend=extend.none)

    // Extend yellow box while setup is active (before trade entry or invalidation)
    if not na(order_block_box) and not waiting_for_retrace
        box.set_right(order_block_box, time)

    // Extend blue line with limits: max 10 bars OR until price closes through it
    if not na(hurdle2_pierce_line) and not na(blue_line_start_bar)
        bars_since_blue = bar_index - blue_line_start_bar
        price_closed_through = close < hurdle2_pierce_level

        // Stop extending after 10 bars or if price closed through
        if bars_since_blue <= 10 and not price_closed_through
            line.set_x2(hurdle2_pierce_line, time)

    // Check if price reversed and closed below the BLUE LINE (HURDLE #2 COMPLETE)
    if ob_formed and not na(hurdle2_pierce_level) and close < hurdle2_pierce_level
        hurdle2_complete := true
        waiting_for_retrace := true

        // Draw red entry trigger line at the BOTTOM of the entry candle (where we enter short)
        // Don't delete old ones - they stay on chart as history
        entry_time = time[bar_index - entry_candle_bar]
        entry_trigger_line := line.new(entry_time, entry_candle_low, time, entry_candle_low, xloc=xloc.bar_time, color=color.new(color.red, 0), width=2, style=line.style_solid, extend=extend.none)

        // Annotate entry candle - don't delete old labels, they stay on chart as history
        // Position label further above the candle high for better visibility
        if show_swing_labels
            label_offset = (entry_candle_high - entry_candle_low) * 2  // Offset by 2x candle height
            swing_label := label.new(entry_candle_bar, entry_candle_high + label_offset, "ENTRY ZONE\n(Short @ Bottom)", style=label.style_label_down, color=color.new(color.red, 20), textcolor=color.white, size=size.small)

// FOR LONGS: Track bearish order block formation, then wait for reversal above it
if in_demand_zone and not hurdle2_complete
    is_bearish = close < open

    // Build the order block with consecutive bearish candles
    if is_bearish
        if na(ob_start_bar)
            // Start tracking order block - draw blue line at first bearish candle's high
            ob_start_bar := bar_index
            ob_high := high
            ob_low := low
            entry_candle_high := high  // Track the lowest candle
            entry_candle_low := low
            entry_candle_bar := bar_index
            hurdle2_pierce_level := high  // Store the pierce level (blue line)
            blue_line_start_bar := bar_index  // Track when blue line was created

            // Draw blue dotted line at the high of the FIRST bearish candle
            // Don't delete old ones - they stay on chart as history
            hurdle2_pierce_line := line.new(time, high, time + (time - time[1]) * 10, high, xloc=xloc.bar_time, color=color.new(color.blue, 0), width=2, style=line.style_dotted, extend=extend.none)
        else
            // Extend order block
            ob_high := math.max(ob_high, high)
            ob_low := math.min(ob_low, low)

            // Update entry candle to be the one with the lowest low (regardless of color)
            if low < entry_candle_low
                entry_candle_high := high
                entry_candle_low := low
                entry_candle_bar := bar_index

        ob_end_bar := bar_index
        ob_formed := true

        // Update yellow box on entry candle only
        if not na(order_block_box)
            box.delete(order_block_box)

        // Draw yellow box on the entry candle (lowest candle)
        entry_candle_time = time[bar_index - entry_candle_bar]
        order_block_box := box.new(entry_candle_time, entry_candle_high, time + (time - time[1]) * 50, entry_candle_low, xloc=xloc.bar_time, border_color=color.new(color.yellow, 30), bgcolor=color.new(color.yellow, 90), border_width=2, border_style=line.style_solid)
    else
        // Non-bearish candle - check if it should still be part of the order block range
        if not na(ob_start_bar)
            // Extend the range if this bar overlaps
            ob_high := math.max(ob_high, high)
            ob_low := math.min(ob_low, low)

            // Update entry candle if this has the lowest low
            if low < entry_candle_low
                entry_candle_high := high
                entry_candle_low := low
                entry_candle_bar := bar_index

                // Update yellow box to new entry candle
                if not na(order_block_box)
                    box.delete(order_block_box)

                entry_candle_time = time[bar_index - entry_candle_bar]
                order_block_box := box.new(entry_candle_time, entry_candle_high, time, entry_candle_low, xloc=xloc.bar_time, border_color=color.new(color.yellow, 30), bgcolor=color.new(color.yellow, 90), border_width=2, border_style=line.style_solid, extend=extend.none)

    // Extend yellow box while setup is active (before trade entry or invalidation)
    if not na(order_block_box) and not waiting_for_retrace
        box.set_right(order_block_box, time)

    // Extend blue line with limits: max 10 bars OR until price closes through it
    if not na(hurdle2_pierce_line) and not na(blue_line_start_bar)
        bars_since_blue = bar_index - blue_line_start_bar
        price_closed_through = close > hurdle2_pierce_level

        // Stop extending after 10 bars or if price closed through
        if bars_since_blue <= 10 and not price_closed_through
            line.set_x2(hurdle2_pierce_line, time)

    // Check if price reversed and closed above the BLUE LINE (HURDLE #2 COMPLETE)
    if ob_formed and not na(hurdle2_pierce_level) and close > hurdle2_pierce_level
        hurdle2_complete := true
        waiting_for_retrace := true

        // Draw green entry trigger line at the TOP of the entry candle (where we enter long)
        // Don't delete old ones - they stay on chart as history
        entry_time = time[bar_index - entry_candle_bar]
        entry_trigger_line := line.new(entry_time, entry_candle_high, time, entry_candle_high, xloc=xloc.bar_time, color=color.new(color.green, 0), width=2, style=line.style_solid, extend=extend.none)

        // Annotate entry candle - don't delete old labels, they stay on chart as history
        // Position label further below the candle low for better visibility
        if show_swing_labels
            label_offset = (entry_candle_high - entry_candle_low) * 2  // Offset by 2x candle height
            swing_label := label.new(entry_candle_bar, entry_candle_low - label_offset, "ENTRY ZONE\n(Long @ Top)", style=label.style_label_up, color=color.new(color.green, 20), textcolor=color.white, size=size.small)

// ============================================================================
// EXTEND ACTIVE SETUP VISUALIZATIONS
// ============================================================================

// Extend entry trigger line while waiting for retrace (until trade enters or invalidates)
if waiting_for_retrace and not na(entry_trigger_line) and strategy.position_size == 0 and not setup_invalid
    line.set_x2(entry_trigger_line, time)

// ============================================================================
// ENTRY LOGIC: RETRACE TO ENTRY ZONE
// ============================================================================

// Close positions outside session if enabled
if close_outside_session and not in_session and strategy.position_size != 0
    strategy.close_all("Outside Session")

// SHORT ENTRY: Waiting for retrace to entry candle bottom
// IMPORTANT: Only allow entry if price is currently in the original zone or extended zone
if waiting_for_retrace and trade_direction == "short_setup" and not na(entry_candle_low) and in_session
    // Check if price is in valid entry zone (original or extended if activated)
    in_valid_entry_zone = current_in_supply

    // Enter short when price retraces back to the entry candle bottom (low) AND is in valid zone
    if high >= entry_candle_low and strategy.position_size == 0 and in_valid_entry_zone
        entry_price = entry_candle_low  // Entry at bottom of entry candle
        stop_price = entry_candle_high + two_ticks  // Stop 2 ticks above entry candle high
        risk_amount = stop_price - entry_price
        target_price = entry_price - (risk_amount * risk_reward)

        // Calculate position size
        contracts = 1
        if risk_amount > 0
            contracts := math.floor(risk_per_trade / (risk_amount * syminfo.pointvalue))
            contracts := math.max(1, math.min(contracts, max_contracts))

        // Enter trade
        strategy.entry("Short", strategy.short, qty=contracts, limit=entry_price)

        // Increment trade count for this supply zone
        if active_supply_zone_idx >= 0 and active_supply_zone_idx < array.size(supply_zone_trade_count)
            current_count = array.get(supply_zone_trade_count, active_supply_zone_idx)
            array.set(supply_zone_trade_count, active_supply_zone_idx, current_count + 1)

        // Draw trade lines
        if not na(entry_line)
            line.delete(entry_line)
            line.delete(stop_line)
            line.delete(tp_line)
            label.delete(trade_label)

        entry_line := line.new(time, entry_price, time, entry_price,
                              xloc=xloc.bar_time, extend=extend.right,
                              color=color.white, width=2, style=line.style_dashed)
        stop_line := line.new(time, stop_price, time, stop_price,
                             xloc=xloc.bar_time, extend=extend.right,
                             color=color.red, width=2)
        tp_line := line.new(time, target_price, time, target_price,
                           xloc=xloc.bar_time, extend=extend.right,
                           color=color.green, width=2)

        trade_info = "SHORT\nQty: " + str.tostring(contracts, "#") + "\nEntry: " + str.tostring(entry_price, "#.##") + "\nStop: " + str.tostring(stop_price, "#.##") + " (+2 ticks above)\nTarget: " + str.tostring(target_price, "#.##") + "\nR:R = 1:" + str.tostring(risk_reward, "#.#")

        trade_label := label.new(time, stop_price, trade_info, xloc=xloc.bar_time, style=label.style_label_up, color=color.new(color.red, 20), textcolor=color.white, size=size.small)

        // Set exit orders
        strategy.exit("Exit Short", "Short", stop=stop_price, limit=target_price)

        // Reset flags
        waiting_for_retrace := false

// LONG ENTRY: Waiting for retrace to entry candle top
// IMPORTANT: Only allow entry if price is currently in the original zone or extended zone
if waiting_for_retrace and trade_direction == "long_setup" and not na(entry_candle_high) and in_session
    // Check if price is in valid entry zone (original or extended if activated)
    in_valid_entry_zone = current_in_demand

    // Enter long when price retraces back to the entry candle top (high) AND is in valid zone
    if low <= entry_candle_high and strategy.position_size == 0 and in_valid_entry_zone
        entry_price = entry_candle_high  // Entry at top of entry candle
        stop_price = entry_candle_low - two_ticks  // Stop 2 ticks below entry candle low
        risk_amount = entry_price - stop_price
        target_price = entry_price + (risk_amount * risk_reward)

        // Calculate position size
        contracts = 1
        if risk_amount > 0
            contracts := math.floor(risk_per_trade / (risk_amount * syminfo.pointvalue))
            contracts := math.max(1, math.min(contracts, max_contracts))

        // Enter trade
        strategy.entry("Long", strategy.long, qty=contracts, limit=entry_price)

        // Increment trade count for this demand zone
        if active_demand_zone_idx >= 0 and active_demand_zone_idx < array.size(demand_zone_trade_count)
            current_count = array.get(demand_zone_trade_count, active_demand_zone_idx)
            array.set(demand_zone_trade_count, active_demand_zone_idx, current_count + 1)

        // Draw trade lines
        if not na(entry_line)
            line.delete(entry_line)
            line.delete(stop_line)
            line.delete(tp_line)
            label.delete(trade_label)

        entry_line := line.new(time, entry_price, time, entry_price,
                              xloc=xloc.bar_time, extend=extend.right,
                              color=color.white, width=2, style=line.style_dashed)
        stop_line := line.new(time, stop_price, time, stop_price,
                             xloc=xloc.bar_time, extend=extend.right,
                             color=color.red, width=2)
        tp_line := line.new(time, target_price, time, target_price,
                           xloc=xloc.bar_time, extend=extend.right,
                           color=color.green, width=2)

        trade_info = "LONG\nQty: " + str.tostring(contracts, "#") + "\nEntry: " + str.tostring(entry_price, "#.##") + "\nStop: " + str.tostring(stop_price, "#.##") + " (-2 ticks below)\nTarget: " + str.tostring(target_price, "#.##") + "\nR:R = 1:" + str.tostring(risk_reward, "#.#")

        trade_label := label.new(time, stop_price, trade_info, xloc=xloc.bar_time, style=label.style_label_down, color=color.new(color.green, 20), textcolor=color.white, size=size.small)

        // Set exit orders
        strategy.exit("Exit Long", "Long", stop=stop_price, limit=target_price)

        // Reset flags
        waiting_for_retrace := false

// ============================================================================
// DEBUG TABLE
// ============================================================================

if show_debug
    var table debug_table = table.new(position.top_right, 2, 14, border_width=1,
                                      bgcolor=color.new(color.black, 20),
                                      frame_color=color.new(color.gray, 50),
                                      frame_width=2)

    table.cell(debug_table, 0, 0, "Parameter", bgcolor=color.new(color.black, 30),
              text_color=color.white, text_size=size.small)
    table.cell(debug_table, 1, 0, "Value", bgcolor=color.new(color.black, 30),
              text_color=color.white, text_size=size.small)

    table.cell(debug_table, 0, 1, "HTF", text_size=size.small, text_color=color.white,
              bgcolor=color.new(color.black, 40))
    table.cell(debug_table, 1, 1, htf, text_size=size.small, text_color=color.white,
              bgcolor=color.new(color.black, 40))

    table.cell(debug_table, 0, 2, "Supply Zones", text_size=size.small, text_color=color.white,
              bgcolor=color.new(color.black, 40))
    table.cell(debug_table, 1, 2, str.tostring(array.size(supply_zones)), text_size=size.small,
              text_color=color.white, bgcolor=color.new(color.black, 40))

    table.cell(debug_table, 0, 3, "Demand Zones", text_size=size.small, text_color=color.white,
              bgcolor=color.new(color.black, 40))
    table.cell(debug_table, 1, 3, str.tostring(array.size(demand_zones)), text_size=size.small,
              text_color=color.white, bgcolor=color.new(color.black, 40))

    table.cell(debug_table, 0, 4, "Hurdle #1", text_size=size.small, text_color=color.white,
              bgcolor=color.new(color.black, 40))
    hurdle1_text = in_supply_zone ? "In Supply " : in_demand_zone ? "In Demand " : "Not in Zone"
    hurdle1_color = in_supply_zone ? color.new(color.red, 60) : in_demand_zone ? color.new(color.green, 60) : color.new(color.black, 40)
    table.cell(debug_table, 1, 4, hurdle1_text, text_size=size.small, text_color=color.white,
              bgcolor=hurdle1_color)

    table.cell(debug_table, 0, 5, "Hurdle #2", text_size=size.small, text_color=color.white,
              bgcolor=color.new(color.black, 40))
    hurdle2_text = hurdle2_complete ? "Reversed " : ob_formed ? "OB Forming" : "Waiting"
    hurdle2_color = hurdle2_complete ? color.new(color.green, 60) : ob_formed ? color.new(color.yellow, 60) : color.new(color.black, 40)
    table.cell(debug_table, 1, 5, hurdle2_text, text_size=size.small, text_color=color.white,
              bgcolor=hurdle2_color)

    table.cell(debug_table, 0, 6, "OB High", text_size=size.small, text_color=color.white,
              bgcolor=color.new(color.black, 40))
    table.cell(debug_table, 1, 6, na(ob_high) ? "N/A" : str.tostring(ob_high, "#.##"),
              text_size=size.small, text_color=color.white, bgcolor=color.new(color.black, 40))

    table.cell(debug_table, 0, 7, "OB Low", text_size=size.small, text_color=color.white,
              bgcolor=color.new(color.black, 40))
    table.cell(debug_table, 1, 7, na(ob_low) ? "N/A" : str.tostring(ob_low, "#.##"),
              text_size=size.small, text_color=color.white, bgcolor=color.new(color.black, 40))

    table.cell(debug_table, 0, 8, "Entry Candle", text_size=size.small, text_color=color.white,
              bgcolor=color.new(color.black, 40))
    entry_candle_text = na(entry_candle_bar) ? "N/A" : str.tostring(bar_index - entry_candle_bar) + " bars ago"
    table.cell(debug_table, 1, 8, entry_candle_text, text_size=size.small, text_color=color.white,
              bgcolor=color.new(color.black, 40))

    table.cell(debug_table, 0, 9, "Setup", text_size=size.small, text_color=color.white,
              bgcolor=color.new(color.black, 40))
    setup_text = waiting_for_retrace ? "Waiting for Retrace" : na(trade_direction) ? "N/A" : trade_direction
    setup_color = waiting_for_retrace ? color.new(color.yellow, 60) : color.new(color.black, 40)
    table.cell(debug_table, 1, 9, setup_text, text_size=size.small, text_color=color.white,
              bgcolor=setup_color)

    table.cell(debug_table, 0, 10, "Position", text_size=size.small, text_color=color.white,
              bgcolor=color.new(color.black, 40))
    pos_text = strategy.position_size > 0 ? "LONG" : strategy.position_size < 0 ? "SHORT" : "None"
    pos_color = strategy.position_size != 0 ? color.new(color.blue, 60) : color.new(color.black, 40)
    table.cell(debug_table, 1, 10, pos_text, text_size=size.small, text_color=color.white,
              bgcolor=pos_color)

    table.cell(debug_table, 0, 11, "Position Size", text_size=size.small, text_color=color.white,
              bgcolor=color.new(color.black, 40))
    table.cell(debug_table, 1, 11, str.tostring(math.abs(strategy.position_size), "#") + " contracts",
              text_size=size.small, text_color=color.white, bgcolor=color.new(color.black, 40))

    table.cell(debug_table, 0, 12, "Setup Status", text_size=size.small, text_color=color.white,
              bgcolor=color.new(color.black, 40))
    status_text = setup_invalid ? "INVALID" : (in_supply_zone or in_demand_zone) ? "VALID" : "N/A"
    status_color = setup_invalid ? color.new(color.red, 40) : (in_supply_zone or in_demand_zone) ? color.new(color.green, 60) : color.new(color.black, 40)
    table.cell(debug_table, 1, 12, status_text, text_size=size.small, text_color=color.white,
              bgcolor=status_color)

    table.cell(debug_table, 0, 13, "Invalidation Reason", text_size=size.small, text_color=color.white,
              bgcolor=color.new(color.black, 40))
    invalid_reason_text = na(invalidation_reason) ? "None" : invalidation_reason
    invalid_reason_color = na(invalidation_reason) ? color.new(color.black, 40) : color.new(color.orange, 60)
    table.cell(debug_table, 1, 13, invalid_reason_text, text_size=size.small, text_color=color.white,
              bgcolor=invalid_reason_color)
