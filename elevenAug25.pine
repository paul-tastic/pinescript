// Â© mach2fx
//@version=5
strategy("Eleven Aug 25",
     overlay=true,
     calc_on_order_fills = true,
     use_bar_magnifier = true,
     initial_capital = 500,
     default_qty_type = strategy.percent_of_equity,
     default_qty_value = 100,
     commission_type = strategy.commission.cash_per_contract,
     commission_value = 1.99)

     // set trading hours
     // freeze zones just prior
     // set reset time for variables
    //  1 contract static size
    // exit all trades by trading hours
    // use ATR for SL and TP
    // use VIX for SL/ATR ratio
    // 1:1 breakeven
    // 1 loss/day stop trading
    // 150% negates trade

// IDEAS: consider entering at half-entry into zone?
// if it leaves the zone during cool down, consider that a valid setup still

// TODO: lookback from pivots to see if a swing candle within 10 back and use that
// TODO: clean up user inputs UI
// TODO: add tooltips for the inputs

// new specifics
// user inputs:
    // trading hours 
    // SL and TP
    // confluences to use (checkbox)
    // enter mid zone
// identify pivot point 
// if price crosses through a resistance, that becomes supply/demand range 
// grab high and low of that candle 
// start counting L and R last 75 bars if price retested that range 
    // if > 2 retests, that becomes a support/resistance zone 
    // keep last 5 of each in an array 
// confluences to enter:
    // price rejects off 50sma 
    // opposite/reversal candle forms
    // price re-enters the zone 
    // no falling knife candle (increase in relative volume)

// === Inputs ===

enum tz
    utc  = "UTC"
    exch = ""
    ny   = "America/New_York"
    chi  = "America/Chicago"
    lon  = "Europe/London"
    tok  = "Asia/Tokyo"



timeZoneInput = str.tostring(input.enum(tz.ny, "Session Timezone"))

lockZonesHighlightColor = input.color(color.new(#047e2f, 90), title="No Trade cool-off Session Highlight Color", group="Strategy Times")

lockZonesStartHour = int(str.tonumber(input.string(defval="09", title="Lock Zones Time", group="Strategy Times", inline="Lock Zones Time", options = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"])))
lockZonesStartMinute = int(str.tonumber(input.string(defval="15", title=":", group="Strategy Times", inline="Lock Zones Time", options = ["00", "15", "30", "45", "59"])))

tradeHighlightColor = input.color(color.new(#04ff00, 83), title="Trading Session Highlight Color", group="Strategy Times")

tradeStartHour = int(str.tonumber(input.string(defval="09", title="Trading Start Time", group="Strategy Times", inline="Start Trading Times", options = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"])))
tradeStartMinute = int(str.tonumber(input.string(defval="30", title=":", group="Strategy Times", inline="Start Trading Times", options = ["00", "15", "30", "35", "45"])))
tradeEndHour = int(str.tonumber(input.string(defval="16", title="Trading end time", group="Strategy Times", inline="End Trading Times", options = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"])))
tradeEndMinute   = int(str.tonumber(input.string(defval="45", title=":", group="Strategy Times", inline="End Trading Times", options = ["00", "15", "30", "45"])))

pivotStrength = input.int(5, title="Pivot Strength (Left & Right Bars)", minval=1)
showTables = input.bool(true, title="Show debug tables")
stopLossRatio = input.int(defval = 2, title="Stop Loss / ATR ratio 1:? ", minval = 1)
breakEvenActivated = input.bool(false, title = 'Break Even at 1:1 Activated')
reduceSL = input.bool(true, title="reduce stop loss to $500 risk?")


// lockZone timestamp
lockZoneTimestamp = timestamp(timeZoneInput, year, month, dayofmonth, lockZonesStartHour, lockZonesStartMinute)

// trade timestamps
tradeStart = timestamp(timeZoneInput, year, month, dayofmonth, tradeStartHour, tradeStartMinute)
tradeEnd  = timestamp(timeZoneInput, year, month, dayofmonth, tradeEndHour, tradeEndMinute)
closeAllOpenTrades  = timestamp(timeZoneInput, year, month, dayofmonth, 16, 55)

inLockZonesSession = time == lockZoneTimestamp
inTradeSession = time > tradeStart and time <= tradeEnd

bgColor = if inLockZonesSession
    lockZonesHighlightColor
else if inTradeSession
    tradeHighlightColor
else 
    na

bgcolor(bgColor)

// === Arrays to Store Zone Data ===
var float[] resistancePrices = array.new_float()
var float[] supportPrices = array.new_float()
var int[] resistanceTimes = array.new_int()
var int[] supportTimes = array.new_int()
var box[] resistanceBoxes = array.new_box()
var box[] supportBoxes = array.new_box()
var bool zonesSet = false
var float buyLimitPrice = 0.0
var float sellLimitPrice = 0.0
var bool noTradesTaken = true
var bool longTradeSetUp = false
var bool shortTradeSetUp = false
var alreadyLabeled = false // for debugging steps

var bool longTradeValid = true
var bool shortTradeValid = true
var bool alreadyTradedShort = false
var bool alreadyTradedLong = false
var bool lostATrade = false

var bool longSignal = false
var bool shortSignal = false
var float i_fx_risk = 0.1 // percentage of risk
var float longTradeTP = 0.0
var float longTradeSL = 0.0
var float longTradeEntry = 0.0
var float shortTradeTP = 0.0
var float shortTradeSL = 0.0
var float shortTradeEntry = 0.0
var bool newLongTrade = false 
var bool newShortTrade = false
var int winningTradeCount = 0
var int losingTradeCount = 0
var bool alreadyLockedIn = false
var float highBar = 0
var int highIndex = 0
var float lowBar = 0
var int lowIndex = 0
var int rb0Count = 0
var int rb1Count = 0
var int sb0Count = 0
var int sb1Count = 0
var float ATR = math.round(ta.atr(14),2)
var float SL = 0 
var float TP = 0 
var string debugValue = ''
var float longBE = 0
var float shortBE = 0
var float amountRisked = SL * syminfo.pointvalue
var float positionSize = 500 / amountRisked
var float modifiedEntry = 0

zoneColorSupply = color.new(color.red, 85)
zoneColorDemand = color.new(color.green, 85)
zoneWidth = syminfo.mintick * 10
boxHeight = syminfo.mintick * 4

// ********************  methods

checkForPivot(pivotHigh, pivotLow) =>
    if (not na(pivotHigh))
        top = pivotHigh
        bottom = top - zoneWidth
        b = box.new(left=bar_index - pivotStrength, right=bar_index, top=top, bottom=bottom, bgcolor=zoneColorSupply, border_color=color.red)
        array.unshift(resistanceBoxes, b)
        array.unshift(resistancePrices, high[pivotStrength])
        array.unshift(resistanceTimes, time[pivotStrength])

    if (not na(pivotLow))
        bottom = pivotLow
        top = bottom + zoneWidth
        b = box.new(left=bar_index - pivotStrength, right=bar_index, top=top, bottom=bottom, bgcolor=zoneColorDemand, border_color=color.green)
        array.unshift(supportBoxes, b)
        array.unshift(supportPrices, low[pivotStrength])
        array.unshift(supportTimes, time[pivotStrength])


// === Invalidate Zones if Price Wicks Through ===
invalidateZones(arrBoxes, arrPrices, arrTimes) =>
    if array.size(arrBoxes) > 0
        for i = array.size(arrBoxes) - 1 to 0
            b = array.get(arrBoxes, i)
            top = box.get_top(b)
            bottom = box.get_bottom(b)
            cross = high >= bottom and low <= top
            if cross
                box.delete(b)
                array.remove(arrBoxes, i)
                array.remove(arrPrices, i)
                array.remove(arrTimes, i)

removeZones(arrBoxes, arrPrices, arrTimes) =>
    if array.size(arrBoxes) > 0
        for i = array.size(arrBoxes) - 1 to 0
            b = array.get(arrBoxes, i)
            box.delete(b)
        array.clear(arrPrices)
        array.clear(arrTimes)
        array.clear(arrBoxes)

invalidateZones(resistanceBoxes, resistancePrices, resistanceTimes)
invalidateZones(supportBoxes, supportPrices, supportTimes)

// ****************** script start
// === Pivot Detection ===
pivotHigh = ta.pivothigh(high, pivotStrength, pivotStrength)
pivotLow = ta.pivotlow(low, pivotStrength, pivotStrength)

// Draw conditional data
plotshape(newLongTrade,  style=shape.triangleup,   color=color.green, location=location.belowbar, title="Long Setup")
plotshape(newShortTrade, style=shape.triangledown, color=color.red,   location=location.abovebar, title="Short Setup")

// Draw stops & targets
plot(strategy.position_size > 0 ? longTradeSL : na,   color=color.red,   style=plot.style_linebr, title="Stop Loss")
plot(strategy.position_size > 0 ? longTradeTP : na, color=color.green, style=plot.style_linebr, title="Profit Target")
plot(strategy.position_size > 0 ? longBE : na, color=color.green, style=plot.style_linebr, title="Break Even")

plot(strategy.position_size < 0 ? shortTradeSL : na,   color=color.red,   style=plot.style_linebr, title="Stop Loss")
plot(strategy.position_size < 0 ? shortTradeTP : na, color=color.green, style=plot.style_linebr, title="Profit Target")
plot(strategy.position_size < 0 ? shortBE : na, color=color.green, style=plot.style_linebr, title="Break Even")

// paint active trade indicators
if (strategy.position_size > 0)
    line.new(x1=bar_index, x2=bar_index, y1=buyLimitPrice, y2=longTradeSL, color=color.new(#a23b3b, 50), width=6)
    line.new(x1=bar_index, x2=bar_index, y1=buyLimitPrice, y2=longTradeTP, color=color.new(#2fc016, 50), width=6)
    line.new(x1=bar_index, x2=bar_index, y1=buyLimitPrice, y2=longBE, color=color.new(#207611, 50), width=6)

if (strategy.position_size < 0)
    line.new(x1=bar_index, x2=bar_index, y1=sellLimitPrice, y2=shortTradeSL, color=color.new(#a23b3b, 50), width=6)
    line.new(x1=bar_index, x2=bar_index, y1=sellLimitPrice, y2=shortTradeTP, color=color.new(#2fc016, 50), width=6)
    line.new(x1=bar_index, x2=bar_index, y1=sellLimitPrice, y2=shortBE, color=color.new(#207611, 50), width=6)

// === Tables ===
var table resistanceTable = table.new(position.top_right, 2, 10, frame_color=color.red, border_width=1)
var table supportTable = table.new(position.bottom_right, 2, 10, frame_color=color.green, border_width=1)
var table variableTracker = table.new(position.middle_left, 2, 20, frame_color=#002b80, border_width=1)

// monitor for trade exits
if (breakEvenActivated and (strategy.position_size > 0) and (high >= longBE))
    debugValue := 'move to BE'
    longTradeSL := buyLimitPrice
    strategy.exit(id="Long", comment="Break even stop", stop=buyLimitPrice)
if (breakEvenActivated and (strategy.position_size < 0) and (low <= shortBE))
    debugValue := 'move to BE'
    shortTradeSL := sellLimitPrice
    strategy.exit(id="Short", comment="Break even stop", stop=sellLimitPrice)

ATR := math.round(ta.atr(14),2)


// Looking Session
if not inTradeSession
    // reset trading variables
    noTradesTaken := true
    longTradeSetUp := false
    shortTradeSetUp := false
    longTradeValid := true
    shortTradeValid := true
    alreadyLabeled := false
    alreadyTradedShort := false
    alreadyTradedLong := false
    newLongTrade := false
    newShortTrade := false
    lostATrade := false
   // buyLimitPrice := 0
    // sellLimitPrice := 0
    alreadyLockedIn := false
    highBar := 0
    highIndex := 0
    lowBar := 0
    lowIndex := 0
    rb0Count := 0
    rb1Count := 0
    sb0Count := 0
    sb1Count := 0
    shortTradeSL := 0
    longTradeSL := 0
    SL := 0
    TP := 0
    longBE := 0
    shortBE := 0
    debugValue := ''

    // close any open trades
    if (time >= closeAllOpenTrades and strategy.opentrades != 0)
        strategy.close_all(alert_message = "open trade detected, closing", immediately = true)
        
    // check if a pivot, and if so, create zone and boxes
    checkForPivot(pivotHigh, pivotLow)

highBar := ta.highest(high, pivotStrength)
highIndex := ta.barssince(high == highBar)
lowBar := ta.lowest(low,pivotStrength)
lowIndex := ta.barssince(low == lowBar)
 

if inLockZonesSession 

    zonesSet := true // prob can delete this one?
    var int sessEndBarIndex = tradeEnd - time
    barDuration = time - time[1]
    barsUntilFuture = math.round(sessEndBarIndex / barDuration)
    estimatedFutureBarIndex = bar_index + barsUntilFuture + 15

    if (array.size(resistanceBoxes) == 0 and not alreadyLockedIn)
        // if there aren't any valid pivots (because of a bullish premarket) use highest bar in the last pivotStrength rows back

        // highBar := ta.highest(high, pivotStrength)
        // highIndex := ta.barssince(high == highBar)
        if not na(highBar)
            top = high[highIndex]
            bottom = top - zoneWidth
            b = box.new(left=bar_index[highIndex] - pivotStrength, right=bar_index[highIndex], top=top, bottom=bottom, bgcolor=zoneColorSupply, border_color=color.red)
            array.unshift(resistanceBoxes, b)
            array.unshift(resistancePrices, high[pivotStrength])
            array.unshift(resistanceTimes, time[pivotStrength])

    if (array.size(supportBoxes) == 0 and not alreadyLockedIn)
        // if there aren't any valid pivots (because of a bearish premarket) use lowest bar in the last pivotStrength rows back
        // lowBar := ta.lowest(low,pivotStrength)
        // lowIndex := ta.barssince(low == lowBar)
        if not na(lowBar)
            bottom = low[lowIndex]
            top = bottom + zoneWidth
            b = box.new(left=bar_index[lowIndex] - pivotStrength, right=bar_index[lowIndex], top=top, bottom=bottom, bgcolor=zoneColorDemand, border_color=color.green)
            array.unshift(supportBoxes, b)
            array.unshift(supportPrices, low[pivotStrength])
            array.unshift(supportTimes, time[pivotStrength])

    // now that we have populated resistanceBoxes, set the last one for entries
    if array.size(resistanceBoxes) > 0
        alreadyLockedIn := true
        rb0 = array.get(resistanceBoxes, 0)
        resistanceBox0Top = box.get_top(rb0)

        box rb1 = na

        if array.size(resistanceBoxes) > 1
            rb1 := array.get(resistanceBoxes, 1)
            resistanceBox1Top = box.get_top(rb1)

            for i = 0 to 9
                if (high[i] <= resistanceBox0Top and high[i] >= (resistanceBox0Top - 0.01)) 
                    rb0Count += 1
                if (high[i] <= resistanceBox1Top and high[i] >= (resistanceBox1Top - 0.01))
                    rb1Count += 1

        resistanceBoxTop = (rb0Count >= rb1Count) ? box.get_top(rb0) : box.get_top(rb1)
        buyLimitPrice := resistanceBoxTop
        resistanceBoxLeft = (rb0Count >= rb1Count) ? box.get_left(rb0) : box.get_left(rb1)
        resistanceBoxBottom = resistanceBoxTop - boxHeight 
        resistanceBoxRight = estimatedFutureBarIndex
        box.new(left=resistanceBoxLeft, right=resistanceBoxRight, top=resistanceBoxTop, bottom=resistanceBoxBottom, bgcolor=zoneColorSupply, border_color=color.red)
    
    if array.size(supportBoxes) > 0
        alreadyLockedIn := true
        sb0 = array.get(supportBoxes, 0)
        supportBox0Bottom = box.get_bottom(sb0)

        box sb1 = na 

        if array.size(supportBoxes) > 1
            sb1 := array.get(supportBoxes, 1)
            supportBox1Bottom = box.get_bottom(sb1)

            for i = 0 to 9
                if (low[i] >= supportBox0Bottom and low[i] <= (supportBox0Bottom + 0.01)) 
                    sb0Count += 1
                if (low[i] >= supportBox1Bottom and low[i] <= (supportBox1Bottom + 0.01))
                    sb1Count += 1
        
        supportBoxBottom = (sb0Count >= sb1Count) ? box.get_bottom(sb0) : box.get_bottom(sb1)
        supportBoxLeft = (sb0Count >= sb1Count) ? box.get_left(sb0) : box.get_left(sb1)
        sellLimitPrice := supportBoxBottom
        supportBoxTop = supportBoxBottom + boxHeight 
        supportBoxRight = estimatedFutureBarIndex
        box.new(left=supportBoxLeft, right=supportBoxRight, top=supportBoxTop, bottom=supportBoxBottom, bgcolor=zoneColorDemand, border_color=color.rgb(33, 135, 69))

    // remove all other array values
    removeZones(resistanceBoxes, resistancePrices, resistanceTimes)
    removeZones(supportBoxes, supportPrices, supportTimes)

inATrade = if (strategy.opentrades == 0)
    "None"
else if (strategy.opentrades < 0)
    "Short"
else if (strategy.opentrades > 0)
    "Long"

SL := (ATR * stopLossRatio)
TP := SL * 2

if (not inTradeSession and strategy.opentrades != 0)
    strategy.close_all(alert_message='secondary close all', immediately=true)


amountRisked := SL * syminfo.pointvalue
positionSize := (500 / amountRisked) > 1 ? math.floor(500 / amountRisked) : 1
// Trading Session
if inTradeSession

    if (strategy.losstrades[0] > strategy.losstrades[1])
        // last trade was a loss
        lostATrade := true

    // LONG trade setup
    newLongTrade := (open <= buyLimitPrice and close > buyLimitPrice and not alreadyTradedLong and strategy.opentrades == 0 and not lostATrade) 
    newShortTrade := (open >= sellLimitPrice and close < sellLimitPrice and not alreadyTradedShort and strategy.opentrades == 0 and not lostATrade) 

    if newLongTrade and not alreadyTradedLong and noTradesTaken


        SL := (ATR * stopLossRatio) 
        TP := SL * 2

        // change up entry if large SL
        if (amountRisked > 500.00) and reduceSL
            fiveHondoRiskSL = 500/syminfo.pointvalue
            modifiedEntry = newLongTrade ? buyLimitPrice - fiveHondoRiskSL : sellLimitPrice + fiveHondoRiskSL 
        else 
            modifiedEntry = newLongTrade ? buyLimitPrice : sellLimitPrice
        
        alreadyTradedLong := true
        longTradeSetUp := true
        longSignal := true
        noTradesTaken := false

        if syminfo.type == "forex"
            longTradeSL := modifiedEntry - (SL / 100)
            longTradeTP := modifiedEntry + (TP / 100)
            longTradeEntry := modifiedEntry
            strategy.entry(id="Long", direction=strategy.long, qty=positionSize, limit=buyLimitPrice)
        else
            strategy.entry(id="Long", direction=strategy.long, limit = modifiedEntry, qty =positionSize, alert_message="Long buy order for {{ticker}} at {{strategy.order.price}}")
            longTradeTP := modifiedEntry + TP
            longTradeSL := modifiedEntry - SL
            longBE := modifiedEntry + TP/2

    // SHORT trade setup
    if newShortTrade and not alreadyTradedShort and noTradesTaken
        alreadyTradedShort := true
        noTradesTaken := false
        shortTradeSetUp := true
        shortSignal := true

        if syminfo.type == "forex"
            shortTradeSL := modifiedEntry + (SL / 100)
            shortTradeTP := modifiedEntry - (TP / 100)
            shortTradeEntry := modifiedEntry
            strategy.entry(id="Short", direction=strategy.short, qty=positionSize, limit=modifiedEntry)
        else
            strategy.entry(id="Short", direction=strategy.short, limit = modifiedEntry, qty =positionSize, alert_message="Short sell order for {{ticker}} at {{strategy.order.price}}")
            shortTradeTP := modifiedEntry - TP
            shortTradeSL := modifiedEntry + SL
            shortBE := modifiedEntry - TP/2

    // Handle trade exits
    strategy.exit(id="Long Exit",  from_entry="Long",  limit=longTradeTP, stop=longTradeSL)
    strategy.exit(id="Short Exit", from_entry="Short", limit=shortTradeTP, stop=shortTradeSL)

    //determine if price moved too far without an entry to invalidate trade
    if (high > buyLimitPrice + .15 and longTradeSetUp and not alreadyTradedLong)
        longTradeValid := false
        if not alreadyLabeled 
            label.new(bar_index, buyLimitPrice, "long trade invalidated")
            alreadyLabeled := true

    if (low < sellLimitPrice - .15 and shortTradeSetUp and not alreadyTradedShort)
        shortTradeValid := false
        if not alreadyLabeled 
            label.new(bar_index, sellLimitPrice, "short trade invalidated")
            alreadyLabeled := true
    
    // no trades on Fridays or Sundays - I say let it ride since price has to open in zone and exit outside the zone


  //  / === Table Headers & Clear Cells ===
if showTables
    variableTracker := table.new(position.bottom_left, 2, 16)

    table.cell(variableTracker, 0, 0, "")
    table.cell(variableTracker, 1, 0, "")

    table.cell(variableTracker, 0,1,"")
    table.cell(variableTracker, 1,1,str.tostring(""))
    table.cell(variableTracker, 0,2,"")
    table.cell(variableTracker, 1,2,str.tostring(""))
    table.cell(variableTracker, 0,3,"")
    table.cell(variableTracker, 1,3,str.tostring(""))
    table.cell(variableTracker, 0,4,"")
    table.cell(variableTracker, 1,4,str.tostring(""))
    table.cell(variableTracker, 0,5,"")
    table.cell(variableTracker, 1,5,str.tostring(""))
    table.cell(variableTracker, 0,6,"modified Entry")
    table.cell(variableTracker, 1,6,str.tostring(modifiedEntry))
    table.cell(variableTracker, 0,7,"")
    table.cell(variableTracker, 1,7,str.tostring(""))
    table.cell(variableTracker, 0,8,"$ amount risking")
    table.cell(variableTracker, 1,8,str.tostring(amountRisked))
    table.cell(variableTracker, 0,9,"position size")
    table.cell(variableTracker, 1,9,str.tostring(positionSize))
    table.cell(variableTracker, 0,10,"Open Trades:")
    table.cell(variableTracker, 1,10,str.tostring(inATrade))
    table.cell(variableTracker, 0,11,"")
    table.cell(variableTracker, 1,11,str.tostring(""))
    table.cell(variableTracker, 0,12,"Trade set up")
    table.cell(variableTracker, 1,12,str.tostring(newLongTrade or newShortTrade))
    table.cell(variableTracker, 0,13,"TP")
    table.cell(variableTracker, 1,13,str.tostring(TP))
    table.cell(variableTracker, 0,14,"SL")
    table.cell(variableTracker, 1,14,str.tostring(SL))
    table.cell(variableTracker, 0,15,"ATR")
    table.cell(variableTracker, 1,15,str.tostring(ATR))
