//@version=5
strategy("MORB Auto Trader v1",
     overlay=true,
     calc_on_order_fills = true,
     use_bar_magnifier = true,
     initial_capital = 500,
     default_qty_type = strategy.percent_of_equity,
     default_qty_value = 100,
     commission_type = strategy.commission.cash_per_contract,
     commission_value = 1.99,
     currency = currency.USD)

     // set trading hours
     // freeze zones just prior
     // set reset time for variables
    //  1 contract static size
    // exit all trades by trading hours
    // use ATR for SL and TP
    // 1:1 breakeven
    // 1 loss/day stop trading
    // 150% negates trade

// IDEAS: consider entering at half-entry into zone?
// if it leaves the zone during cool down, consider that a valid setup still

// TODO: lookback from pivots to see if a swing candle within 10 back and use that
// TODO: clean up user inputs UI
// TODO: add tooltips for the inputs

// new specifics
// user inputs:
    // trading hours 
    // SL and TP
    // confluences to use (checkbox)
    // enter mid zone
// identify pivot point 
// if price crosses through a resistance, that becomes supply/demand range 
// grab high and low of that candle 
// start counting L and R last 75 bars if price retested that range 
    // if > 2 retests, that becomes a support/resistance zone 
    // keep last 5 of each in an array 
// confluences to enter:
    // price rejects off 50sma 
    // opposite/reversal candle forms
    // price re-enters the zone 
    // no falling knife candle (increase in relative volume)

// === Inputs ===

enum tz
    utc  = "UTC"
    exch = ""
    ny   = "America/New_York"
    chi  = "America/Chicago"
    lon  = "Europe/London"
    tok  = "Asia/Tokyo"



timeZoneInput = str.tostring(input.enum(tz.ny, "Session Timezone"))


lockZonesHighlightColor = input.color(color.new(#047e2f, 90), title="No Trade cool-off Session Highlight Color", group="Strategy Times")
lockZonesStartHour = int(str.tonumber(input.string(defval="09", title="Lock Zones Time", group="Strategy Times", inline="Lock Zones Time", options = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"])))
lockZonesStartMinute = int(str.tonumber(input.string(defval="15", title=":", group="Strategy Times", inline="Lock Zones Time", options = ["00", "15", "30", "45", "59"])))


tradeHighlightColor = input.color(color.new(#04ff00, 83), title="Trading Session Highlight Color", group="Strategy Times")

tradeStartHour = int(str.tonumber(input.string(defval="09", title="Trading Start Time", group="Strategy Times", inline="Start Trading Times", options = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"])))
tradeStartMinute = int(str.tonumber(input.string(defval="35", title=":", group="Strategy Times", inline="Start Trading Times", options = ["00", "15", "30", "35", "45"])))
tradeEndHour = int(str.tonumber(input.string(defval="16", title="Trading end time", group="Strategy Times", inline="End Trading Times", options = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"])))
tradeEndMinute   = int(str.tonumber(input.string(defval="45", title=":", group="Strategy Times", inline="End Trading Times", options = ["00", "15", "30", "45"])))

pivotStrength = input.int(5, title="Pivot Strength (Left & Right Bars)", minval=1)
zoneWidthTicks = input.int(10, title="Zone Width (Ticks)", minval=1)
showTables = input.bool(true, title="Show debug tables")
//takeProfit = input.int(defval = 40, title="Take Profit Size", minval = 1)
//stopLoss = input.int(defval = 20, title="Stop Loss Size", minval = 1)
stopLossRatio = input.int(defval = 2, title="Stop Loss ratio 1:? ", minval = 1)
boxHeight = input.float(defval = 10, title="Height of S/R boxes", minval = .01)
breakEvenActivated = input.bool(false, title = 'Break Even at 1:1 Activated')

// lockZone timestamp
lockZoneTimestamp = timestamp(timeZoneInput, year, month, dayofmonth, lockZonesStartHour, lockZonesStartMinute)

// trade timestamps
tradeStart = timestamp(timeZoneInput, year, month, dayofmonth, tradeStartHour, tradeStartMinute)
tradeEnd  = timestamp(timeZoneInput, year, month, dayofmonth, tradeEndHour, tradeEndMinute)
closeAllOpenTrades  = timestamp(timeZoneInput, year, month, dayofmonth, 16, 55)

inLockZonesSession = time == lockZoneTimestamp
inTradeSession = time > tradeStart and time <= tradeEnd

bgColor = if inLockZonesSession
    lockZonesHighlightColor
else if inTradeSession
    tradeHighlightColor
else 
    na

bgcolor(bgColor)

// === Arrays to Store Zone Data ===
var float[] resistancePrices = array.new_float()
var float[] supportPrices = array.new_float()
var int[] resistanceTimes = array.new_int()
var int[] supportTimes = array.new_int()
var box[] resistanceBoxes = array.new_box()
var box[] supportBoxes = array.new_box()
var bool zonesSet = false
var float buyLimitPrice = 0.0
var float sellLimitPrice = 0.0
var bool noTradesTaken = true
var bool longTradeSetUp = false
var bool shortTradeSetUp = false
var alreadyLabeled = false // for debugging steps

var bool longTradeValid = true
var bool shortTradeValid = true
var bool alreadyTradedShort = false
var bool alreadyTradedLong = false
var bool lostATrade = false

var bool longSignal = false
var bool shortSignal = false
var float i_fx_risk = 0.1 // percentage of risk
var float longTradeTP = 0.0
var float longTradeSL = 0.0
var float longTradeEntry = 0.0
var float shortTradeTP = 0.0
var float shortTradeSL = 0.0
var float shortTradeEntry = 0.0
var bool newLongTrade = false 
var bool newShortTrade = false
var int winningTradeCount = 0
var int losingTradeCount = 0
var bool alreadyLockedIn = false
var float highBar = 0
var int highIndex = 0
var float lowBar = 0
var int lowIndex = 0
var int rb0Count = 0
var int rb1Count = 0
var int sb0Count = 0
var int sb1Count = 0
var float myAtr = ta.atr(14)
var int SL = 0 //5 * (math.round(myAtr / 5))
var int TP = 0 //SL * 2
var string debugValue = ''
var float longBE = 0
var float shortBE = 0


zoneColorSupply = color.new(color.red, 85)
zoneColorDemand = color.new(color.green, 85)
zoneWidth = zoneWidthTicks * syminfo.mintick

// ********************  methods

checkForPivot(pivotHigh, pivotLow) =>
    if (not na(pivotHigh))
        top = pivotHigh
        bottom = top - zoneWidth
        b = box.new(left=bar_index - pivotStrength, right=bar_index, top=top, bottom=bottom, bgcolor=zoneColorSupply, border_color=color.red)
        array.unshift(resistanceBoxes, b)
        array.unshift(resistancePrices, high[pivotStrength])
        array.unshift(resistanceTimes, time[pivotStrength])

    if (not na(pivotLow))
        bottom = pivotLow
        top = bottom + zoneWidth
        b = box.new(left=bar_index - pivotStrength, right=bar_index, top=top, bottom=bottom, bgcolor=zoneColorDemand, border_color=color.green)
        array.unshift(supportBoxes, b)
        array.unshift(supportPrices, low[pivotStrength])
        array.unshift(supportTimes, time[pivotStrength])


// === Invalidate Zones if Price Wicks Through ===
invalidateZones(arrBoxes, arrPrices, arrTimes) =>
    if array.size(arrBoxes) > 0
        for i = array.size(arrBoxes) - 1 to 0
            b = array.get(arrBoxes, i)
            top = box.get_top(b)
            bottom = box.get_bottom(b)
            cross = high >= bottom and low <= top
            if cross
                box.delete(b)
                array.remove(arrBoxes, i)
                array.remove(arrPrices, i)
                array.remove(arrTimes, i)

removeZones(arrBoxes, arrPrices, arrTimes) =>
    if array.size(arrBoxes) > 0
        for i = array.size(arrBoxes) - 1 to 0
            b = array.get(arrBoxes, i)
            box.delete(b)
        array.clear(arrPrices)
        array.clear(arrTimes)
        array.clear(arrBoxes)

invalidateZones(resistanceBoxes, resistancePrices, resistanceTimes)
invalidateZones(supportBoxes, supportPrices, supportTimes)

// ****************** script start
// === Pivot Detection ===
pivotHigh = ta.pivothigh(high, pivotStrength, pivotStrength)
pivotLow = ta.pivotlow(low, pivotStrength, pivotStrength)

// Draw conditional data
plotshape(newLongTrade,  style=shape.triangleup,   color=color.green, location=location.belowbar, title="Long Setup")
plotshape(newShortTrade, style=shape.triangledown, color=color.red,   location=location.abovebar, title="Short Setup")

// Draw stops & targets
plot(strategy.position_size > 0 ? longTradeSL : na,   color=color.red,   style=plot.style_linebr, title="Stop Loss")
plot(strategy.position_size > 0 ? longTradeTP : na, color=color.green, style=plot.style_linebr, title="Profit Target")
plot(strategy.position_size > 0 ? longBE : na, color=color.green, style=plot.style_linebr, title="Break Even")

plot(strategy.position_size < 0 ? shortTradeSL : na,   color=color.red,   style=plot.style_linebr, title="Stop Loss")
plot(strategy.position_size < 0 ? shortTradeTP : na, color=color.green, style=plot.style_linebr, title="Profit Target")
plot(strategy.position_size < 0 ? shortBE : na, color=color.green, style=plot.style_linebr, title="Break Even")

// paint active trade indicators
if (strategy.position_size > 0)
    line.new(x1=bar_index, x2=bar_index, y1=buyLimitPrice, y2=longTradeSL, color=color.new(#a23b3b, 50), width=6)
    line.new(x1=bar_index, x2=bar_index, y1=buyLimitPrice, y2=longTradeTP, color=color.new(#2fc016, 50), width=6)
    line.new(x1=bar_index, x2=bar_index, y1=buyLimitPrice, y2=longBE, color=color.new(#207611, 50), width=6)

if (strategy.position_size < 0)
    line.new(x1=bar_index, x2=bar_index, y1=sellLimitPrice, y2=shortTradeSL, color=color.new(#a23b3b, 50), width=6)
    line.new(x1=bar_index, x2=bar_index, y1=sellLimitPrice, y2=shortTradeTP, color=color.new(#2fc016, 50), width=6)
    line.new(x1=bar_index, x2=bar_index, y1=sellLimitPrice, y2=shortBE, color=color.new(#207611, 50), width=6)

// === Tables ===
var table resistanceTable = table.new(position.top_right, 2, 10, frame_color=color.red, border_width=1)
var table supportTable = table.new(position.bottom_right, 2, 10, frame_color=color.green, border_width=1)
var table variableTracker = table.new(position.middle_left, 2, 20, frame_color=#002b80, border_width=1)

// monitor for trade exits
if (breakEvenActivated and (strategy.position_size > 0) and (high >= longBE))
    debugValue := 'move to BE'
    longTradeSL := buyLimitPrice
    strategy.exit(id="Long", comment="Break even stop", stop=buyLimitPrice)
if (breakEvenActivated and (strategy.position_size < 0) and (low <= shortBE))
    debugValue := 'move to BE'
    shortTradeSL := sellLimitPrice
    strategy.exit(id="Short", comment="Break even stop", stop=sellLimitPrice)

// === Table Headers & Clear Cells ===
if showTables
    for i = 0 to 15
        // table.cell(resistanceTable, 0, i, "")
        // table.cell(resistanceTable, 1, i, "")
        // table.cell(supportTable, 0, i, "")
        // table.cell(supportTable, 1, i, "")
        table.cell(variableTracker, 0, i, "")
        table.cell(variableTracker, 1, i, "")

    // table.cell(resistanceTable, 0, 0, "Time", text_color=color.white, bgcolor=color.red)
    // table.cell(resistanceTable, 1, 0, "High", text_color=color.white, bgcolor=color.red)
    // table.cell(supportTable, 0, 0, "Time", text_color=color.white, bgcolor=color.green)
    // table.cell(supportTable, 1, 0, "Low", text_color=color.white, bgcolor=color.green)
    table.cell(variableTracker, 0, 0, "var", text_color=color.white, bgcolor=#1c0080)
    table.cell(variableTracker, 1, 0, "value", text_color=color.white, bgcolor=#1c0080)

    table.cell(variableTracker, 0,1,"newLongTrade")
    table.cell(variableTracker, 1,1,str.tostring(newLongTrade))
    table.cell(variableTracker, 0,2,"newShortTrade")
    table.cell(variableTracker, 1,2,str.tostring(newShortTrade))
    table.cell(variableTracker, 0,3,"longTradeSL")
    table.cell(variableTracker, 1,3,str.tostring(longTradeSL))
    table.cell(variableTracker, 0,4,"longTradeTP")
    table.cell(variableTracker, 1,4,str.tostring(longTradeTP))
    table.cell(variableTracker, 0,5,"shortTradeSL")
    table.cell(variableTracker, 1,5,str.tostring(shortTradeSL))
    table.cell(variableTracker, 0,6,"shortTradeTP")
    table.cell(variableTracker, 1,6,str.tostring(shortTradeTP))
    table.cell(variableTracker, 0,7,"shortBE")
    table.cell(variableTracker, 1,7,str.tostring(shortBE))
    table.cell(variableTracker, 0,8,"")
    table.cell(variableTracker, 1,8,str.tostring(""))
    table.cell(variableTracker, 0,9,"")
    table.cell(variableTracker, 1,9,str.tostring(""))
    table.cell(variableTracker, 0,10,"sellLimitPrice")
    table.cell(variableTracker, 1,10,str.tostring(sellLimitPrice))
    table.cell(variableTracker, 0,11,"buyLimitPrice")
    table.cell(variableTracker, 1,11,str.tostring(buyLimitPrice))
    table.cell(variableTracker, 0,12,"debugValue")
    table.cell(variableTracker, 1,12,str.tostring(debugValue))
    table.cell(variableTracker, 0,13,"syminfo.type")
    table.cell(variableTracker, 1,13,str.tostring(syminfo.type))
    table.cell(variableTracker, 0,14,"SL")
    table.cell(variableTracker, 1,14,str.tostring(SL))
    table.cell(variableTracker, 0,15,"myAtr")
    table.cell(variableTracker, 1,15,str.tostring(myAtr))

// === Display Zone Info Sorted (Newest First) ===
displayZoneTable(arrPrices, arrTimes, tbl) =>
    if array.size(arrPrices) > 0
        maxRows = 9
        zoneCount = math.min(array.size(arrPrices), maxRows)
        for i = 0 to zoneCount - 1
            priceStr = str.tostring(array.get(arrPrices, i), format.mintick)
            timeStr = str.format("{0,date,yyyy-MM-dd HH:mm}", array.get(arrTimes, i))
            table.cell(tbl, 0, i + 1, timeStr)
            table.cell(tbl, 1, i + 1, priceStr)

myAtr := ta.atr(14) 


// Looking Session
if not inTradeSession
    // reset trading variables
    noTradesTaken := true
    longTradeSetUp := false
    shortTradeSetUp := false
    longTradeValid := true
    shortTradeValid := true
    alreadyLabeled := false
    alreadyTradedShort := false
    alreadyTradedLong := false
    newLongTrade := false
    newShortTrade := false
    lostATrade := false
   // buyLimitPrice := 0
    // sellLimitPrice := 0
    alreadyLockedIn := false
    highBar := 0
    highIndex := 0
    lowBar := 0
    lowIndex := 0
    rb0Count := 0
    rb1Count := 0
    sb0Count := 0
    sb1Count := 0
    shortTradeSL := 0
    longTradeSL := 0
    SL := 0
    TP := 0
    longBE := 0
    shortBE := 0
    debugValue := ''

    // close any open trades
    if (time == closeAllOpenTrades and strategy.opentrades != 0)
        strategy.close_all(alert_message = "open trade detected, closing", immediately = true)
        
    // check if a pivot, and if so, create zone and boxes
    checkForPivot(pivotHigh, pivotLow)

if inLockZonesSession 

    zonesSet := true // prob can delete this one?
    var int sessEndBarIndex = tradeEnd - time
    barDuration = time - time[1]
    barsUntilFuture = math.round(sessEndBarIndex / barDuration)
    estimatedFutureBarIndex = bar_index + barsUntilFuture + 15

    if (array.size(resistanceBoxes) == 0 and not alreadyLockedIn)
        // if there aren't any valid pivots (because of a bullish premarket) use highest bar in the last pivotStrength rows back

        // instead, grab the most recent pivot  - look for 
        highBar := ta.highest(high, pivotStrength * 3)
        highIndex := ta.barssince(high == highBar)
        if not na(highBar)
            top = high
            bottom = top - zoneWidth
            b = box.new(left=bar_index[highIndex] - pivotStrength, right=bar_index[highIndex], top=top, bottom=bottom, bgcolor=zoneColorSupply, border_color=color.red)
            array.unshift(resistanceBoxes, b)
            array.unshift(resistancePrices, high[pivotStrength])
            array.unshift(resistanceTimes, time[pivotStrength])

    if (array.size(supportBoxes) == 0 and not alreadyLockedIn)
        // if there aren't any valid pivots (because of a bearish premarket) use lowest bar in the last pivotStrength rows back
        lowBar := ta.lowest(low,pivotStrength * 3)
        lowIndex := ta.barssince(low == lowBar)
        if not na(lowBar)
            bottom = low
            top = bottom + zoneWidth
            b = box.new(left=bar_index[lowIndex] - pivotStrength, right=bar_index[lowIndex], top=top, bottom=bottom, bgcolor=zoneColorDemand, border_color=color.green)
            array.unshift(supportBoxes, b)
            array.unshift(supportPrices, low[pivotStrength])
            array.unshift(supportTimes, time[pivotStrength])

    // now that we have populated resistanceBoxes, set the last one for entries
    if array.size(resistanceBoxes) > 0
        alreadyLockedIn := true
        rb0 = array.get(resistanceBoxes, 0)
        resistanceBox0Top = box.get_top(rb0)

        box rb1 = na

        if array.size(resistanceBoxes) > 1
            rb1 := array.get(resistanceBoxes, 1)
            resistanceBox1Top = box.get_top(rb1)

            for i = 0 to 9
                if (high[i] <= resistanceBox0Top and high[i] >= (resistanceBox0Top - 0.01)) 
                    rb0Count += 1
                if (high[i] <= resistanceBox1Top and high[i] >= (resistanceBox1Top - 0.01))
                    rb1Count += 1

        resistanceBoxTop = (rb0Count >= rb1Count) ? box.get_top(rb0) : box.get_top(rb1)
        buyLimitPrice := resistanceBoxTop
        resistanceBoxLeft = (rb0Count >= rb1Count) ? box.get_left(rb0) : box.get_left(rb1)
        resistanceBoxBottom = resistanceBoxTop - boxHeight // 0.03 // make user configurable
        resistanceBoxRight = estimatedFutureBarIndex
        box.new(left=resistanceBoxLeft, right=resistanceBoxRight, top=resistanceBoxTop, bottom=resistanceBoxBottom, bgcolor=zoneColorSupply, border_color=color.red)
    
    if array.size(supportBoxes) > 0
        alreadyLockedIn := true
        sb0 = array.get(supportBoxes, 0)
        supportBox0Bottom = box.get_bottom(sb0)

        box sb1 = na 

        if array.size(supportBoxes) > 1
            sb1 := array.get(supportBoxes, 1)
            supportBox1Bottom = box.get_bottom(sb1)

            for i = 0 to 9
                if (low[i] >= supportBox0Bottom and low[i] <= (supportBox0Bottom + 0.01)) 
                    sb0Count += 1
                if (low[i] >= supportBox1Bottom and low[i] <= (supportBox1Bottom + 0.01))
                    sb1Count += 1
        
        supportBoxBottom = (sb0Count >= sb1Count) ? box.get_bottom(sb0) : box.get_bottom(sb1)
        supportBoxLeft = (sb0Count >= sb1Count) ? box.get_left(sb0) : box.get_left(sb1)
        sellLimitPrice := supportBoxBottom
        supportBoxTop = supportBoxBottom + boxHeight // 0.03 // make user configurable
        supportBoxRight = estimatedFutureBarIndex
        box.new(left=supportBoxLeft, right=supportBoxRight, top=supportBoxTop, bottom=supportBoxBottom, bgcolor=zoneColorDemand, border_color=color.rgb(33, 135, 69))

    // remove all other array values
    removeZones(resistanceBoxes, resistancePrices, resistanceTimes)
    removeZones(supportBoxes, supportPrices, supportTimes)

// Trading Session
if inTradeSession
    if (strategy.losstrades[0] > strategy.losstrades[1])

    if (strategy.losstrades[0] > strategy.losstrades[1])
        // last trade was a loss
        lostATrade := true





    // TODO: keep table of day of trade, result, total count

    // check if a gap occurred and invalidate all trading
    // actually is this necessary since we look for open in the zone and close outside it?
    
    // check if there's a trade setup, only one allowed per direction per trade session

    // LONG trade setup
    newLongTrade := (open <= buyLimitPrice and close > buyLimitPrice and not alreadyTradedLong and strategy.opentrades == 0 and not lostATrade) 
    newShortTrade := (open >= sellLimitPrice and close < sellLimitPrice and not alreadyTradedShort and strategy.opentrades == 0 and not lostATrade) 

    if newLongTrade and not alreadyTradedLong
        SL := 5 * ((math.round(myAtr / 5)) + 1)
        TP := SL * stopLossRatio
        alreadyTradedLong := true
        longTradeSetUp := true
        longSignal := true

    //setTradeMarkers(direction = "buy", entry = buyLimitPrice, SL = buyLimitPrice - .10, TP = buyLimitPrice + .10)
    //label.new(bar_index, buyLimitPrice, "buy setup")
        if syminfo.type == "forex"
            longTradeSL := buyLimitPrice - (SL / 100)
            longTradeTP := buyLimitPrice + (TP / 100)
            longTradeEntry := buyLimitPrice
            positionSize = 10.0 //math.floor((strategy.equity * (i_fx_risk / 100)))
            strategy.entry(id="Long", direction=strategy.long, qty=positionSize, limit=buyLimitPrice)
        else
            strategy.entry(id="Long", direction=strategy.long, limit = buyLimitPrice, qty = 1.0)
            longTradeTP := buyLimitPrice + TP
            longTradeSL := buyLimitPrice - SL
            longBE := buyLimitPrice + TP/2
            // strategy.exit(id="Long", profit = buyLimitPrice + takeProfit, stop = buyLimitPrice - stopLoss)
        // box.new(left=bar_index, top=longTradeTP, right=bar_index+10, bottom=buyLimitPrice, bgcolor=color.new(#54d6ad, 63), border_width=0) //border_color = color.new(color = color.green, transp = 0))
        // box.new(left=bar_index, top=buyLimitPrice, right=bar_index+10, bottom=longTradeSL, bgcolor=color.new(#a23b3b, 70), border_width=0)
    // SHORT trade setup
    if newShortTrade and not alreadyTradedShort
        SL := 5 * ((math.round(myAtr / 5)) + 1)
        TP := SL * stopLossRatio
        alreadyTradedShort := true
        noTradesTaken := false
        shortTradeSetUp := true
        shortSignal := true
            //setTradeMarkers(direction = "sell", entry = sellLimitPrice, SL = sellLimitPrice + .10, TP = sellLimitPrice - .10)
        //label.new(bar_index, buyLimitPrice, "sell setup"+str.tostring(alreadyTradedShort))
        if syminfo.type == "forex"
            shortTradeSL := sellLimitPrice + (SL / 100)
            shortTradeTP := sellLimitPrice - (TP / 100)
            shortTradeEntry := sellLimitPrice
            positionSize = 10.0 //math.floor((strategy.equity * (i_fx_risk / 100)))
            strategy.entry(id="Short", direction=strategy.short, qty=positionSize, limit=sellLimitPrice)
        else
            strategy.entry(id="Short", direction=strategy.short, limit = sellLimitPrice, qty = 1.0)
            shortTradeTP := sellLimitPrice - TP
            shortTradeSL := sellLimitPrice + SL
            shortBE := sellLimitPrice - TP/2
            // strategy.exit("Short SL", profit = sellLimitPrice - takeProfit, stop = sellLimitPrice + stopLoss)
        // box.new(left=bar_index, top=sellLimitPrice, right=bar_index+10, bottom=shortTradeTP, bgcolor=color.new(#54d6ad, 63), border_width=0)
        // box.new(left=bar_index, top=shortTradeSL, right=bar_index+10, bottom=sellLimitPrice, bgcolor=color.new(#a23b3b, 70), border_width=0)
    // Handle trade exits
    strategy.exit(id="Long Exit",  from_entry="Long",  limit=longTradeTP, stop=longTradeSL)
    // strategy.exit(id="Long Exit #2",  from_entry="Long",  limit=tradeTarget2, stop=tradeStop, qty_percent=100)
    strategy.exit(id="Short Exit", from_entry="Short", limit=shortTradeTP, stop=shortTradeSL)
    // strategy.exit(id="Short Exit #2", from_entry="Short", limit=tradeTarget2, stop=tradeStop, qty_percent=100)

    //determine if price moved too far without an entry to invalidate trade
    if (high > buyLimitPrice + .15 and longTradeSetUp and not alreadyTradedLong)
        longTradeValid := false
        if not alreadyLabeled 
            label.new(bar_index, buyLimitPrice, "long trade invalidated")
            alreadyLabeled := true

    if (low < sellLimitPrice - .15 and shortTradeSetUp and not alreadyTradedShort)
        shortTradeValid := false
        if not alreadyLabeled 
            label.new(bar_index, sellLimitPrice, "short trade invalidated")
            alreadyLabeled := true
    
    // no trades on Fridays or Sundays - I say let it ride since price has to open in zone and exit outside the zone