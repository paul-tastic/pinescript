//@version=5
strategy("Nexus Strategy Manual", overlay=true, initial_capital=10000, default_qty_type=strategy.fixed, default_qty_value=1)

// ============================================================================
// INPUTS - MANUAL ZONES
// ============================================================================
supply_top = input.float(0.0, "Supply Zone Top", group="Manual Zones")
supply_bottom = input.float(0.0, "Supply Zone Bottom", group="Manual Zones")
clear_supply = input.bool(false, "Disable Supply Zone", group="Manual Zones", tooltip="Check to temporarily disable supply zone without clearing values")

demand_top = input.float(0.0, "Demand Zone Top", group="Manual Zones")
demand_bottom = input.float(0.0, "Demand Zone Bottom", group="Manual Zones")
clear_demand = input.bool(false, "Disable Demand Zone", group="Manual Zones", tooltip="Check to temporarily disable demand zone without clearing values")

show_zones = input.bool(true, "Show Zones", group="Manual Zones", tooltip="Show/hide zone boxes on chart")

// ============================================================================
// INPUTS - TRADING WINDOW
// ============================================================================
trading_start_hour = input.int(9, "Trading Start Hour", minval=0, maxval=23, group="Trading Window", tooltip="Hour to start trading (NY time)")
trading_start_minute = input.int(30, "Trading Start Minute", minval=0, maxval=59, group="Trading Window", tooltip="Minute to start trading (NY time)")
trading_end_hour = input.int(16, "Trading End Hour", minval=0, maxval=23, group="Trading Window", tooltip="Hour to end trading (NY time)")
trading_end_minute = input.int(45, "Trading End Minute", minval=0, maxval=59, group="Trading Window", tooltip="Minute to end trading (NY time)")

// ============================================================================
// INPUTS - TRADE SETTINGS
// ============================================================================
risk_per_trade = input.float(500.0, "Risk Per Trade ($)", minval=1.0, group="Trade Settings", tooltip="Dollar amount to risk per trade")
max_setup_bars = input.int(100, "Max Setup Age (bars)", minval=1, group="Trade Settings", tooltip="Maximum number of bars before setup is invalidated")
setup_timeout_bars = input.int(30, "Setup Timeout (bars)", minval=1, group="Trade Settings", tooltip="Invalidate setup after this many bars if no entry signal triggers")
entry_timeout_bars = input.int(20, "Entry Timeout (bars)", minval=1, group="Trade Settings", tooltip="Invalidate entry signal after this many bars if trade doesn't execute")
grace_ticks = input.float(0.0, "Grace Ticks (SL Padding)", minval=0.0, step=0.25, group="Trade Settings", tooltip="Add extra ticks to stop loss for safety margin (maintains 2:1 RR)")

// ============================================================================
// INPUTS - ENTRY STRATEGIES (can enable multiple)
// ============================================================================
use_mss_ob = input.bool(true, "MSS OB", group="Entry Strategies", tooltip="Market Structure Shift Order Block - enters when price crosses opposite fractal level")
use_bpr_fvg = input.bool(false, "Balanced Price Range FVG", group="Entry Strategies", tooltip="Fair Value Gap within balanced price range")
bpr_fvg_min_ticks = input.float(2.0, "BPR FVG Min Size (ticks)", minval=0.0, step=0.25, group="Entry Strategies", tooltip="Minimum FVG size in ticks - smaller FVGs will be ignored")
use_inverted_fvg = input.bool(false, "Inverted FVG", group="Entry Strategies", tooltip="Inverted Fair Value Gap entry")
use_breaker_block = input.bool(false, "Breaker Block", group="Entry Strategies", tooltip="Breaker Block entry pattern")

// ============================================================================
// ZONE DETECTION
// ============================================================================
// Apply clear flags - if clear is checked, treat zone as not configured
bool supply_configured = not clear_supply and supply_top > 0 and supply_bottom > 0 and supply_top > supply_bottom
bool demand_configured = not clear_demand and demand_top > 0 and demand_bottom > 0 and demand_top > demand_bottom

// Check if candle touches zone (high/low overlap with zone range)
// Uses real-time high/low so it triggers immediately when zone is touched
bool in_supply = supply_configured and not (low > supply_top or high < supply_bottom)
bool in_demand = demand_configured and not (low > demand_top or high < demand_bottom)

// ============================================================================
// TRADING WINDOW CHECK
// ============================================================================
// Convert current time to minutes since midnight for easier comparison
int current_time_minutes = hour(time, "America/New_York") * 60 + minute(time, "America/New_York")
int trading_start_minutes = trading_start_hour * 60 + trading_start_minute
int trading_end_minutes = trading_end_hour * 60 + trading_end_minute

// Check if we're within trading window
bool in_trading_window = current_time_minutes >= trading_start_minutes and current_time_minutes <= trading_end_minutes


// ============================================================================
// SESSION HIGH/LOW TRACKING
// ============================================================================
// Session times (America/New_York):
// - Asian: 20:00 - 00:00 (previous day 8pm to midnight)
// - London: 03:00 - 12:00
// - Previous Day: 00:00 - 00:00 (full previous trading day)

// Track session highs and lows
var float asian_high = na
var float asian_low = na
var float london_high = na
var float london_low = na
var float prev_day_high = na
var float prev_day_low = na

// Track if sessions have been crossed (invalidated)
var bool asian_high_crossed = false
var bool asian_low_crossed = false
var bool london_high_crossed = false
var bool london_low_crossed = false
var bool prev_day_high_crossed = false
var bool prev_day_low_crossed = false

// Track lines for visual display
var line asian_high_line = na
var line asian_low_line = na
var line london_high_line = na
var line london_low_line = na
var line prev_day_high_line = na
var line prev_day_low_line = na

// Get current time
int hour_et = hour(time, "America/New_York")
int day_of_month = dayofmonth(time, "America/New_York")

// Track session high/low during their respective periods
// Asian session: 20:00 - 00:00 (8pm to midnight)
bool in_asian_session = hour_et >= 20 or hour_et < 0
if in_asian_session
    if na(asian_high) or high > asian_high
        asian_high := high
    if na(asian_low) or low < asian_low
        asian_low := low

        // do NOT reset asian hi/lo at NY midnight. instead of resetting at midnight, reset at next asian session
else if hour_et == 0 and minute(time, "America/New_York") == 0
    // Reset at midnight (start of new day)
    asian_high := na
    asian_low := na
    asian_high_crossed := false
    asian_low_crossed := false

// London session: 03:00 - 12:00
bool in_london_session = hour_et >= 3 and hour_et < 12
if in_london_session
    if na(london_high) or high > london_high
        london_high := high
    if na(london_low) or low < london_low
        london_low := low
else if hour_et == 3 and minute(time, "America/New_York") == 0
    // Reset at London open
    london_high := na
    london_low := na
    london_high_crossed := false
    london_low_crossed := false

// Previous Day high/low: track full previous day, reset at midnight
var float temp_day_high = na
var float temp_day_low = na
var int last_tracked_day = na

if barstate.isnew
    int current_day = dayofmonth(time, "America/New_York")

    // At start of new day (midnight ET), save yesterday's high/low as prev_day
    if not na(last_tracked_day) and current_day != last_tracked_day
        prev_day_high := temp_day_high
        prev_day_low := temp_day_low
        prev_day_high_crossed := false
        prev_day_low_crossed := false

        // Reset temp tracking for new day
        temp_day_high := high
        temp_day_low := low
    else
        // Continue tracking current day's high/low
        if na(temp_day_high) or high > temp_day_high
            temp_day_high := high
        if na(temp_day_low) or low < temp_day_low
            temp_day_low := low

    last_tracked_day := current_day

// Check for crosses and invalidate levels
if not asian_high_crossed and not na(asian_high) and high >= asian_high
    asian_high_crossed := true
if not asian_low_crossed and not na(asian_low) and low <= asian_low
    asian_low_crossed := true

if not london_high_crossed and not na(london_high) and high >= london_high
    london_high_crossed := true
if not london_low_crossed and not na(london_low) and low <= london_low
    london_low_crossed := true

if not prev_day_high_crossed and not na(prev_day_high) and high >= prev_day_high
    prev_day_high_crossed := true
if not prev_day_low_crossed and not na(prev_day_low) and low <= prev_day_low
    prev_day_low_crossed := true

// Session level lines removed - keep it simple

// ============================================================================
// ZONE VISUALIZATION - Draw zones during trading window on current day
// ============================================================================
// Get current time info
int current_hour = hour(time, "America/New_York")
int current_minute = minute(time, "America/New_York")
bool is_new_day = ta.change(dayofmonth(time, "America/New_York")) != 0

// Track zone boxes
var box supply_zone_box = na
var box demand_zone_box = na
var int zone_start_bar = na

// At trading window start, create new zone boxes for the day
// Create boxes when entering trading window on a new day OR if boxes don't exist yet
bool at_trading_start = current_hour == trading_start_hour and current_minute == trading_start_minute
bool should_create_boxes = at_trading_start and (is_new_day or na(supply_zone_box) or na(demand_zone_box))

if should_create_boxes
    zone_start_bar := bar_index

    // Delete old boxes
    if not na(supply_zone_box)
        box.delete(supply_zone_box)
    if not na(demand_zone_box)
        box.delete(demand_zone_box)

    // Create supply zone box (only if show_zones is enabled)
    if show_zones and supply_configured
        supply_zone_box := box.new(bar_index, supply_top, bar_index + 1, supply_bottom,
                                   border_color=color.red,
                                   bgcolor=color.new(color.red, 90),
                                   border_width=1,
                                   extend=extend.none)

    // Create demand zone box (only if show_zones is enabled)
    if show_zones and demand_configured
        demand_zone_box := box.new(bar_index, demand_top, bar_index + 1, demand_bottom,
                                   border_color=color.blue,
                                   bgcolor=color.new(color.blue, 90),
                                   border_width=1,
                                   extend=extend.none)

// Update zone boxes to extend to current bar + 2 bars into future (within trading window)
if show_zones and in_trading_window
    if supply_configured and not na(supply_zone_box)
        box.set_right(supply_zone_box, bar_index + 3)
    if demand_configured and not na(demand_zone_box)
        box.set_right(demand_zone_box, bar_index + 3)
else if show_zones and current_hour == trading_end_hour and current_minute == trading_end_minute
    // Stop extending at trading window end
    if supply_configured and not na(supply_zone_box)
        box.set_right(supply_zone_box, bar_index)
    if demand_configured and not na(demand_zone_box)
        box.set_right(demand_zone_box, bar_index)

// If show_zones is disabled, delete any existing boxes
if not show_zones
    if not na(supply_zone_box)
        box.delete(supply_zone_box)
        supply_zone_box := na
    if not na(demand_zone_box)
        box.delete(demand_zone_box)
        demand_zone_box := na

// Track zone entry - stays true while in zone OR while setup is active
var bool supply_triggered = false
var bool demand_triggered = false
var int supply_trigger_bar = -1
var int demand_trigger_bar = -1

// Track deepest penetration into zones (resets on fresh entry)
var float demand_lowest_low = na
var float supply_highest_high = na

// Track deepest HISTORICAL penetration (for validating new ENG OBs must be deeper)
var float demand_deepest_ever = na  // Deepest low ever reached in demand zone
var float supply_deepest_ever = na  // Highest high ever reached in supply zone

// Track if we're completely outside both zones (ready to reset)
var bool was_outside_zones = true

// Track if ENG OB is active (declare early so it can be used in zone logic)
var bool eng_ob_active = false
var bool eng_ob_is_bullish = false
var float eng_ob_deepest_level = na
var int eng_ob_bar_index = na
var float eng_ob_candle_high = na
var float eng_ob_candle_low = na
var box eng_ob_box = na  // Yellow box around ENG OB candle for visual debug

// Track ENTRY SIGNALS - generic for all entry strategies
var bool entry_signal_active = false  // Any entry strategy has triggered
var string active_entry_strategy = ""  // Which strategy triggered (for display/debug)
var bool entry_is_bullish = false  // Trade direction: true = long, false = short
var float entry_price = na  // Entry price (regardless of strategy)
var float entry_tp = na     // Take profit level
var float entry_sl = na     // Stop loss level
var int entry_signal_bar_index = na  // Bar index when entry signal triggered (for timeout tracking)

// Track MSS OB specific state (one of four entry strategies)
var float target_fractal_level_mss = na  // Fractal level for MSS OB strategy

// Track BPR FVG specific state
var bool bpr_fvg_active = false  // BPR FVG has been detected
var bool bpr_fvg_is_bullish = false  // True = bullish FVG (in supply), False = bearish FVG (in demand)
var float bpr_fvg_top = na  // Top of the FVG
var float bpr_fvg_bottom = na  // Bottom of the FVG
var float bpr_fvg_invalidation_level = na  // Highest/lowest of 3-candle pattern for invalidation
var int bpr_fvg_bar_index = na  // Bar index where FVG was detected
var float bpr_fvg_candle_high = na  // High of the candle that created the FVG (for SL)
var float bpr_fvg_candle_low = na  // Low of the candle that created the FVG (for SL)
var box bpr_fvg_box = na  // Yellow box around FVG
var string bpr_fvg_invalidation_reason = ""  // Track why BPR FVG was cleared (for debugging)

// Track Inverted FVG specific state
var bool inv_fvg_active = false  // Inverted FVG has been detected (overlap found)
var bool inv_fvg_is_bullish = false  // Trade direction: true = long, false = short
var float inv_fvg_overlap_top = na  // Top of overlap zone (entry for bearish)
var float inv_fvg_overlap_bottom = na  // Bottom of overlap zone (entry for bullish)
var float inv_fvg_reversal_candle_high = na  // High of reversal FVG candle (for SL in bearish)
var float inv_fvg_reversal_candle_low = na  // Low of reversal FVG candle (for SL in bullish)
var int inv_fvg_bar_index = na  // Bar index where Inverted FVG was detected
var box inv_fvg_overlap_box = na  // Purple box for overlap visualization
var string inv_fvg_invalidation_reason = ""  // Track why Inverted FVG was cleared (for debugging)

// Track Breaker Block specific state
// TODO: Add Breaker Block variables when implementing

// Track TP/SL indicator boxes - use arrays to persist multiple boxes throughout the day
var array<box> daily_tp_boxes = array.new<box>()
var array<box> daily_sl_boxes = array.new<box>()
var box tp_box = na  // Current active TP box
var box sl_box = na  // Current active SL box

// Track if we've already entered a trade for this setup
var bool trade_entered = false

// Track if limit order has been placed for current entry signal
var bool order_placed = false
var int order_placed_bar = -1  // Track which bar the order was placed on

// Track the bar on which the last trade exited (prevent same-bar re-entry)
var int last_exit_bar = -1

// Track bars to wait after exit before allowing new setups (cooldown period)
cooldown_bars = input.int(2, "Cooldown After Exit (bars)", minval=0, group="Trade Settings", tooltip="Number of bars to wait after trade exit before detecting new setups")

// ============================================================================
// DAILY PERFORMANCE TRACKING
// ============================================================================
var int today_trade_count = 0
var int today_wins = 0
var int today_losses = 0
var float today_pnl = 0.0
var int last_trade_day = na
var float last_position_entry = na  // Track entry price to calculate P&L

// Reset daily stats at midnight and clear old boxes at 20:00 (start of Asian session)
if barstate.isnew
    int current_day = dayofmonth(time, "America/New_York")
    int current_hour = hour(time, "America/New_York")
    int current_minute = minute(time, "America/New_York")

    // At midnight, reset daily stats
    if not na(last_trade_day) and current_day != last_trade_day
        today_trade_count := 0
        today_wins := 0
        today_losses := 0
        today_pnl := 0.0

    // At 09:00 NY time, reset deepest zone penetration tracking for the new trading day
    // Also invalidate any active setups from previous day
    if current_hour == 9 and current_minute == 0
        demand_deepest_ever := na
        supply_deepest_ever := na

        // Invalidate any active setups from previous day
        if eng_ob_active or entry_signal_active
            // Close any open positions and cancel pending orders
            strategy.close_all()
            strategy.cancel_all()

            eng_ob_active := false
            eng_ob_is_bullish := false
            eng_ob_deepest_level := na
            eng_ob_bar_index := na
            eng_ob_candle_high := na
            eng_ob_candle_low := na
            target_fractal_level_mss := na

            // Clear entry signals (all strategies)
            entry_signal_active := false
            active_entry_strategy := ""
            entry_price := na
            entry_tp := na
            entry_sl := na

            // Reset trade flags
            trade_entered := false
            order_placed := false
            order_placed_bar := -1

            // Delete yellow box
            if not na(eng_ob_box)
                box.delete(eng_ob_box)
                eng_ob_box := na

            // Delete TP/SL boxes
            if not na(tp_box)
                box.delete(tp_box)
                tp_box := na
            if not na(sl_box)
                box.delete(sl_box)
                sl_box := na

            // Clear BPR FVG state
            if not na(bpr_fvg_box)
                box.delete(bpr_fvg_box)
                bpr_fvg_box := na
            bpr_fvg_active := false
            bpr_fvg_is_bullish := false
            bpr_fvg_top := na
            bpr_fvg_bottom := na
            bpr_fvg_invalidation_level := na
            bpr_fvg_bar_index := na
            bpr_fvg_candle_high := na
            bpr_fvg_candle_low := na
            bpr_fvg_invalidation_reason := "9 AM reset"

            // Clear Inverted FVG state
            if not na(inv_fvg_overlap_box)
                box.delete(inv_fvg_overlap_box)
                inv_fvg_overlap_box := na
            inv_fvg_active := false
            inv_fvg_is_bullish := false
            inv_fvg_overlap_top := na
            inv_fvg_overlap_bottom := na
            inv_fvg_reversal_candle_high := na
            inv_fvg_reversal_candle_low := na
            inv_fvg_bar_index := na
            inv_fvg_invalidation_reason := "9 AM reset"

    // At trading window start time (default 09:30 NY time), reset all setup state for clean start
    // This ensures no stale setups from pre-market or previous sessions persist into trading window
    if at_trading_start
        // Invalidate any active setups from before trading window
        if eng_ob_active or entry_signal_active or bpr_fvg_active or inv_fvg_active
            // Close any open positions and cancel pending orders
            strategy.close_all()
            strategy.cancel_all()

            eng_ob_active := false
            eng_ob_is_bullish := false
            eng_ob_deepest_level := na
            eng_ob_bar_index := na
            eng_ob_candle_high := na
            eng_ob_candle_low := na
            target_fractal_level_mss := na

            // Clear entry signals (all strategies)
            entry_signal_active := false
            active_entry_strategy := ""
            entry_price := na
            entry_tp := na
            entry_sl := na
            entry_signal_bar_index := na

            // Reset trade flags
            trade_entered := false
            order_placed := false
            order_placed_bar := -1

            // Delete yellow box
            if not na(eng_ob_box)
                box.delete(eng_ob_box)
                eng_ob_box := na

            // Delete TP/SL boxes
            if not na(tp_box)
                box.delete(tp_box)
                tp_box := na
            if not na(sl_box)
                box.delete(sl_box)
                sl_box := na

            // Clear BPR FVG state
            if not na(bpr_fvg_box)
                box.delete(bpr_fvg_box)
                bpr_fvg_box := na
            bpr_fvg_active := false
            bpr_fvg_is_bullish := false
            bpr_fvg_top := na
            bpr_fvg_bottom := na
            bpr_fvg_invalidation_level := na
            bpr_fvg_bar_index := na
            bpr_fvg_candle_high := na
            bpr_fvg_candle_low := na
            bpr_fvg_invalidation_reason := "Trading start reset"

            // Clear Inverted FVG state
            if not na(inv_fvg_overlap_box)
                box.delete(inv_fvg_overlap_box)
                inv_fvg_overlap_box := na
            inv_fvg_active := false
            inv_fvg_is_bullish := false
            inv_fvg_overlap_top := na
            inv_fvg_overlap_bottom := na
            inv_fvg_reversal_candle_high := na
            inv_fvg_reversal_candle_low := na
            inv_fvg_bar_index := na
            inv_fvg_invalidation_reason := "Trading start reset"

    // At 20:00 (start of Asian session), clear all persisted boxes from the day
    if current_hour == 20
        // Delete all TP boxes - only if array has elements
        if array.size(daily_tp_boxes) > 0
            for i = 0 to array.size(daily_tp_boxes) - 1
                box.delete(array.get(daily_tp_boxes, i))
        array.clear(daily_tp_boxes)

        // Delete all SL boxes - only if array has elements
        if array.size(daily_sl_boxes) > 0
            for i = 0 to array.size(daily_sl_boxes) - 1
                box.delete(array.get(daily_sl_boxes, i))
        array.clear(daily_sl_boxes)

    last_trade_day := current_day

// Track when trade enters
if entry_signal_active and not trade_entered and strategy.position_size != 0
    last_position_entry := strategy.position_avg_price

// Track when trade exits and calculate P&L using strategy's closed trade P&L
var int last_closed_trades = 0
int current_closed_trades = strategy.closedtrades

if current_closed_trades > last_closed_trades
    // A new trade just closed - get the P&L from the most recent closed trade
    float trade_pnl = strategy.closedtrades.profit(strategy.closedtrades - 1)

    // Update daily stats
    today_trade_count += 1
    today_pnl += trade_pnl

    if trade_pnl > 0
        today_wins += 1
    else
        today_losses += 1

    last_closed_trades := current_closed_trades

// ============================================================================
// FORCE CLOSE AT TRADING WINDOW END - TOP LEVEL (runs every bar)
// ============================================================================
int check_hour = hour(time, "America/New_York")
int check_minute = minute(time, "America/New_York")
int check_time_mins = check_hour * 60 + check_minute
int end_time_mins = trading_end_hour * 60 + trading_end_minute

// Check if we're past trading end time and have an open position
if check_time_mins >= end_time_mins and strategy.position_size != 0
    // FIRST cancel all pending orders (including TP/SL exits)
    strategy.cancel_all()

    // THEN close the position
    if strategy.position_size > 0
        strategy.close("Long", comment="EOD Close")
    else if strategy.position_size < 0
        strategy.close("Short", comment="EOD Close")

// Check if currently outside both zones
bool outside_both_zones = not in_supply and not in_demand

if barstate.isnew
    // Clear trigger only if it's been more than 1 bar since entry AND no active setup
    // This keeps supply_triggered/demand_triggered true while a setup is tracking
    bool has_supply_setup = (eng_ob_active and not eng_ob_is_bullish) or (bpr_fvg_active and bpr_fvg_is_bullish)
    bool has_demand_setup = (eng_ob_active and eng_ob_is_bullish) or (bpr_fvg_active and not bpr_fvg_is_bullish)

    if bar_index - supply_trigger_bar > 1 and not has_supply_setup
        supply_triggered := false
    if bar_index - demand_trigger_bar > 1 and not has_demand_setup
        demand_triggered := false

    // Track when we're outside both zones
    // Only set was_outside_zones if there's NO active ENG OB setup
    if outside_both_zones and not eng_ob_active
        was_outside_zones := true

if in_supply
    supply_triggered := true
    supply_trigger_bar := bar_index

    // Reset deepest on fresh entry after being outside
    if was_outside_zones
        supply_highest_high := high
        was_outside_zones := false
    // Otherwise, track highest high in supply zone
    else if na(supply_highest_high) or high > supply_highest_high
        supply_highest_high := high

    // Track deepest EVER in supply zone (never resets, only gets deeper) - using CLOSE
    if na(supply_deepest_ever) or close > supply_deepest_ever
        supply_deepest_ever := close

if in_demand
    demand_triggered := true
    demand_trigger_bar := bar_index

    // Reset deepest on fresh entry after being outside
    if was_outside_zones
        demand_lowest_low := low
        was_outside_zones := false
    // Otherwise, track lowest low in demand zone
    else if na(demand_lowest_low) or low < demand_lowest_low
        demand_lowest_low := low

    // Track deepest EVER in demand zone (never resets, only gets deeper) - using CLOSE
    if na(demand_deepest_ever) or close < demand_deepest_ever
        demand_deepest_ever := close

// ============================================================================
// SETUP FLOW AND INVALIDATION RULES
// ============================================================================
// FLOW:
// 1. When AOI is entered, show "IN AOI"
// 2. If price leaves AOI without an ENG OB, return to "-"
// 3. If ENG OB forms, black diamond appears, ENG OB shows checkmark
//    - AOI status changes to "ACTIVE" (setup is now active)
//    - ENG OB stays checked until invalidated
// 4. Look BACKWARD for first opposite LTF fractal candle, place debug diamond above it
// 5. If price crosses fractal high (bullish) or low (bearish), MSS OB is formed
//    - Checkmark MSS OB row
//    - Draw entry OB from lowest candle in ENG OB setup (use that candle's high and low)
//    - Add debug row showing entry window
//    - Status changes to "AWAITING MSS OB ENTRY"
//
// INVALIDATION RULES:
// - ENG OB invalidated: if price goes deeper into zone than ENG OB candle before crossing fractal level (step 5)
// - MSS OB invalidated: if price touches opposite color zone (may add more criteria later)
//
// ============================================================================
// ENGULFING ORDER BLOCK DETECTION
// ============================================================================
bool is_bullish_engulfing = false
bool is_bearish_engulfing = false

// Only check for engulfing when in an AOI AND within trading window
if demand_triggered and bar_index > 0 and in_trading_window
    // Bullish engulfing: current candle close engulfs previous candle body
    bool current_bullish = close > open
    bool prev_bearish = close[1] < open[1]
    bool engulfs_body = close >= open[1]

    // Check if current or previous candle made the deepest low FOR THIS ZONE ENTRY
    bool is_deepest = low <= demand_lowest_low or low[1] <= demand_lowest_low

    // VALIDATION: ENG OB must be deeper than or equal to any previous ENG OB
    // The CLOSE of whichever candle made the deepest low must be lower than or equal to previous deepest close
    float deepest_candle_close = low <= low[1] ? close : close[1]
    bool is_deeper_than_previous = na(demand_deepest_ever) or deepest_candle_close <= demand_deepest_ever

    is_bullish_engulfing := current_bullish and prev_bearish and engulfs_body and is_deepest and is_deeper_than_previous

if supply_triggered and bar_index > 0 and in_trading_window
    // Bearish engulfing: current candle close engulfs previous candle body
    bool current_bearish = close < open
    bool prev_bullish = close[1] > open[1]
    bool engulfs_body = close <= open[1]

    // Check if current or previous candle made the highest high FOR THIS ZONE ENTRY
    bool is_deepest = high >= supply_highest_high or high[1] >= supply_highest_high

    // VALIDATION: ENG OB must be deeper than or equal to any previous ENG OB
    // The CLOSE of whichever candle made the highest high must be higher than or equal to previous deepest close
    float deepest_candle_close = high >= high[1] ? close : close[1]
    bool is_deeper_than_previous = na(supply_deepest_ever) or deepest_candle_close >= supply_deepest_ever

    is_bearish_engulfing := current_bearish and prev_bullish and engulfs_body and is_deepest and is_deeper_than_previous

bool engulfing_ob_detected = is_bullish_engulfing or is_bearish_engulfing

// NOTE: Trading window only prevents NEW setups from forming
// Existing setups remain active even outside trading window
// This allows setups to continue tracking but prevents new entries outside hours

// INVALIDATION: Setup expires after max_setup_bars (only if not in trade) or at trading end time
if eng_ob_active and not na(eng_ob_bar_index)
    bool should_invalidate_timeout = false
    string timeout_reason = ""

    // Check if setup has exceeded max bars (ONLY if not in a trade)
    if not trade_entered
        int bars_since_setup = bar_index - eng_ob_bar_index
        if bars_since_setup >= max_setup_bars
            should_invalidate_timeout := true
            timeout_reason := "Max bars (" + str.tostring(max_setup_bars) + ")"

    // Check if it's past trading end time (applies to ALL setups, including active trades)
    int current_hour = hour(time, "America/New_York")
    int current_minute = minute(time, "America/New_York")
    int current_time_mins = current_hour * 60 + current_minute
    int end_time_mins = trading_end_hour * 60 + trading_end_minute

    if current_time_mins >= end_time_mins
        should_invalidate_timeout := true
        string end_time_str = str.tostring(trading_end_hour) + ":" + (trading_end_minute < 10 ? "0" : "") + str.tostring(trading_end_minute)
        timeout_reason := timeout_reason == "" ? end_time_str + " NY time" : timeout_reason + " + " + end_time_str

    if should_invalidate_timeout
        label.new(bar_index, eng_ob_is_bullish ? low : high, "❌ TIMEOUT\n" + timeout_reason,
                 color=color.purple, textcolor=color.white,
                 style=eng_ob_is_bullish ? label.style_label_up : label.style_label_down,
                 size=size.small)

        // Close any open positions and cancel pending orders
        strategy.close_all()
        strategy.cancel_all()

        eng_ob_active := false
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level_mss := na

        // Clear entry signals (all strategies)
        entry_signal_active := false
        active_entry_strategy := ""
        entry_price := na
        entry_tp := na
        entry_sl := na

        // Reset trade flag
        trade_entered := false

        // Delete yellow box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

        // Delete TP/SL boxes
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

// INVALIDATION: Clear setup when zones are disabled
// Only invalidate if the disabled zone MATCHES the setup's zone
// Bullish setup (from demand) only invalidated by clear_demand
// Bearish setup (from supply) only invalidated by clear_supply
if eng_ob_active
    bool should_invalidate = false

    if eng_ob_is_bullish and clear_demand
        // Bullish setup invalidated by disabling demand zone
        should_invalidate := true
    else if not eng_ob_is_bullish and clear_supply
        // Bearish setup invalidated by disabling supply zone
        should_invalidate := true

    if should_invalidate
        eng_ob_active := false
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level_mss := na

        // Clear entry signals (all strategies)
        entry_signal_active := false
        active_entry_strategy := ""
        entry_price := na
        entry_tp := na
        entry_sl := na

        // Delete yellow box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

        // Delete TP/SL boxes
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

// INVALIDATION: Clear setup when entering the OPPOSITE zone (fresh zone entry)
// Bullish setup (from demand) invalidated by entering supply zone
// Bearish setup (from supply) invalidated by entering demand zone
if barstate.isnew and was_outside_zones
    if eng_ob_active and eng_ob_is_bullish and in_supply
        // Bullish setup invalidated by entering supply zone
        eng_ob_active := false
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level_mss := na

        // Clear entry signals (all strategies)
        entry_signal_active := false
        active_entry_strategy := ""
        entry_price := na
        entry_tp := na
        entry_sl := na

        // Delete yellow box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

        // Delete TP/SL boxes
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

    else if eng_ob_active and not eng_ob_is_bullish and in_demand
        // Bearish setup invalidated by entering demand zone
        eng_ob_active := false
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level_mss := na

        // Clear entry signals (all strategies)
        entry_signal_active := false
        active_entry_strategy := ""
        entry_price := na
        entry_tp := na
        entry_sl := na

        // Delete yellow box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

        // Delete TP/SL boxes
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

// When ENG OB forms, activate it and record deepest level + capture the OB candle
if is_bullish_engulfing
    eng_ob_active := true
    eng_ob_is_bullish := true
    eng_ob_deepest_level := demand_lowest_low
    target_fractal_level_mss := na  // Reset fractal search for new ENG OB

    // Determine which candle is the actual OB candle (the one that made the deepest low)
    // For bullish engulfing, the OB candle is whichever made the lowest low
    if low <= low[1]
        // Current candle made the deepest low - it's the OB candle
        eng_ob_bar_index := bar_index
        eng_ob_candle_high := high
        eng_ob_candle_low := low
    else
        // Previous candle made the deepest low - it's the OB candle
        eng_ob_bar_index := bar_index - 1
        eng_ob_candle_high := high[1]
        eng_ob_candle_low := low[1]

else if is_bearish_engulfing
    eng_ob_active := true
    eng_ob_is_bullish := false
    eng_ob_deepest_level := supply_highest_high
    target_fractal_level_mss := na  // Reset fractal search for new ENG OB

    // Determine which candle is the actual OB candle (the one that made the highest high)
    // For bearish engulfing, the OB candle is whichever made the highest high
    if high >= high[1]
        // Current candle made the highest high - it's the OB candle
        eng_ob_bar_index := bar_index
        eng_ob_candle_high := high
        eng_ob_candle_low := low
    else
        // Previous candle made the highest high - it's the OB candle
        eng_ob_bar_index := bar_index - 1
        eng_ob_candle_high := high[1]
        eng_ob_candle_low := low[1]

// INVALIDATION: Price goes deeper into zone than ENG OB candle (before MSS OB is crossed)
// Only invalidate if price is IN the zone and goes deeper than the OB candle
// TODO: Once MSS OB crossing detection is implemented, add condition to stop invalidation after cross
if eng_ob_active
    if eng_ob_is_bullish and demand_triggered and not na(eng_ob_candle_low)
        // Bullish setup invalidated if price makes new lower low than ENG OB candle's low WHILE IN DEMAND ZONE
        if low < eng_ob_candle_low
            eng_ob_active := false
            eng_ob_is_bullish := false
            eng_ob_deepest_level := na
            eng_ob_bar_index := na
            eng_ob_candle_high := na
            eng_ob_candle_low := na
            target_fractal_level_mss := na

            // Clear entry signals (all strategies)
            entry_signal_active := false
            active_entry_strategy := ""
            entry_price := na
            entry_tp := na
            entry_sl := na

            // Delete the yellow box when invalidated
            if not na(eng_ob_box)
                box.delete(eng_ob_box)
                eng_ob_box := na

            // Delete TP/SL boxes
            if not na(tp_box)
                box.delete(tp_box)
                tp_box := na
            if not na(sl_box)
                box.delete(sl_box)
                sl_box := na

    else if not eng_ob_is_bullish and supply_triggered and not na(eng_ob_candle_high)
        // Bearish setup invalidated if price makes new higher high than ENG OB candle's high WHILE IN SUPPLY ZONE
        if high > eng_ob_candle_high
            eng_ob_active := false
            eng_ob_is_bullish := false
            eng_ob_deepest_level := na
            eng_ob_bar_index := na
            eng_ob_candle_high := na
            eng_ob_candle_low := na
            target_fractal_level_mss := na

            // Clear entry signals (all strategies)
            entry_signal_active := false
            active_entry_strategy := ""
            entry_price := na
            entry_tp := na
            entry_sl := na

            // Delete the yellow box when invalidated
            if not na(eng_ob_box)
                box.delete(eng_ob_box)
                eng_ob_box := na

            // Delete TP/SL boxes
            if not na(tp_box)
                box.delete(tp_box)
                tp_box := na
            if not na(sl_box)
                box.delete(sl_box)
                sl_box := na

// INVALIDATION: Entry signal invalidated when price reaches opposite zone
// This invalidation applies even if we haven't left both zones
// Bullish entry invalidated by touching supply zone
// Bearish entry invalidated by touching demand zone
if entry_signal_active
    bool should_invalidate_entry = false

    // Use entry_is_bullish (generic for all strategies) instead of eng_ob_is_bullish (ENG OB specific)
    if entry_is_bullish and in_supply
        // Bullish entry invalidated by reaching supply zone
        should_invalidate_entry := true
    else if not entry_is_bullish and in_demand
        // Bearish entry invalidated by reaching demand zone
        should_invalidate_entry := true

    if should_invalidate_entry
        // Clear strategy-specific state based on which strategy placed the order
        if active_entry_strategy == "MSS OB"
            // MSS OB strategy - clear ENG OB state
            eng_ob_active := false
            eng_ob_is_bullish := false
            eng_ob_deepest_level := na
            eng_ob_bar_index := na
            eng_ob_candle_high := na
            eng_ob_candle_low := na
            target_fractal_level_mss := na

            // Delete the ENG OB box
            if not na(eng_ob_box)
                box.delete(eng_ob_box)
                eng_ob_box := na

        else if active_entry_strategy == "BPR FVG"
            // BPR FVG strategy - clear BPR FVG state
            bpr_fvg_active := false
            bpr_fvg_is_bullish := false
            bpr_fvg_top := na
            bpr_fvg_bottom := na
            bpr_fvg_invalidation_level := na
            bpr_fvg_bar_index := na
            bpr_fvg_candle_high := na
            bpr_fvg_candle_low := na
            bpr_fvg_invalidation_reason := "Opposite zone reached"

            // Delete the BPR FVG box
            if not na(bpr_fvg_box)
                box.delete(bpr_fvg_box)
                bpr_fvg_box := na

        else if active_entry_strategy == "Inverted FVG"
            // Inverted FVG strategy - clear both BPR FVG and Inverted FVG state
            bpr_fvg_active := false
            bpr_fvg_is_bullish := false
            bpr_fvg_top := na
            bpr_fvg_bottom := na
            bpr_fvg_invalidation_level := na
            bpr_fvg_bar_index := na
            bpr_fvg_candle_high := na
            bpr_fvg_candle_low := na
            bpr_fvg_invalidation_reason := "Opposite zone reached"

            inv_fvg_active := false
            inv_fvg_is_bullish := false
            inv_fvg_overlap_top := na
            inv_fvg_overlap_bottom := na
            inv_fvg_reversal_candle_high := na
            inv_fvg_reversal_candle_low := na
            inv_fvg_bar_index := na
            inv_fvg_invalidation_reason := "Opposite zone reached"

            // Delete the BPR FVG box and Inverted FVG overlap box
            if not na(bpr_fvg_box)
                box.delete(bpr_fvg_box)
                bpr_fvg_box := na
            if not na(inv_fvg_overlap_box)
                box.delete(inv_fvg_overlap_box)
                inv_fvg_overlap_box := na

        else if active_entry_strategy == "Breaker Block"
            // Breaker Block strategy - clear ENG OB state
            eng_ob_active := false
            eng_ob_is_bullish := false
            eng_ob_deepest_level := na
            eng_ob_bar_index := na
            eng_ob_candle_high := na
            eng_ob_candle_low := na
            target_fractal_level_mss := na

            // Delete the ENG OB box
            if not na(eng_ob_box)
                box.delete(eng_ob_box)
                eng_ob_box := na

        // Clear entry signals (all strategies)
        entry_signal_active := false
        active_entry_strategy := ""
        entry_price := na
        entry_tp := na
        entry_sl := na

        // Delete TP/SL boxes (shared across all strategies)
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

// Track which candle made the deepest penetration (only show current)
var label deepest_demand_label = na
var label deepest_supply_label = na

// Update deepest marker when new deepest is found - place below/above candle to avoid covering it
if demand_triggered and not na(demand_lowest_low) and low == demand_lowest_low
    // Delete old label
    if not na(deepest_demand_label)
        label.delete(deepest_demand_label)
    // Create new label below the candle low
    deepest_demand_label := label.new(bar_index, low, "●", xloc=xloc.bar_index, yloc=yloc.price, color=color.new(color.white, 100), textcolor=color.blue, size=size.tiny, style=label.style_label_up, textalign=text.align_center)

if supply_triggered and not na(supply_highest_high) and high == supply_highest_high
    // Delete old label
    if not na(deepest_supply_label)
        label.delete(deepest_supply_label)
    // Create new label above the candle high
    deepest_supply_label := label.new(bar_index, high, "●", xloc=xloc.bar_index, yloc=yloc.price, color=color.new(color.white, 100), textcolor=color.orange, size=size.tiny, style=label.style_label_down, textalign=text.align_center)

// Plot diamonds for engulfing OB detection (smaller size)
plotshape(is_bullish_engulfing, title="Bullish Engulfing OB", style=shape.diamond, location=location.belowbar, color=color.black, size=size.tiny)
plotshape(is_bearish_engulfing, title="Bearish Engulfing OB", style=shape.diamond, location=location.abovebar, color=color.black, size=size.tiny)

// DEBUG: Plot bar index counter for BPR FVG (helps diagnose replay mode issues)
// This appears as a label on the chart so you can see it update in real-time
if bpr_fvg_active and not na(bpr_fvg_bar_index)
    int bars_since_fvg = bar_index - bpr_fvg_bar_index
    string debug_text = "FVG: " + str.tostring(bars_since_fvg) + "/" + str.tostring(setup_timeout_bars) + "\nbar=" + str.tostring(bar_index) + " fvg_bar=" + str.tostring(bpr_fvg_bar_index)
    label.new(bar_index, high, debug_text, style=label.style_label_down, color=color.yellow, textcolor=color.black, size=size.small)

// DEBUG: Show when NEW FVG is detected
if not bpr_fvg_active[1] and bpr_fvg_active
    label.new(bar_index, low, "NEW FVG", style=label.style_label_up, color=color.orange, textcolor=color.white, size=size.small)

// ============================================================================
// BPR FVG DETECTION
// ============================================================================
// FVG = Fair Value Gap = gap between candle 1 high/low and candle 3 low/high
// Bullish FVG: low[0] > high[2] (gap up)
// Bearish FVG: high[0] < low[2] (gap down)
// BPR = Balanced Price Range = FVG that forms in AOI

// Detect BPR FVG when in AOI and within trading window (no ENG OB requirement)
// Check if ANY of the 3 FVG candles touched the zone
// Don't detect new FVGs when we already have an active entry signal, active trade, or within cooldown
bool in_cooldown = last_exit_bar >= 0 and (bar_index - last_exit_bar) < cooldown_bars
if not bpr_fvg_active and not entry_signal_active and not trade_entered and not in_cooldown and bar_index >= 2 and in_trading_window and (in_supply or in_demand)
    // Bearish setup: detect bullish FVG in supply zone
    // Check if current candle OR previous 2 candles touched supply zone
    bool supply_touched_by_fvg_candles = false
    if supply_configured
        // Check current candle (candle 3)
        bool c0_in_supply = not (low > supply_top or high < supply_bottom)
        // Check candle 1 bar ago (candle 2)
        bool c1_in_supply = not (low[1] > supply_top or high[1] < supply_bottom)
        // Check candle 2 bars ago (candle 1)
        bool c2_in_supply = not (low[2] > supply_top or high[2] < supply_bottom)

        supply_touched_by_fvg_candles := c0_in_supply or c1_in_supply or c2_in_supply

    if supply_touched_by_fvg_candles
        // Bullish FVG: current low > high of 2 bars ago (gap up)
        bool has_bullish_fvg = low > high[2]

        if has_bullish_fvg
            // Calculate FVG size in ticks
            float fvg_size = low - high[2]
            float fvg_size_ticks = fvg_size / syminfo.mintick

            // Only activate if FVG meets minimum tick size requirement
            if fvg_size_ticks >= bpr_fvg_min_ticks
                bpr_fvg_active := true
                bpr_fvg_is_bullish := true
                bpr_fvg_bottom := high[2]  // Bottom of gap
                bpr_fvg_top := low  // Top of gap
                bpr_fvg_bar_index := bar_index

                // Capture the FVG candle (current candle) high/low for SL
                bpr_fvg_candle_high := high
                bpr_fvg_candle_low := low

                // Invalidation level: highest high of the 3 candles involved
                bpr_fvg_invalidation_level := math.max(high[2], math.max(high[1], high))

    // Bullish setup: detect bearish FVG in demand zone
    // Check if current candle OR previous 2 candles touched demand zone
    bool demand_touched_by_fvg_candles = false
    if demand_configured
        // Check current candle (candle 3)
        bool c0_in_demand = not (low > demand_top or high < demand_bottom)
        // Check candle 1 bar ago (candle 2)
        bool c1_in_demand = not (low[1] > demand_top or high[1] < demand_bottom)
        // Check candle 2 bars ago (candle 1)
        bool c2_in_demand = not (low[2] > demand_top or high[2] < demand_bottom)

        demand_touched_by_fvg_candles := c0_in_demand or c1_in_demand or c2_in_demand

    if demand_touched_by_fvg_candles
        // Bearish FVG: current high < low of 2 bars ago (gap down)
        bool has_bearish_fvg = high < low[2]

        if has_bearish_fvg
            // Calculate FVG size in ticks
            float fvg_size = low[2] - high
            float fvg_size_ticks = fvg_size / syminfo.mintick

            // Only activate if FVG meets minimum tick size requirement
            if fvg_size_ticks >= bpr_fvg_min_ticks
                bpr_fvg_active := true
                bpr_fvg_is_bullish := false
                bpr_fvg_top := low[2]  // Top of gap
                bpr_fvg_bottom := high  // Bottom of gap
                bpr_fvg_bar_index := bar_index

                // Capture the FVG candle (current candle) high/low for SL
                bpr_fvg_candle_high := high
                bpr_fvg_candle_low := low

                // Invalidation level: lowest low of the 3 candles involved
                bpr_fvg_invalidation_level := math.min(low[2], math.min(low[1], low))

// INVALIDATION: Price closes beyond invalidation level (deeper into zone)
// This catches price going BACK INTO the zone (wrong direction), not price breaching THROUGH the FVG
// Don't run this invalidation once entry signal is active
if bpr_fvg_active and not entry_signal_active
    bool should_invalidate_fvg = false

    if bpr_fvg_is_bullish
        // Bullish FVG (bearish trade): invalidated if close goes HIGHER than invalidation level (back into supply)
        if close > bpr_fvg_invalidation_level
            should_invalidate_fvg := true
            bpr_fvg_invalidation_reason := "Price beyond invalidation (" + str.tostring(close, format.mintick) + " > " + str.tostring(bpr_fvg_invalidation_level, format.mintick) + ")"
    else
        // Bearish FVG (bullish trade): invalidated if close goes LOWER than invalidation level (back into demand)
        if close < bpr_fvg_invalidation_level
            should_invalidate_fvg := true
            bpr_fvg_invalidation_reason := "Price beyond invalidation (" + str.tostring(close, format.mintick) + " < " + str.tostring(bpr_fvg_invalidation_level, format.mintick) + ")"

    if should_invalidate_fvg
        bpr_fvg_active := false
        bpr_fvg_is_bullish := false
        bpr_fvg_top := na
        bpr_fvg_bottom := na
        bpr_fvg_invalidation_level := na
        bpr_fvg_bar_index := na
        bpr_fvg_candle_high := na
        bpr_fvg_candle_low := na

        // Delete FVG box
        if not na(bpr_fvg_box)
            box.delete(bpr_fvg_box)
            bpr_fvg_box := na

// SAFETY: Clear zombie BPR FVG state (active but bar_index is na)
if bpr_fvg_active and na(bpr_fvg_bar_index)
    bpr_fvg_active := false
    bpr_fvg_is_bullish := false
    bpr_fvg_top := na
    bpr_fvg_bottom := na
    bpr_fvg_invalidation_level := na
    bpr_fvg_candle_high := na
    bpr_fvg_candle_low := na
    bpr_fvg_invalidation_reason := "Zombie state cleared (bar_index was na)"
    if not na(bpr_fvg_box)
        box.delete(bpr_fvg_box)
        bpr_fvg_box := na

// INVALIDATION: BPR FVG timeout after N bars without entry signal
if bpr_fvg_active and not entry_signal_active and not na(bpr_fvg_bar_index)
    int bars_since_bpr = bar_index - bpr_fvg_bar_index
    if bars_since_bpr >= setup_timeout_bars
        bpr_fvg_invalidation_reason := "Timeout (" + str.tostring(bars_since_bpr) + " bars)"

        bpr_fvg_active := false
        bpr_fvg_is_bullish := false
        bpr_fvg_top := na
        bpr_fvg_bottom := na
        bpr_fvg_invalidation_level := na
        bpr_fvg_bar_index := na
        bpr_fvg_candle_high := na
        bpr_fvg_candle_low := na

        // Delete FVG box
        if not na(bpr_fvg_box)
            box.delete(bpr_fvg_box)
            bpr_fvg_box := na

// INVALIDATION: Clear BPR FVG when zones are disabled
if bpr_fvg_active
    bool should_invalidate_fvg_zone = false

    if bpr_fvg_is_bullish and clear_supply
        should_invalidate_fvg_zone := true
        bpr_fvg_invalidation_reason := "Supply zone disabled"
    else if not bpr_fvg_is_bullish and clear_demand
        should_invalidate_fvg_zone := true
        bpr_fvg_invalidation_reason := "Demand zone disabled"

    if should_invalidate_fvg_zone
        bpr_fvg_active := false
        bpr_fvg_is_bullish := false
        bpr_fvg_top := na
        bpr_fvg_bottom := na
        bpr_fvg_invalidation_level := na
        bpr_fvg_bar_index := na
        bpr_fvg_candle_high := na
        bpr_fvg_candle_low := na

        // Delete FVG box
        if not na(bpr_fvg_box)
            box.delete(bpr_fvg_box)
            bpr_fvg_box := na

// INVALIDATION: Clear BPR FVG when entering opposite zone
if barstate.isnew and was_outside_zones and bpr_fvg_active
    bool should_invalidate_opposite = false

    if bpr_fvg_is_bullish and in_demand
        should_invalidate_opposite := true
        bpr_fvg_invalidation_reason := "Entered opposite zone (demand)"
    else if not bpr_fvg_is_bullish and in_supply
        should_invalidate_opposite := true
        bpr_fvg_invalidation_reason := "Entered opposite zone (supply)"

    if should_invalidate_opposite
        bpr_fvg_active := false
        bpr_fvg_is_bullish := false
        bpr_fvg_top := na
        bpr_fvg_bottom := na
        bpr_fvg_invalidation_level := na
        bpr_fvg_bar_index := na
        bpr_fvg_candle_high := na
        bpr_fvg_candle_low := na

        // Delete FVG box
        if not na(bpr_fvg_box)
            box.delete(bpr_fvg_box)
            bpr_fvg_box := na

// Visualize BPR FVG with dotted blue outline and darker yellow fill
if bpr_fvg_active
    // Create box on first detection
    if na(bpr_fvg_box)
        bpr_fvg_box := box.new(bpr_fvg_bar_index, bpr_fvg_top, bpr_fvg_bar_index + 1, bpr_fvg_bottom,
                               border_color=color.blue,
                               border_style=line.style_dotted,
                               bgcolor=color.new(color.yellow, 70),
                               border_width=1,
                               extend=extend.none)
    else
        // Extend box to current bar
        box.set_right(bpr_fvg_box, bar_index + 1)

// ============================================================================
// INVERTED FVG DETECTION
// ============================================================================
// Inverted FVG = BPR FVG + opposite direction FVG that overlaps
// Entry is at the overlap zone, not at the FVG breach
// Every Inverted FVG starts as a BPR FVG, but not every BPR FVG becomes Inverted

// Detect Inverted FVG when we have an active BPR FVG (not yet triggered entry)
// Look for opposite direction FVG that overlaps the initial BPR FVG
// Don't detect when entry signal is already active or trade is entered
if use_inverted_fvg and bpr_fvg_active and not inv_fvg_active and not entry_signal_active and not trade_entered and bar_index >= 2
    // Check for opposite direction FVG
    if bpr_fvg_is_bullish
        // Initial FVG is bullish (gap up) - look for bearish FVG (gap down) that overlaps
        // Bearish FVG: current high < low of 2 bars ago
        bool has_bearish_reversal_fvg = high < low[2]

        if has_bearish_reversal_fvg
            // Check if reversal FVG overlaps initial FVG
            float reversal_fvg_top = low[2]
            float reversal_fvg_bottom = high

            // Overlap exists if reversal bottom < initial top AND reversal top > initial bottom
            bool has_overlap = reversal_fvg_bottom < bpr_fvg_top and reversal_fvg_top > bpr_fvg_bottom

            if has_overlap
                // Calculate overlap zone
                float overlap_top = math.min(reversal_fvg_top, bpr_fvg_top)
                float overlap_bottom = math.max(reversal_fvg_bottom, bpr_fvg_bottom)

                // Activate Inverted FVG
                inv_fvg_active := true
                inv_fvg_is_bullish := false  // Bearish trade (reversal FVG is bearish)
                inv_fvg_overlap_top := overlap_top
                inv_fvg_overlap_bottom := overlap_bottom
                inv_fvg_bar_index := bar_index

                // Track reversal candle for SL - whichever of the 3 candles made the highest high
                if high >= high[1] and high >= high[2]
                    inv_fvg_reversal_candle_high := high
                    inv_fvg_reversal_candle_low := low
                else if high[1] >= high[2]
                    inv_fvg_reversal_candle_high := high[1]
                    inv_fvg_reversal_candle_low := low[1]
                else
                    inv_fvg_reversal_candle_high := high[2]
                    inv_fvg_reversal_candle_low := low[2]
    else
        // Initial FVG is bearish (gap down) - look for bullish FVG (gap up) that overlaps
        // Bullish FVG: current low > high of 2 bars ago
        bool has_bullish_reversal_fvg = low > high[2]

        if has_bullish_reversal_fvg
            // Check if reversal FVG overlaps initial FVG
            float reversal_fvg_top = low
            float reversal_fvg_bottom = high[2]

            // Overlap exists if reversal bottom < initial top AND reversal top > initial bottom
            bool has_overlap = reversal_fvg_bottom < bpr_fvg_top and reversal_fvg_top > bpr_fvg_bottom

            if has_overlap
                // Calculate overlap zone
                float overlap_top = math.min(reversal_fvg_top, bpr_fvg_top)
                float overlap_bottom = math.max(reversal_fvg_bottom, bpr_fvg_bottom)

                // Activate Inverted FVG
                inv_fvg_active := true
                inv_fvg_is_bullish := true  // Bullish trade (reversal FVG is bullish)
                inv_fvg_overlap_top := overlap_top
                inv_fvg_overlap_bottom := overlap_bottom
                inv_fvg_bar_index := bar_index

                // Track reversal candle for SL - whichever of the 3 candles made the lowest low
                if low <= low[1] and low <= low[2]
                    inv_fvg_reversal_candle_high := high
                    inv_fvg_reversal_candle_low := low
                else if low[1] <= low[2]
                    inv_fvg_reversal_candle_high := high[1]
                    inv_fvg_reversal_candle_low := low[1]
                else
                    inv_fvg_reversal_candle_high := high[2]
                    inv_fvg_reversal_candle_low := low[2]

// INVALIDATION: Clear Inverted FVG when zones are disabled
if inv_fvg_active
    bool should_invalidate_inv_fvg_zone = false

    if inv_fvg_is_bullish and clear_demand
        should_invalidate_inv_fvg_zone := true
        inv_fvg_invalidation_reason := "Demand zone disabled"
    else if not inv_fvg_is_bullish and clear_supply
        should_invalidate_inv_fvg_zone := true
        inv_fvg_invalidation_reason := "Supply zone disabled"

    if should_invalidate_inv_fvg_zone
        inv_fvg_active := false
        inv_fvg_is_bullish := false
        inv_fvg_overlap_top := na
        inv_fvg_overlap_bottom := na
        inv_fvg_reversal_candle_high := na
        inv_fvg_reversal_candle_low := na
        inv_fvg_bar_index := na

        // Delete overlap box
        if not na(inv_fvg_overlap_box)
            box.delete(inv_fvg_overlap_box)
            inv_fvg_overlap_box := na

// SAFETY: Clear zombie Inverted FVG state (active but bar_index is na)
if inv_fvg_active and na(inv_fvg_bar_index)
    inv_fvg_active := false
    inv_fvg_is_bullish := false
    inv_fvg_overlap_top := na
    inv_fvg_overlap_bottom := na
    inv_fvg_reversal_candle_high := na
    inv_fvg_reversal_candle_low := na
    inv_fvg_invalidation_reason := "Zombie state cleared (bar_index was na)"
    if not na(inv_fvg_overlap_box)
        box.delete(inv_fvg_overlap_box)
        inv_fvg_overlap_box := na

// INVALIDATION: Inverted FVG timeout after N bars without entry signal
if inv_fvg_active and not entry_signal_active and not na(inv_fvg_bar_index)
    int bars_since_inv = bar_index - inv_fvg_bar_index
    if bars_since_inv >= setup_timeout_bars
        inv_fvg_invalidation_reason := "Timeout (" + str.tostring(bars_since_inv) + " bars)"

        inv_fvg_active := false
        inv_fvg_is_bullish := false
        inv_fvg_overlap_top := na
        inv_fvg_overlap_bottom := na
        inv_fvg_reversal_candle_high := na
        inv_fvg_reversal_candle_low := na
        inv_fvg_bar_index := na

        // Delete overlap box
        if not na(inv_fvg_overlap_box)
            box.delete(inv_fvg_overlap_box)
            inv_fvg_overlap_box := na

// INVALIDATION: Clear Inverted FVG when entering opposite zone
if barstate.isnew and was_outside_zones and inv_fvg_active
    bool should_invalidate_inv_opposite = false

    if inv_fvg_is_bullish and in_supply
        should_invalidate_inv_opposite := true
        inv_fvg_invalidation_reason := "Entered opposite zone (supply)"
    else if not inv_fvg_is_bullish and in_demand
        should_invalidate_inv_opposite := true
        inv_fvg_invalidation_reason := "Entered opposite zone (demand)"

    if should_invalidate_inv_opposite
        inv_fvg_active := false
        inv_fvg_is_bullish := false
        inv_fvg_overlap_top := na
        inv_fvg_overlap_bottom := na
        inv_fvg_reversal_candle_high := na
        inv_fvg_reversal_candle_low := na
        inv_fvg_bar_index := na

        // Delete overlap box
        if not na(inv_fvg_overlap_box)
            box.delete(inv_fvg_overlap_box)
            inv_fvg_overlap_box := na

// Visualize Inverted FVG overlap with dotted blue outline and darker yellow fill
if inv_fvg_active
    // Create overlap box on first detection
    if na(inv_fvg_overlap_box)
        inv_fvg_overlap_box := box.new(inv_fvg_bar_index, inv_fvg_overlap_top, inv_fvg_bar_index + 1, inv_fvg_overlap_bottom,
                                       border_color=color.blue,
                                       border_style=line.style_dotted,
                                       bgcolor=color.new(color.yellow, 70),
                                       border_width=1,
                                       extend=extend.none)
    else
        // Extend overlap box to current bar
        box.set_right(inv_fvg_overlap_box, bar_index + 1)

// ============================================================================
// ENTRY ZONE VISUALIZATION - Works for ALL entry strategies
// ============================================================================
// Standard visual flow for all 4 entry strategies:
// 1. YELLOW box = ENG OB detected (entry zone identified)
// 2. BLUE box = Entry signal active (limit order placed, awaiting fill)
// 3. GREEN/RED boxes = Trade entered (TP/SL shown when position is open)

// STEP 1: Create YELLOW box with dotted blue outline when ENG OB forms
if is_bullish_engulfing or is_bearish_engulfing
    // Delete old box
    if not na(eng_ob_box)
        box.delete(eng_ob_box)

    // Draw new box around the OB candle we just identified
    if not na(eng_ob_bar_index)
        int box_left = eng_ob_bar_index
        int box_right = eng_ob_bar_index + 1
        float box_top = eng_ob_candle_high
        float box_bottom = eng_ob_candle_low

        // Use darker yellow fill with dotted blue outline for ENG OB (entry zone)
        eng_ob_box := box.new(box_left, box_top, box_right, box_bottom,
                              border_color=color.blue,
                              border_style=line.style_dotted,
                              bgcolor=color.new(color.yellow, 70),
                              border_width=1,
                              extend=extend.none)

// STEP 2: Extend box and change fill to BLUE when entry signal activates
if (eng_ob_active or entry_signal_active) and not na(eng_ob_box)
    box.set_right(eng_ob_box, bar_index + 1)

    // Change fill to blue ONLY when MSS OB or other ENG OB-based strategies activate (not BPR FVG)
    // Border stays dotted blue throughout
    if entry_signal_active and active_entry_strategy != "BPR FVG"
        box.set_bgcolor(eng_ob_box, color.new(color.blue, 90))

// STEP 2: Extend BPR FVG box and change fill to BLUE when entry signal activates
if bpr_fvg_active and not na(bpr_fvg_box)
    box.set_right(bpr_fvg_box, bar_index + 1)

    // Change fill to blue when BPR FVG entry strategy activates (limit order placed)
    // Border stays dotted blue throughout
    if entry_signal_active and active_entry_strategy == "BPR FVG"
        box.set_bgcolor(bpr_fvg_box, color.new(color.blue, 90))

// STEP 2: Extend Inverted FVG overlap box and change fill to BLUE when entry signal activates
if inv_fvg_active and not na(inv_fvg_overlap_box)
    box.set_right(inv_fvg_overlap_box, bar_index + 1)

    // Change fill to blue when Inverted FVG entry strategy activates (limit order placed)
    // Border stays dotted blue throughout
    if entry_signal_active and active_entry_strategy == "Inverted FVG"
        box.set_bgcolor(inv_fvg_overlap_box, color.new(color.blue, 90))

// ============================================================================
// LTF FRACTAL DETECTION (only when in AOI or active setup)
// ============================================================================
// Only detect fractals when we're in AOI or have an active setup
bool should_detect_fractals = supply_triggered or demand_triggered or eng_ob_active

// Fractal detection: 2-period lookback/forward (5 candle pattern)
bool is_bearish_fractal = false
bool is_bullish_fractal = false

if should_detect_fractals and bar_index >= 2
    // Bearish fractal: high is higher than 2 candles before and 2 candles after
    is_bearish_fractal := high[2] > high[4] and high[2] > high[3] and high[2] > high[1] and high[2] > high[0]

    // Bullish fractal: low is lower than 2 candles before and 2 candles after
    is_bullish_fractal := low[2] < low[4] and low[2] < low[3] and low[2] < low[1] and low[2] < low[0]

// Plot fractals for debugging (only when actively detecting)
plotshape(is_bearish_fractal, title="Bearish Fractal", style=shape.triangledown, location=location.abovebar, color=color.red, size=size.tiny, offset=-2)
plotshape(is_bullish_fractal, title="Bullish Fractal", style=shape.triangleup, location=location.belowbar, color=color.green, size=size.tiny, offset=-2)

// ============================================================================
// MSS OB STRATEGY - Fractal Detection
// ============================================================================
// When ENG OB forms, search BACKWARD for the most recent opposite fractal
// This runs once when target_fractal_level_mss is na (right after ENG OB forms)
if use_mss_ob and eng_ob_active and na(target_fractal_level_mss) and bar_index >= 6
    // Search backward up to 20 bars for the most recent opposite fractal
    // Fractal pattern needs i-2, i-1, i, i+1, i+2 so we can only look back where i+2 is valid
    // Maximum safe lookback considering historical buffer limit
    int max_safe_lookback = bar_index - 4  // Ensures i+2 doesn't exceed bar_index
    int lookback_limit = math.min(20, max_safe_lookback)

    if eng_ob_is_bullish and lookback_limit >= 2
        // Bullish setup: look for most recent bearish fractal (high point)
        for i = 2 to lookback_limit
            // Double-check bounds before accessing historical data
            // This prevents accessing offsets beyond the historical buffer
            if i + 2 <= bar_index and not na(high[i+2]) and not na(high[i+1]) and not na(high[i-1]) and not na(high[i-2])
                bool is_bearish_frac = high[i] > high[i+2] and high[i] > high[i+1] and high[i] > high[i-1] and high[i] > high[i-2]
                if is_bearish_frac
                    // Found the most recent bearish fractal
                    target_fractal_level_mss := high[i]
                    break
    else if lookback_limit >= 2
        // Bearish setup: look for most recent bullish fractal (low point)
        for i = 2 to lookback_limit
            // Double-check bounds before accessing historical data
            // This prevents accessing offsets beyond the historical buffer
            if i + 2 <= bar_index and not na(low[i+2]) and not na(low[i+1]) and not na(low[i-1]) and not na(low[i-2])
                bool is_bullish_frac = low[i] < low[i+2] and low[i] < low[i+1] and low[i] < low[i-1] and low[i] < low[i-2]
                if is_bullish_frac
                    // Found the most recent bullish fractal
                    target_fractal_level_mss := low[i]
                    break

// ============================================================================
// MSS OB STRATEGY - Entry Signal Detection
// ============================================================================
// Check if price has crossed the fractal level (wick or close through)
// Don't trigger new entries while a trade is active, on same bar as exit, or within cooldown
if use_mss_ob and eng_ob_active and not entry_signal_active and not trade_entered and not in_cooldown and not na(target_fractal_level_mss)
    bool fractal_crossed = false

    if eng_ob_is_bullish
        // Bullish setup: check if price crossed above the bearish fractal high
        fractal_crossed := high >= target_fractal_level_mss
    else
        // Bearish setup: check if price crossed below the bullish fractal low
        fractal_crossed := low <= target_fractal_level_mss

    if fractal_crossed
        // MSS OB entry signal triggered
        entry_signal_active := true
        entry_signal_bar_index := bar_index
        active_entry_strategy := "MSS OB"
        entry_is_bullish := eng_ob_is_bullish

        // Set entry, TP, and SL based on the OB candle
        if eng_ob_is_bullish
            // Bullish: Entry at high of OB candle, SL at low (with grace ticks), TP at 2:1 RR
            entry_price := eng_ob_candle_high
            entry_sl := eng_ob_candle_low - grace_ticks  // Pad SL below the low
            float risk = entry_price - entry_sl
            entry_tp := entry_price + (risk * 2)  // 2:1 reward to risk
        else
            // Bearish: Entry at low of OB candle, SL at high (with grace ticks), TP at 2:1 RR
            entry_price := eng_ob_candle_low
            entry_sl := eng_ob_candle_high + grace_ticks  // Pad SL above the high
            float risk = entry_sl - entry_price
            entry_tp := entry_price - (risk * 2)  // 2:1 reward to risk

// ============================================================================
// BPR FVG STRATEGY - Entry Signal Detection
// ============================================================================
// Entry triggered when price CLOSES below FVG bottom (bearish) or above FVG top (bullish)
// Don't trigger new entries while a trade is active or within cooldown period
// IMPORTANT: Only check at bar close (barstate.isconfirmed) to wait for candle to fully close
if use_bpr_fvg and bpr_fvg_active and not entry_signal_active and not trade_entered and not in_cooldown and barstate.isconfirmed
    bool close_through_fvg = false

    if bpr_fvg_is_bullish
        // Bearish setup: wait for close BELOW FVG bottom (fully breached)
        close_through_fvg := close < bpr_fvg_bottom
    else
        // Bullish setup: wait for close ABOVE FVG top (fully breached)
        close_through_fvg := close > bpr_fvg_top

    if close_through_fvg
        entry_signal_active := true
        entry_signal_bar_index := bar_index
        active_entry_strategy := "BPR FVG"
        entry_is_bullish := not bpr_fvg_is_bullish  // Inverse: bullish FVG = bearish trade

        if bpr_fvg_is_bullish
            // Bearish setup: Entry at bottom of FVG, SL at HIGH of FVG candle (with grace ticks), TP at 2:1 RR
            entry_price := bpr_fvg_bottom
            entry_sl := bpr_fvg_candle_high + grace_ticks  // Pad SL above the candle high
            float risk = entry_sl - entry_price
            entry_tp := entry_price - (risk * 2)  // 2:1 reward to risk
        else
            // Bullish setup: Entry at top of FVG, SL at LOW of FVG candle (with grace ticks), TP at 2:1 RR
            entry_price := bpr_fvg_top
            entry_sl := bpr_fvg_candle_low - grace_ticks  // Pad SL below the candle low
            float risk = entry_price - entry_sl
            entry_tp := entry_price + (risk * 2)  // 2:1 reward to risk

        // DON'T clear BPR FVG state here - keep it for debug table display
        // It will be cleared when trade exits or is invalidated

// ============================================================================
// INVERTED FVG STRATEGY - Entry Signal Detection
// ============================================================================
// Entry triggered when Inverted FVG is detected (overlap found)
// Entry is at top of overlap (bearish) or bottom of overlap (bullish)
// SL is at high/low of reversal FVG candle, TP is 2:1 RR
if use_inverted_fvg and inv_fvg_active and not entry_signal_active and not trade_entered and not in_cooldown
    // Inverted FVG entry triggers immediately when overlap is detected
    entry_signal_active := true
    entry_signal_bar_index := bar_index
    active_entry_strategy := "Inverted FVG"
    entry_is_bullish := inv_fvg_is_bullish

    if inv_fvg_is_bullish
        // Bullish setup: Entry at TOP of overlap, SL at LOW of reversal candle
        entry_price := inv_fvg_overlap_top
        entry_sl := inv_fvg_reversal_candle_low - grace_ticks
        float risk = entry_price - entry_sl
        entry_tp := entry_price + (risk * 2)  // 2:1 RR
    else
        // Bearish setup: Entry at BOTTOM of overlap, SL at HIGH of reversal candle
        entry_price := inv_fvg_overlap_bottom
        entry_sl := inv_fvg_reversal_candle_high + grace_ticks
        float risk = entry_sl - entry_price
        entry_tp := entry_price - (risk * 2)  // 2:1 RR

// ============================================================================
// BREAKER BLOCK STRATEGY - Entry Signal Detection
// ============================================================================
// TODO: Implement Breaker Block detection
if use_breaker_block and eng_ob_active and not entry_signal_active
    // Placeholder for Breaker Block strategy
    bool breaker_triggered = false  // TODO: Add actual detection logic

    if breaker_triggered
        entry_signal_active := true
        active_entry_strategy := "Breaker Block"
        // TODO: Set entry_price, entry_tp, entry_sl

// ============================================================================
// ENTRY SIGNAL TIMEOUT - Works for ALL strategies
// ============================================================================
// Invalidate entry signal after N bars if limit order doesn't fill
if entry_signal_active and not trade_entered and not na(entry_signal_bar_index)
    int bars_since_entry_signal = bar_index - entry_signal_bar_index
    if bars_since_entry_signal >= entry_timeout_bars
        // Entry signal timed out - clear ALL strategy-specific state
        if active_entry_strategy == "MSS OB" or active_entry_strategy == "Breaker Block"
            // ENG OB-based strategies
            eng_ob_active := false
            eng_ob_is_bullish := false
            eng_ob_deepest_level := na
            eng_ob_bar_index := na
            eng_ob_candle_high := na
            eng_ob_candle_low := na
            target_fractal_level_mss := na
            if not na(eng_ob_box)
                box.delete(eng_ob_box)
                eng_ob_box := na
        else if active_entry_strategy == "BPR FVG"
            // BPR FVG strategy
            bpr_fvg_active := false
            bpr_fvg_is_bullish := false
            bpr_fvg_top := na
            bpr_fvg_bottom := na
            bpr_fvg_invalidation_level := na
            bpr_fvg_bar_index := na
            bpr_fvg_candle_high := na
            bpr_fvg_candle_low := na
            bpr_fvg_invalidation_reason := "Entry timeout"
            if not na(bpr_fvg_box)
                box.delete(bpr_fvg_box)
                bpr_fvg_box := na
        else if active_entry_strategy == "Inverted FVG"
            // Inverted FVG strategy (clears both BPR FVG and Inverted FVG state)
            bpr_fvg_active := false
            bpr_fvg_is_bullish := false
            bpr_fvg_top := na
            bpr_fvg_bottom := na
            bpr_fvg_invalidation_level := na
            bpr_fvg_bar_index := na
            bpr_fvg_candle_high := na
            bpr_fvg_candle_low := na
            bpr_fvg_invalidation_reason := "Entry timeout"
            if not na(bpr_fvg_box)
                box.delete(bpr_fvg_box)
                bpr_fvg_box := na
            inv_fvg_active := false
            inv_fvg_is_bullish := false
            inv_fvg_overlap_top := na
            inv_fvg_overlap_bottom := na
            inv_fvg_reversal_candle_high := na
            inv_fvg_reversal_candle_low := na
            inv_fvg_bar_index := na
            inv_fvg_invalidation_reason := "Entry timeout"
            if not na(inv_fvg_overlap_box)
                box.delete(inv_fvg_overlap_box)
                inv_fvg_overlap_box := na

        // Clear generic entry signal state (all strategies)
        entry_signal_active := false
        entry_signal_bar_index := na
        active_entry_strategy := ""
        entry_is_bullish := false
        entry_price := na
        entry_tp := na
        entry_sl := na
        order_placed := false

        // Delete TP/SL boxes
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

// ============================================================================
// GENERIC ENTRY EXECUTION - Works for all strategies
// ============================================================================
// When any entry signal becomes active, place the trade ONCE
if entry_signal_active and not trade_entered and not order_placed and not na(entry_price)
    // Calculate position size based on risk
    float risk_per_contract = math.abs(entry_price - entry_sl)
    float position_size = risk_per_trade / risk_per_contract

    // Place limit order at entry level
    if entry_is_bullish
        // Enter long position with limit order at entry level
        strategy.entry("Long", strategy.long, qty=position_size, limit=entry_price)
        strategy.exit("TP/SL Long", "Long", limit=entry_tp, stop=entry_sl)
    else
        // Enter short position with limit order at entry level
        strategy.entry("Short", strategy.short, qty=position_size, limit=entry_price)
        strategy.exit("TP/SL Short", "Short", limit=entry_tp, stop=entry_sl)

    // Mark that order has been placed for this signal
    order_placed := true
    order_placed_bar := bar_index

// ============================================================================
// TRADE EXECUTION - Track when limit order is filled
// ============================================================================
// STEP 3: Create GREEN/RED boxes when trade is entered (generic for all strategies)
if entry_signal_active and not trade_entered
    // Check if we now have an open position (limit order was filled)
    if strategy.position_size != 0
        trade_entered := true

        // Create TP and SL indicator boxes (only when trade is actually entered)
        // This completes the standard visual flow: YELLOW → BLUE → GREEN/RED
        // Delete old boxes first
        if not na(tp_box)
            box.delete(tp_box)
        if not na(sl_box)
            box.delete(sl_box)

        // Create new TP box (green) and SL box (red)
        if entry_is_bullish
            // Bullish: TP is above entry
            tp_box := box.new(bar_index, entry_tp, bar_index + 1, entry_price,
                             border_color=color.green,
                             bgcolor=color.new(color.green, 85),
                             border_width=1,
                             extend=extend.none)
            // SL is below entry
            sl_box := box.new(bar_index, entry_price, bar_index + 1, entry_sl,
                             border_color=color.red,
                             bgcolor=color.new(color.red, 85),
                             border_width=1,
                             extend=extend.none)
        else
            // Bearish: TP is below entry
            tp_box := box.new(bar_index, entry_price, bar_index + 1, entry_tp,
                             border_color=color.green,
                             bgcolor=color.new(color.green, 85),
                             border_width=1,
                             extend=extend.none)
            // SL is above entry
            sl_box := box.new(bar_index, entry_sl, bar_index + 1, entry_price,
                             border_color=color.red,
                             bgcolor=color.new(color.red, 85),
                             border_width=1,
                             extend=extend.none)

// Check if trade has exited (TP or SL hit)
if trade_entered and strategy.position_size == 0
    // FIRST: Cancel all pending orders to prevent re-entry from lingering limit order
    strategy.cancel_all()

    // Record the exit bar to prevent same-bar re-entry
    last_exit_bar := bar_index

    // Trade has exited - clear all setup variables
    eng_ob_active := false
    eng_ob_is_bullish := false
    eng_ob_deepest_level := na
    eng_ob_bar_index := na
    eng_ob_candle_high := na
    eng_ob_candle_low := na
    target_fractal_level_mss := na

    // Clear entry signals (all strategies)
    entry_signal_active := false
    active_entry_strategy := ""
    entry_is_bullish := false
    entry_price := na
    entry_tp := na
    entry_sl := na

    // Reset trade flag and order placement flag
    trade_entered := false
    order_placed := false
    order_placed_bar := -1

    // Persist TP/SL boxes for the day (don't delete, just stop extending)
    // Add them to daily arrays so they stay visible until 20:00
    if not na(tp_box)
        array.push(daily_tp_boxes, tp_box)
        tp_box := na
    if not na(sl_box)
        array.push(daily_sl_boxes, sl_box)
        sl_box := na

    // Delete eng_ob_box since it's just for active setup
    if not na(eng_ob_box)
        box.delete(eng_ob_box)
        eng_ob_box := na

    // Delete bpr_fvg_box since it's just for active setup
    if not na(bpr_fvg_box)
        box.delete(bpr_fvg_box)
        bpr_fvg_box := na

    // Clear BPR FVG state
    bpr_fvg_active := false
    bpr_fvg_is_bullish := false
    bpr_fvg_top := na
    bpr_fvg_bottom := na
    bpr_fvg_invalidation_level := na
    bpr_fvg_bar_index := na
    bpr_fvg_candle_high := na
    bpr_fvg_candle_low := na
    bpr_fvg_invalidation_reason := "Trade exited"

    // Delete inv_fvg_overlap_box since it's just for active setup
    if not na(inv_fvg_overlap_box)
        box.delete(inv_fvg_overlap_box)
        inv_fvg_overlap_box := na

    // Clear Inverted FVG state
    inv_fvg_active := false
    inv_fvg_is_bullish := false
    inv_fvg_overlap_top := na
    inv_fvg_overlap_bottom := na
    inv_fvg_reversal_candle_high := na
    inv_fvg_reversal_candle_low := na
    inv_fvg_bar_index := na
    inv_fvg_invalidation_reason := "Trade exited"

// ============================================================================
// INTRABAR TRADE CLEANUP - REMOVED
// ============================================================================
// Intrabar cleanup has been removed to simplify the strategy logic
// The regular exit handler handles all trade exits (including intrabar fills)
// Unfilled limit orders will be cleaned up at 9 AM reset or when new setups form

// Update TP/SL boxes to extend one bar at a time while trade is entered (only show when in trade)
if trade_entered and not na(tp_box) and not na(sl_box)
    box.set_right(tp_box, bar_index + 1)
    box.set_right(sl_box, bar_index + 1)

// ============================================================================
// DEBUG TABLE - DYNAMIC (expands based on active setup)
// ============================================================================
// Calculate max rows needed (will adjust dynamically)
var int MAX_DEBUG_ROWS = 50
var table debugTable = table.new(position.top_right, 2, MAX_DEBUG_ROWS, border_width=1)

// Initialize row counter for dynamic table
var int row = 0
row := 0

// Common colors - HIGH CONTRAST
color label_bgcolor = color.new(color.black, 0)  // Pure black background for labels (left column)
color value_bgcolor = color.new(color.white, 0)   // Pure white background for values (right column)

// ============================================================================
// BASE TABLE (ALWAYS VISIBLE)
// ============================================================================

// Determine AOI status based on flow rules
string aoi_status = "-"
if trade_entered and strategy.position_size != 0
    aoi_status := "IN TRADE"
    value_bgcolor := entry_is_bullish ? color.new(color.blue, 50) : color.new(color.red, 50)
else if entry_signal_active
    aoi_status := "AWAITING ENTRY"
    value_bgcolor := entry_is_bullish ? color.new(color.blue, 50) : color.new(color.red, 50)
else if eng_ob_active
    aoi_status := "ACTIVE"
    value_bgcolor := eng_ob_is_bullish ? color.new(color.blue, 50) : color.new(color.red, 50)
else if bpr_fvg_active or inv_fvg_active
    aoi_status := "ACTIVE"
    // For BPR FVG, trade direction is INVERTED from FVG direction
    // Bullish FVG = bearish trade (red), Bearish FVG = bullish trade (blue)
    // For Inverted FVG, trade direction matches the variable
    value_bgcolor := (bpr_fvg_active ? not bpr_fvg_is_bullish : inv_fvg_is_bullish) ? color.new(color.blue, 50) : color.new(color.red, 50)
else if supply_triggered or demand_triggered
    aoi_status := "IN AOI"
    value_bgcolor := supply_triggered ? color.new(color.red, 50) : color.new(color.blue, 50)
else
    aoi_status := "-"
    value_bgcolor := color.new(color.gray, 80)

string padded_status = aoi_status == "-" ? "  -   " : aoi_status
table.cell(debugTable, 0, row, "AOI Status", text_color=color.white, bgcolor=label_bgcolor, text_size=size.normal)
table.cell(debugTable, 1, row, padded_status, text_color=color.black, bgcolor=value_bgcolor, text_size=size.normal)
row := row + 1

// Entry Strategy - show which strategy is active (detected or triggered)
string entry_strategy_text = "-"
color entry_strategy_bgcolor = value_bgcolor
if entry_signal_active
    entry_strategy_text := active_entry_strategy
    entry_strategy_bgcolor := entry_is_bullish ? color.new(color.blue, 50) : color.new(color.red, 50)
else if inv_fvg_active
    entry_strategy_text := "Inverted FVG (detected)"
    entry_strategy_bgcolor := color.new(color.purple, 60)
else if bpr_fvg_active
    entry_strategy_text := "BPR FVG (detected)"
    entry_strategy_bgcolor := color.new(color.yellow, 60)
else if eng_ob_active
    entry_strategy_text := "MSS OB (detected)"
    entry_strategy_bgcolor := color.new(color.yellow, 60)
table.cell(debugTable, 0, row, "Entry Strategy", text_color=color.white, bgcolor=label_bgcolor, text_size=size.normal)
table.cell(debugTable, 1, row, entry_strategy_text, text_color=color.black, bgcolor=entry_strategy_bgcolor, text_size=size.normal)
row := row + 1

// Combined: Entry + TP + SL
string entry_tp_sl_text = "-"
if entry_signal_active and not na(entry_price) and not na(entry_tp) and not na(entry_sl)
    entry_tp_sl_text := "Entry: " + str.tostring(entry_price, format.mintick) + " | TP: " + str.tostring(entry_tp, format.mintick) + " | SL: " + str.tostring(entry_sl, format.mintick)
table.cell(debugTable, 0, row, "Entry/TP/SL", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, row, entry_tp_sl_text, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)
row := row + 1

// Position Size
string pos_size = str.tostring(strategy.position_size)
table.cell(debugTable, 0, row, "Position Size", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, row, pos_size, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)
row := row + 1

// Cooldown status
string cooldown_text = in_cooldown ? "✗ YES (blocked)" : "✓ NO"
if last_exit_bar >= 0
    int bars_since_exit = bar_index - last_exit_bar
    cooldown_text := cooldown_text + " (" + str.tostring(bars_since_exit) + " bars)"
color cooldown_bg = in_cooldown ? color.new(color.red, 0) : color.new(color.green, 0)
table.cell(debugTable, 0, row, "Cooldown", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, row, cooldown_text, text_color=color.white, bgcolor=cooldown_bg, text_size=size.small)
row := row + 1

// S&D Zone Levels
string supply_zone = "-"
if clear_supply
    supply_zone := "DISABLED"
else if supply_configured
    supply_zone := str.tostring(supply_bottom, format.mintick) + " - " + str.tostring(supply_top, format.mintick)
table.cell(debugTable, 0, row, "Supply Zone", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, row, supply_zone, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)
row := row + 1

string demand_zone = "-"
color demand_zone_bgcolor = value_bgcolor
if clear_demand
    demand_zone := "DISABLED"
else if demand_configured
    demand_zone := str.tostring(demand_bottom, format.mintick) + " - " + str.tostring(demand_top, format.mintick)
    demand_zone_bgcolor := color.new(color.blue, 0)
table.cell(debugTable, 0, row, "Demand Zone", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, row, demand_zone, text_color=color.white, bgcolor=demand_zone_bgcolor, text_size=size.small)
row := row + 1

// S&D Deepest
string supply_deepest = "-"
if not na(supply_deepest_ever)
    supply_deepest := str.tostring(supply_deepest_ever, format.mintick)
table.cell(debugTable, 0, row, "Supply Deepest", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, row, supply_deepest, text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
row := row + 1

string demand_deepest = "-"
if not na(demand_deepest_ever)
    demand_deepest := str.tostring(demand_deepest_ever, format.mintick)
table.cell(debugTable, 0, row, "Demand Deepest", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, row, demand_deepest, text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
row := row + 1

// Session Levels - REMOVED (commented out to simplify debug table)
// string asian_high_text = "-"
// color asian_high_bg = label_bgcolor
// if not na(asian_high)
//     if asian_high_crossed
//         asian_high_text := "✗ CROSSED"
//         asian_high_bg := color.new(color.gray, 50)
//     else
//         asian_high_text := str.tostring(asian_high, format.mintick)
//         asian_high_bg := color.new(color.red, 70)
// table.cell(debugTable, 0, row, "Asian High", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
// table.cell(debugTable, 1, row, asian_high_text, text_color=color.black, bgcolor=asian_high_bg, text_size=size.small)
// row := row + 1

// string asian_low_text = "-"
// color asian_low_bg = label_bgcolor
// if not na(asian_low)
//     if asian_low_crossed
//         asian_low_text := "✗ CROSSED"
//         asian_low_bg := color.new(color.gray, 50)
//     else
//         asian_low_text := str.tostring(asian_low, format.mintick)
//         asian_low_bg := color.new(color.green, 70)
// table.cell(debugTable, 0, row, "Asian Low", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
// table.cell(debugTable, 1, row, asian_low_text, text_color=color.black, bgcolor=asian_low_bg, text_size=size.small)
// row := row + 1

// string london_high_text = "-"
// color london_high_bg = label_bgcolor
// if not na(london_high)
//     if london_high_crossed
//         london_high_text := "✗ CROSSED"
//         london_high_bg := color.new(color.gray, 50)
//     else
//         london_high_text := str.tostring(london_high, format.mintick)
//         london_high_bg := color.new(color.red, 70)
// table.cell(debugTable, 0, row, "London High", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
// table.cell(debugTable, 1, row, london_high_text, text_color=color.black, bgcolor=london_high_bg, text_size=size.small)
// row := row + 1

// string london_low_text = "-"
// color london_low_bg = label_bgcolor
// if not na(london_low)
//     if london_low_crossed
//         london_low_text := "✗ CROSSED"
//         london_low_bg := color.new(color.gray, 50)
//     else
//         london_low_text := str.tostring(london_low, format.mintick)
//         london_low_bg := color.new(color.green, 70)
// table.cell(debugTable, 0, row, "London Low", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
// table.cell(debugTable, 1, row, london_low_text, text_color=color.black, bgcolor=london_low_bg, text_size=size.small)
// row := row + 1

// string prev_high_text = "-"
// color prev_high_bg = label_bgcolor
// if not na(prev_day_high)
//     if prev_day_high_crossed
//         prev_high_text := "✗ CROSSED"
//         prev_high_bg := color.new(color.gray, 50)
//     else
//         prev_high_text := str.tostring(prev_day_high, format.mintick)
//         prev_high_bg := color.new(color.red, 70)
// table.cell(debugTable, 0, row, "Prev Day High", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
// table.cell(debugTable, 1, row, prev_high_text, text_color=color.black, bgcolor=prev_high_bg, text_size=size.small)
// row := row + 1

// string prev_low_text = "-"
// color prev_low_bg = label_bgcolor
// if not na(prev_day_low)
//     if prev_day_low_crossed
//         prev_low_text := "✗ CROSSED"
//         prev_low_bg := color.new(color.gray, 50)
//     else
//         prev_low_text := str.tostring(prev_day_low, format.mintick)
//         prev_low_bg := color.new(color.green, 70)
// table.cell(debugTable, 0, row, "Prev Day Low", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
// table.cell(debugTable, 1, row, prev_low_text, text_color=color.black, bgcolor=prev_low_bg, text_size=size.small)
// row := row + 1

// ============================================================================
// MSS OB SPECIFIC (only when eng_ob_active)
// ============================================================================
if eng_ob_active
    // Divider
    color eng_divider_color = color.new(color.orange, 0)
    table.cell(debugTable, 0, row, "MSS OB DEBUG", text_color=color.black, bgcolor=eng_divider_color, text_size=size.small)
    table.cell(debugTable, 1, row, "", text_color=color.black, bgcolor=eng_divider_color, text_size=size.small)
    row := row + 1

    // Engulfing OB Status
    string eng_status = "✓"
    color eng_bgcolor = value_bgcolor
    table.cell(debugTable, 0, row, "Engulfing OB", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, eng_status, text_color=color.black, bgcolor=eng_bgcolor, text_size=size.small)
    row := row + 1

    // MSS Fractal Level
    string fractal_level = "-"
    if use_mss_ob
        if not na(target_fractal_level_mss)
            fractal_level := str.tostring(target_fractal_level_mss, format.mintick) + (eng_ob_is_bullish ? " (↑)" : " (↓)")
        else
            fractal_level := "SEARCHING"
    table.cell(debugTable, 0, row, "MSS Fractal", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, fractal_level, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)
    row := row + 1

// ============================================================================
// BPR FVG / INVERTED FVG DEBUG (combined - only when either is active)
// ============================================================================
if bpr_fvg_active or inv_fvg_active
    // Divider
    color fvg_divider_color = bpr_fvg_active ? color.new(color.yellow, 0) : color.new(color.purple, 0)
    string fvg_title = bpr_fvg_active ? "BPR FVG DEBUG" : "INVERTED FVG DEBUG"
    table.cell(debugTable, 0, row, fvg_title, text_color=color.black, bgcolor=fvg_divider_color, text_size=size.small)
    table.cell(debugTable, 1, row, "", text_color=color.black, bgcolor=fvg_divider_color, text_size=size.small)
    row := row + 1

    // Determine if entry is active for this FVG type
    bool fvg_entry_active = entry_signal_active and (active_entry_strategy == "BPR FVG" or active_entry_strategy == "Inverted FVG")

    // Determine trade direction to use correct colors - HIGH CONTRAST
    // For BPR FVG: trade direction is INVERTED from FVG direction
    // For Inverted FVG: trade direction matches the variable
    bool fvg_trade_is_bullish = bpr_fvg_active ? not bpr_fvg_is_bullish : inv_fvg_is_bullish
    color valid_color = fvg_trade_is_bullish ? color.new(color.green, 0) : color.new(color.red, 0)
    color invalid_color = fvg_trade_is_bullish ? color.new(color.red, 0) : color.new(color.green, 0)
    color neutral_color = color.new(color.gray, 30)

    // 0. RAW BOOLEAN DEBUG - Shows the actual variable states
    string fvg_bar_index_str = na(bpr_fvg_bar_index) ? "na" : str.tostring(bpr_fvg_bar_index)
    string bool_debug = "bpr_fvg_active=" + str.tostring(bpr_fvg_active) + " | entry_signal_active=" + str.tostring(entry_signal_active) + " | trade_entered=" + str.tostring(trade_entered) + " | order_placed=" + str.tostring(order_placed) + " | bpr_fvg_bar_index=" + fvg_bar_index_str + " | bar_index=" + str.tostring(bar_index)
    table.cell(debugTable, 0, row, "0. BOOL DEBUG", text_color=color.white, bgcolor=color.new(color.red, 20), text_size=size.small)
    table.cell(debugTable, 1, row, bool_debug, text_color=color.white, bgcolor=color.new(color.red, 30), text_size=size.small)
    row := row + 1

    // 0b. SETUP TIMEOUT COUNTER - Shows bars since FVG detection and timeout progress
    string setup_timeout_debug = "-"
    color setup_timeout_bg = color.new(color.orange, 30)
    if bpr_fvg_active and not na(bpr_fvg_bar_index)
        int bars_since_detection = bar_index - bpr_fvg_bar_index
        setup_timeout_debug := "Setup: " + str.tostring(bars_since_detection) + " / " + str.tostring(setup_timeout_bars) + " bars"
        // Color code: green if far from timeout, yellow if getting close, red if very close
        if bars_since_detection >= setup_timeout_bars * 0.8
            setup_timeout_bg := color.new(color.red, 30)
        else if bars_since_detection >= setup_timeout_bars * 0.6
            setup_timeout_bg := color.new(color.yellow, 30)
        else
            setup_timeout_bg := color.new(color.green, 30)
    else if inv_fvg_active and not na(inv_fvg_bar_index)
        int bars_since_detection = bar_index - inv_fvg_bar_index
        setup_timeout_debug := "Setup: " + str.tostring(bars_since_detection) + " / " + str.tostring(setup_timeout_bars) + " bars"
        if bars_since_detection >= setup_timeout_bars * 0.8
            setup_timeout_bg := color.new(color.red, 30)
        else if bars_since_detection >= setup_timeout_bars * 0.6
            setup_timeout_bg := color.new(color.yellow, 30)
        else
            setup_timeout_bg := color.new(color.green, 30)
    table.cell(debugTable, 0, row, "0b. SETUP TIMEOUT", text_color=color.white, bgcolor=color.new(color.orange, 20), text_size=size.small)
    table.cell(debugTable, 1, row, setup_timeout_debug, text_color=color.white, bgcolor=setup_timeout_bg, text_size=size.small)
    row := row + 1

    // 0c. ENTRY TIMEOUT COUNTER - Shows bars since entry signal and timeout progress
    string entry_timeout_debug = "-"
    color entry_timeout_bg = color.new(color.purple, 30)
    if entry_signal_active and not na(entry_signal_bar_index)
        int bars_since_entry = bar_index - entry_signal_bar_index
        entry_timeout_debug := "Entry: " + str.tostring(bars_since_entry) + " / " + str.tostring(entry_timeout_bars) + " bars"
        // Color code: green if far from timeout, yellow if getting close, red if very close
        if bars_since_entry >= entry_timeout_bars * 0.8
            entry_timeout_bg := color.new(color.red, 30)
        else if bars_since_entry >= entry_timeout_bars * 0.6
            entry_timeout_bg := color.new(color.yellow, 30)
        else
            entry_timeout_bg := color.new(color.green, 30)
    table.cell(debugTable, 0, row, "0c. ENTRY TIMEOUT", text_color=color.white, bgcolor=color.new(color.purple, 20), text_size=size.small)
    table.cell(debugTable, 1, row, entry_timeout_debug, text_color=color.white, bgcolor=entry_timeout_bg, text_size=size.small)
    row := row + 1

    // 1. FVG/Overlap Active
    string fvg_type_text = bpr_fvg_active ? "BPR FVG" : "Inverted FVG"
    table.cell(debugTable, 0, row, "1. Type", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, fvg_type_text, text_color=color.white, bgcolor=valid_color, text_size=size.small)
    row := row + 1

    // 2. Size in ticks
    string fvg_size_text = "-"
    bool size_valid = false
    if bpr_fvg_active and not na(bpr_fvg_top) and not na(bpr_fvg_bottom)
        float fvg_size = bpr_fvg_top - bpr_fvg_bottom
        float fvg_ticks = fvg_size / syminfo.mintick
        fvg_size_text := str.tostring(fvg_ticks, "#.#") + " ticks"
        size_valid := fvg_ticks >= bpr_fvg_min_ticks
    else if inv_fvg_active and not na(inv_fvg_overlap_top) and not na(inv_fvg_overlap_bottom)
        float overlap_size = inv_fvg_overlap_top - inv_fvg_overlap_bottom
        float overlap_ticks = overlap_size / syminfo.mintick
        fvg_size_text := str.tostring(overlap_ticks, "#.#") + " ticks"
        size_valid := true  // Inverted FVG always valid once formed
    table.cell(debugTable, 0, row, "2. Size", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, fvg_size_text, text_color=color.white, bgcolor=size_valid ? valid_color : neutral_color, text_size=size.small)
    row := row + 1

    // 3. FVG/Overlap Levels
    string fvg_levels = "-"
    bool levels_valid = false
    if bpr_fvg_active and not na(bpr_fvg_top) and not na(bpr_fvg_bottom)
        fvg_levels := str.tostring(bpr_fvg_bottom, format.mintick) + " - " + str.tostring(bpr_fvg_top, format.mintick)
        levels_valid := true
    else if inv_fvg_active and not na(inv_fvg_overlap_top) and not na(inv_fvg_overlap_bottom)
        fvg_levels := str.tostring(inv_fvg_overlap_bottom, format.mintick) + " - " + str.tostring(inv_fvg_overlap_top, format.mintick)
        levels_valid := true
    table.cell(debugTable, 0, row, "3. Levels", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, fvg_levels, text_color=color.white, bgcolor=levels_valid ? valid_color : neutral_color, text_size=size.small)
    row := row + 1

    // 4. Breach Status
    string breach_text = "-"
    bool is_breached = false
    if bpr_fvg_active
        bool bpr_close_through = bpr_fvg_is_bullish ? (close < bpr_fvg_bottom) : (close > bpr_fvg_top)
        is_breached := bpr_close_through or fvg_entry_active
        breach_text := is_breached ? "Breached" : "Awaiting"
    else if inv_fvg_active
        // Inverted FVG breaches when price enters overlap zone
        bool inv_breach = inv_fvg_is_bullish ? (close >= inv_fvg_overlap_bottom and close <= inv_fvg_overlap_top) : (close >= inv_fvg_overlap_bottom and close <= inv_fvg_overlap_top)
        is_breached := inv_breach or fvg_entry_active
        breach_text := is_breached ? "In Zone" : "Awaiting"
    table.cell(debugTable, 0, row, "4. Breach", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, breach_text, text_color=color.black, bgcolor=is_breached ? valid_color : color.new(color.yellow, 0), text_size=size.small)
    row := row + 1

    // 5. Invalidation Level
    string inval_level = "-"
    bool inval_valid = false
    if bpr_fvg_active and not na(bpr_fvg_invalidation_level)
        inval_level := str.tostring(bpr_fvg_invalidation_level, format.mintick)
        inval_valid := true
    else if inv_fvg_active
        // Inverted FVG invalidation: reversal candle high/low
        if inv_fvg_is_bullish and not na(inv_fvg_reversal_candle_low)
            inval_level := str.tostring(inv_fvg_reversal_candle_low, format.mintick) + " (low)"
            inval_valid := true
        else if not inv_fvg_is_bullish and not na(inv_fvg_reversal_candle_high)
            inval_level := str.tostring(inv_fvg_reversal_candle_high, format.mintick) + " (high)"
            inval_valid := true
    table.cell(debugTable, 0, row, "5. Inval Level", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, inval_level, text_color=color.white, bgcolor=inval_valid ? valid_color : neutral_color, text_size=size.small)
    row := row + 1

    // 6. Last Clear Reason
    string clear_reason = "-"
    color clear_bg = neutral_color
    if bpr_fvg_active
        clear_reason := bpr_fvg_invalidation_reason == "" ? "-" : bpr_fvg_invalidation_reason
        clear_bg := bpr_fvg_invalidation_reason == "" ? neutral_color : color.new(color.yellow, 0)
    else if inv_fvg_active
        clear_reason := inv_fvg_invalidation_reason == "" ? "-" : inv_fvg_invalidation_reason
        clear_bg := inv_fvg_invalidation_reason == "" ? neutral_color : color.new(color.yellow, 0)
    table.cell(debugTable, 0, row, "6. Last Clear", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, clear_reason, text_color=color.black, bgcolor=clear_bg, text_size=size.small)
    row := row + 1

    // 7. Close Price Check
    string close_check_text = "-"
    bool close_check_valid = false
    if bpr_fvg_active
        string comparison = ""
        bool would_breach = false
        if bpr_fvg_is_bullish
            would_breach := close < bpr_fvg_bottom
            comparison := str.tostring(close, format.mintick) + " < " + str.tostring(bpr_fvg_bottom, format.mintick)
        else
            would_breach := close > bpr_fvg_top
            comparison := str.tostring(close, format.mintick) + " > " + str.tostring(bpr_fvg_top, format.mintick)
        close_check_text := (would_breach ? "✓ " : "✗ ") + comparison
        close_check_valid := would_breach
    else if inv_fvg_active
        bool in_overlap = close >= inv_fvg_overlap_bottom and close <= inv_fvg_overlap_top
        close_check_text := (in_overlap ? "✓ " : "✗ ") + "In Overlap"
        close_check_valid := in_overlap
    table.cell(debugTable, 0, row, "7. Close Check", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, close_check_text, text_color=color.white, bgcolor=close_check_valid ? valid_color : invalid_color, text_size=size.small)
    row := row + 1

    // 8. Zone Trigger Check
    string zone_trig_text = "-"
    bool zone_check_valid = false
    if bpr_fvg_active
        if bpr_fvg_is_bullish
            zone_trig_text := supply_triggered ? "✓ Supply" : "✗ Supply"
            zone_check_valid := supply_triggered
        else
            zone_trig_text := demand_triggered ? "✓ Demand" : "✗ Demand"
            zone_check_valid := demand_triggered
    else if inv_fvg_active
        if inv_fvg_is_bullish
            zone_trig_text := demand_triggered ? "✓ Demand" : "✗ Demand"
            zone_check_valid := demand_triggered
        else
            zone_trig_text := supply_triggered ? "✓ Supply" : "✗ Supply"
            zone_check_valid := supply_triggered
    table.cell(debugTable, 0, row, "8. Zone Trig", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, zone_trig_text, text_color=color.white, bgcolor=zone_check_valid ? valid_color : invalid_color, text_size=size.small)
    row := row + 1

    // 9. Trading Window Check
    string window_text = in_trading_window ? "✓ YES" : "✗ NO"
    table.cell(debugTable, 0, row, "9. Trade Window", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, window_text, text_color=color.white, bgcolor=in_trading_window ? valid_color : invalid_color, text_size=size.small)
    row := row + 1

    // 10. Strategy Enabled Check
    string enabled_text = "-"
    bool strategy_enabled = false
    if bpr_fvg_active
        enabled_text := use_bpr_fvg ? "✓ Enabled" : "✗ Disabled"
        strategy_enabled := use_bpr_fvg
    else if inv_fvg_active
        enabled_text := use_inverted_fvg ? "✓ Enabled" : "✗ Disabled"
        strategy_enabled := use_inverted_fvg
    table.cell(debugTable, 0, row, "10. Strategy", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, enabled_text, text_color=color.white, bgcolor=strategy_enabled ? valid_color : invalid_color, text_size=size.small)
    row := row + 1

// ============================================================================
// DAILY STATS TABLE (HIDDEN FOR DEBUGGING)
// ============================================================================
// var table statsTable = table.new(position.bottom_right, 2, 5, border_width=1)
//
// color stats_label_bg = color.new(color.black, 20)
// color stats_value_bg = color.new(color.gray, 30)
//
// // Title row
// table.cell(statsTable, 0, 0, "TODAY'S STATS", text_color=color.white, bgcolor=color.new(color.blue, 30), text_size=size.normal)
// table.cell(statsTable, 1, 0, "", text_color=color.white, bgcolor=color.new(color.blue, 30), text_size=size.normal)
//
// // Trades count
// string trades_text = str.tostring(today_trade_count)
// table.cell(statsTable, 0, 1, "Trades", text_color=color.white, bgcolor=stats_label_bg, text_size=size.normal)
// table.cell(statsTable, 1, 1, trades_text, text_color=color.white, bgcolor=stats_value_bg, text_size=size.normal)
//
// // Wins
// string wins_text = str.tostring(today_wins)
// table.cell(statsTable, 0, 2, "Wins", text_color=color.white, bgcolor=stats_label_bg, text_size=size.normal)
// table.cell(statsTable, 1, 2, wins_text, text_color=color.white, bgcolor=color.new(color.green, 50), text_size=size.normal)
//
// // Losses
// string losses_text = str.tostring(today_losses)
// table.cell(statsTable, 0, 3, "Losses", text_color=color.white, bgcolor=stats_label_bg, text_size=size.normal)
// table.cell(statsTable, 1, 3, losses_text, text_color=color.white, bgcolor=color.new(color.red, 50), text_size=size.normal)
//
// // P&L
// string pnl_text = (today_pnl >= 0 ? "+" : "") + str.tostring(today_pnl, "#.##")
// color pnl_bg = today_pnl > 0 ? color.new(color.green, 30) : (today_pnl < 0 ? color.new(color.red, 30) : stats_value_bg)
// table.cell(statsTable, 0, 4, "P&L", text_color=color.white, bgcolor=stats_label_bg, text_size=size.normal)
// table.cell(statsTable, 1, 4, pnl_text, text_color=color.white, bgcolor=pnl_bg, text_size=size.normal)
