//@version=5
strategy("Nexus Strategy Manual", overlay=true, initial_capital=10000, default_qty_type=strategy.fixed, default_qty_value=1)

// ============================================================================
// INPUTS - MANUAL ZONES
// ============================================================================
supply_top = input.float(0.0, "Supply Zone Top", group="Manual Zones")
supply_bottom = input.float(0.0, "Supply Zone Bottom", group="Manual Zones")
clear_supply = input.bool(false, "Disable Supply Zone", group="Manual Zones", tooltip="Check to temporarily disable supply zone without clearing values")

demand_top = input.float(0.0, "Demand Zone Top", group="Manual Zones")
demand_bottom = input.float(0.0, "Demand Zone Bottom", group="Manual Zones")
clear_demand = input.bool(false, "Disable Demand Zone", group="Manual Zones", tooltip="Check to temporarily disable demand zone without clearing values")

show_zones = input.bool(true, "Show Zones", group="Manual Zones", tooltip="Show/hide zone boxes on chart")

// ============================================================================
// INPUTS - TRADING WINDOW
// ============================================================================
trading_start_hour = input.int(9, "Trading Start Hour", minval=0, maxval=23, group="Trading Window", tooltip="Hour to start trading (NY time)")
trading_start_minute = input.int(30, "Trading Start Minute", minval=0, maxval=59, group="Trading Window", tooltip="Minute to start trading (NY time)")
trading_end_hour = input.int(16, "Trading End Hour", minval=0, maxval=23, group="Trading Window", tooltip="Hour to end trading (NY time)")
trading_end_minute = input.int(45, "Trading End Minute", minval=0, maxval=59, group="Trading Window", tooltip="Minute to end trading (NY time)")

// ============================================================================
// INPUTS - TRADE SETTINGS
// ============================================================================
risk_per_trade = input.float(500.0, "Risk Per Trade ($)", minval=1.0, group="Trade Settings", tooltip="Dollar amount to risk per trade")
max_setup_bars = input.int(100, "Max Setup Age (bars)", minval=1, group="Trade Settings", tooltip="Maximum number of bars before setup is invalidated")

// ============================================================================
// ZONE DETECTION
// ============================================================================
// Apply clear flags - if clear is checked, treat zone as not configured
bool supply_configured = not clear_supply and supply_top > 0 and supply_bottom > 0 and supply_top > supply_bottom
bool demand_configured = not clear_demand and demand_top > 0 and demand_bottom > 0 and demand_top > demand_bottom

// Check if candle touches zone (high/low overlap with zone range)
// Uses real-time high/low so it triggers immediately when zone is touched
bool in_supply = supply_configured and not (low > supply_top or high < supply_bottom)
bool in_demand = demand_configured and not (low > demand_top or high < demand_bottom)

// ============================================================================
// TRADING WINDOW CHECK
// ============================================================================
// Convert current time to minutes since midnight for easier comparison
int current_time_minutes = hour(time, "America/New_York") * 60 + minute(time, "America/New_York")
int trading_start_minutes = trading_start_hour * 60 + trading_start_minute
int trading_end_minutes = trading_end_hour * 60 + trading_end_minute

// Check if we're within trading window
bool in_trading_window = current_time_minutes >= trading_start_minutes and current_time_minutes <= trading_end_minutes


// ============================================================================
// SESSION HIGH/LOW TRACKING
// ============================================================================
// Session times (America/New_York):
// - Asian: 20:00 - 00:00 (previous day 8pm to midnight)
// - London: 03:00 - 12:00
// - Previous Day: 00:00 - 00:00 (full previous trading day)

// Track session highs and lows
var float asian_high = na
var float asian_low = na
var float london_high = na
var float london_low = na
var float prev_day_high = na
var float prev_day_low = na

// Track if sessions have been crossed (invalidated)
var bool asian_high_crossed = false
var bool asian_low_crossed = false
var bool london_high_crossed = false
var bool london_low_crossed = false
var bool prev_day_high_crossed = false
var bool prev_day_low_crossed = false

// Track lines for visual display
var line asian_high_line = na
var line asian_low_line = na
var line london_high_line = na
var line london_low_line = na
var line prev_day_high_line = na
var line prev_day_low_line = na

// Get current time
int hour_et = hour(time, "America/New_York")
int day_of_month = dayofmonth(time, "America/New_York")

// Track session high/low during their respective periods
// Asian session: 20:00 - 00:00 (8pm to midnight)
bool in_asian_session = hour_et >= 20 or hour_et < 0
if in_asian_session
    if na(asian_high) or high > asian_high
        asian_high := high
    if na(asian_low) or low < asian_low
        asian_low := low

        // do NOT reset asian hi/lo at NY midnight. instead of resetting at midnight, reset at next asian session
else if hour_et == 0 and minute(time, "America/New_York") == 0
    // Reset at midnight (start of new day)
    asian_high := na
    asian_low := na
    asian_high_crossed := false
    asian_low_crossed := false

// London session: 03:00 - 12:00
bool in_london_session = hour_et >= 3 and hour_et < 12
if in_london_session
    if na(london_high) or high > london_high
        london_high := high
    if na(london_low) or low < london_low
        london_low := low
else if hour_et == 3 and minute(time, "America/New_York") == 0
    // Reset at London open
    london_high := na
    london_low := na
    london_high_crossed := false
    london_low_crossed := false

// Previous Day high/low: track full previous day, reset at midnight
var float temp_day_high = na
var float temp_day_low = na
var int last_tracked_day = na

if barstate.isnew
    int current_day = dayofmonth(time, "America/New_York")

    // At start of new day (midnight ET), save yesterday's high/low as prev_day
    if not na(last_tracked_day) and current_day != last_tracked_day
        prev_day_high := temp_day_high
        prev_day_low := temp_day_low
        prev_day_high_crossed := false
        prev_day_low_crossed := false

        // Reset temp tracking for new day
        temp_day_high := high
        temp_day_low := low
    else
        // Continue tracking current day's high/low
        if na(temp_day_high) or high > temp_day_high
            temp_day_high := high
        if na(temp_day_low) or low < temp_day_low
            temp_day_low := low

    last_tracked_day := current_day

// Check for crosses and invalidate levels
if not asian_high_crossed and not na(asian_high) and high >= asian_high
    asian_high_crossed := true
if not asian_low_crossed and not na(asian_low) and low <= asian_low
    asian_low_crossed := true

if not london_high_crossed and not na(london_high) and high >= london_high
    london_high_crossed := true
if not london_low_crossed and not na(london_low) and low <= london_low
    london_low_crossed := true

if not prev_day_high_crossed and not na(prev_day_high) and high >= prev_day_high
    prev_day_high_crossed := true
if not prev_day_low_crossed and not na(prev_day_low) and low <= prev_day_low
    prev_day_low_crossed := true

// Session level lines removed - keep it simple

// ============================================================================
// ZONE VISUALIZATION - Draw zones from 09:00 to 16:00 current day
// ============================================================================
// Get current time info
int current_hour = hour(time, "America/New_York")
int current_minute = minute(time, "America/New_York")
bool is_new_day = ta.change(dayofmonth(time, "America/New_York")) != 0

// Track zone boxes
var box supply_zone_box = na
var box demand_zone_box = na
var int zone_start_bar = na

// At 09:00, create new zone boxes for the day
if current_hour == 9 and current_minute == 0 and is_new_day
    zone_start_bar := bar_index

    // Delete old boxes
    if not na(supply_zone_box)
        box.delete(supply_zone_box)
    if not na(demand_zone_box)
        box.delete(demand_zone_box)

    // Create supply zone box (only if show_zones is enabled)
    if show_zones and supply_configured
        supply_zone_box := box.new(bar_index, supply_top, bar_index + 1, supply_bottom,
                                   border_color=color.red,
                                   bgcolor=color.new(color.red, 90),
                                   border_width=1,
                                   extend=extend.none)

    // Create demand zone box (only if show_zones is enabled)
    if show_zones and demand_configured
        demand_zone_box := box.new(bar_index, demand_top, bar_index + 1, demand_bottom,
                                   border_color=color.blue,
                                   bgcolor=color.new(color.blue, 90),
                                   border_width=1,
                                   extend=extend.none)

// Update zone boxes to extend to current bar (between 09:00 and 16:00)
if show_zones and current_hour >= 9 and current_hour < 16
    if supply_configured and not na(supply_zone_box)
        box.set_right(supply_zone_box, bar_index + 1)
    if demand_configured and not na(demand_zone_box)
        box.set_right(demand_zone_box, bar_index + 1)
else if show_zones and current_hour == 16 and current_minute == 0
    // Stop extending at 16:00
    if supply_configured and not na(supply_zone_box)
        box.set_right(supply_zone_box, bar_index)
    if demand_configured and not na(demand_zone_box)
        box.set_right(demand_zone_box, bar_index)

// If show_zones is disabled, delete any existing boxes
if not show_zones
    if not na(supply_zone_box)
        box.delete(supply_zone_box)
        supply_zone_box := na
    if not na(demand_zone_box)
        box.delete(demand_zone_box)
        demand_zone_box := na

// Track zone entry - once triggered, stays true for the entire bar + 1 more bar
var bool supply_triggered = false
var bool demand_triggered = false
var int supply_trigger_bar = -1
var int demand_trigger_bar = -1

// Track deepest penetration into zones (resets on fresh entry)
var float demand_lowest_low = na
var float supply_highest_high = na

// Track if we're completely outside both zones (ready to reset)
var bool was_outside_zones = true

// Track if ENG OB is active (declare early so it can be used in zone logic)
var bool eng_ob_active = false
var bool eng_ob_is_bullish = false
var float eng_ob_deepest_level = na
var float target_fractal_level = na
var int eng_ob_bar_index = na
var float eng_ob_candle_high = na
var float eng_ob_candle_low = na
var box eng_ob_box = na  // Yellow box around ENG OB candle for visual debug

// Track MSS OB (formed when price crosses fractal level)
var bool mss_ob_active = false
var float mss_ob_entry = na  // Entry price (high of OB candle for bullish, low for bearish)
var float mss_ob_tp = na     // Take profit level
var float mss_ob_sl = na     // Stop loss level

// Track TP/SL indicator boxes
var box tp_box = na
var box sl_box = na

// Track if we've already entered a trade for this setup
var bool trade_entered = false

// ============================================================================
// FORCE CLOSE AT TRADING WINDOW END - TOP LEVEL (runs every bar)
// ============================================================================
int check_hour = hour(time, "America/New_York")
int check_minute = minute(time, "America/New_York")
int check_time_mins = check_hour * 60 + check_minute
int end_time_mins = trading_end_hour * 60 + trading_end_minute

// Check if we're past trading end time and have an open position
if check_time_mins >= end_time_mins and strategy.position_size != 0
    // FIRST cancel all pending orders (including TP/SL exits)
    strategy.cancel_all()

    // THEN close the position
    if strategy.position_size > 0
        strategy.close("Long", comment="EOD Close")
    else if strategy.position_size < 0
        strategy.close("Short", comment="EOD Close")

// Check if currently outside both zones
bool outside_both_zones = not in_supply and not in_demand

if barstate.isnew
    // Clear trigger only if it's been more than 1 bar since entry
    if bar_index - supply_trigger_bar > 1
        supply_triggered := false
    if bar_index - demand_trigger_bar > 1
        demand_triggered := false

    // Track when we're outside both zones
    // Only set was_outside_zones if there's NO active ENG OB setup
    if outside_both_zones and not eng_ob_active
        was_outside_zones := true

if in_supply
    supply_triggered := true
    supply_trigger_bar := bar_index

    // Reset deepest on fresh entry after being outside
    if was_outside_zones
        supply_highest_high := high
        was_outside_zones := false
    // Otherwise, track highest high in supply zone
    else if na(supply_highest_high) or high > supply_highest_high
        supply_highest_high := high

if in_demand
    demand_triggered := true
    demand_trigger_bar := bar_index

    // Reset deepest on fresh entry after being outside
    if was_outside_zones
        demand_lowest_low := low
        was_outside_zones := false
    // Otherwise, track lowest low in demand zone
    else if na(demand_lowest_low) or low < demand_lowest_low
        demand_lowest_low := low

// ============================================================================
// SETUP FLOW AND INVALIDATION RULES
// ============================================================================
// FLOW:
// 1. When AOI is entered, show "IN AOI"
// 2. If price leaves AOI without an ENG OB, return to "-"
// 3. If ENG OB forms, black diamond appears, ENG OB shows checkmark
//    - AOI status changes to "ACTIVE" (setup is now active)
//    - ENG OB stays checked until invalidated
// 4. Look BACKWARD for first opposite LTF fractal candle, place debug diamond above it
// 5. If price crosses fractal high (bullish) or low (bearish), MSS OB is formed
//    - Checkmark MSS OB row
//    - Draw entry OB from lowest candle in ENG OB setup (use that candle's high and low)
//    - Add debug row showing entry window
//    - Status changes to "AWAITING MSS OB ENTRY"
//
// INVALIDATION RULES:
// - ENG OB invalidated: if price goes deeper into zone than ENG OB candle before crossing fractal level (step 5)
// - MSS OB invalidated: if price touches opposite color zone (may add more criteria later)
//
// ============================================================================
// ENGULFING ORDER BLOCK DETECTION
// ============================================================================
bool is_bullish_engulfing = false
bool is_bearish_engulfing = false

// Only check for engulfing when in an AOI AND within trading window
if demand_triggered and bar_index > 0 and in_trading_window
    // Bullish engulfing: current candle close engulfs previous candle body
    bool current_bullish = close > open
    bool prev_bearish = close[1] < open[1]
    bool engulfs_body = close >= open[1]

    // Check if current or previous candle made the deepest low
    bool is_deepest = low <= demand_lowest_low or low[1] <= demand_lowest_low

    is_bullish_engulfing := current_bullish and prev_bearish and engulfs_body and is_deepest

if supply_triggered and bar_index > 0 and in_trading_window
    // Bearish engulfing: current candle close engulfs previous candle body
    bool current_bearish = close < open
    bool prev_bullish = close[1] > open[1]
    bool engulfs_body = close <= open[1]

    // Check if current or previous candle made the highest high
    bool is_deepest = high >= supply_highest_high or high[1] >= supply_highest_high

    is_bearish_engulfing := current_bearish and prev_bullish and engulfs_body and is_deepest

bool engulfing_ob_detected = is_bullish_engulfing or is_bearish_engulfing

// NOTE: Trading window only prevents NEW setups from forming
// Existing setups remain active even outside trading window
// This allows setups to continue tracking but prevents new entries outside hours

// INVALIDATION: Setup expires after max_setup_bars (only if not in trade) or at trading end time
if eng_ob_active and not na(eng_ob_bar_index)
    bool should_invalidate_timeout = false
    string timeout_reason = ""

    // Check if setup has exceeded max bars (ONLY if not in a trade)
    if not trade_entered
        int bars_since_setup = bar_index - eng_ob_bar_index
        if bars_since_setup >= max_setup_bars
            should_invalidate_timeout := true
            timeout_reason := "Max bars (" + str.tostring(max_setup_bars) + ")"

    // Check if it's past trading end time (applies to ALL setups, including active trades)
    int current_hour = hour(time, "America/New_York")
    int current_minute = minute(time, "America/New_York")
    int current_time_mins = current_hour * 60 + current_minute
    int end_time_mins = trading_end_hour * 60 + trading_end_minute

    if current_time_mins >= end_time_mins
        should_invalidate_timeout := true
        string end_time_str = str.tostring(trading_end_hour) + ":" + (trading_end_minute < 10 ? "0" : "") + str.tostring(trading_end_minute)
        timeout_reason := timeout_reason == "" ? end_time_str + " NY time" : timeout_reason + " + " + end_time_str

    if should_invalidate_timeout
        label.new(bar_index, eng_ob_is_bullish ? low : high, "❌ TIMEOUT\n" + timeout_reason,
                 color=color.purple, textcolor=color.white,
                 style=eng_ob_is_bullish ? label.style_label_up : label.style_label_down,
                 size=size.small)

        // Close any open positions and cancel pending orders
        strategy.close_all()
        strategy.cancel_all()

        eng_ob_active := false
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level := na

        // Clear MSS OB
        mss_ob_active := false
        mss_ob_entry := na
        mss_ob_tp := na
        mss_ob_sl := na

        // Reset trade flag
        trade_entered := false

        // Delete yellow box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

        // Delete TP/SL boxes
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

// INVALIDATION: Clear setup when zones are disabled
// Only invalidate if the disabled zone MATCHES the setup's zone
// Bullish setup (from demand) only invalidated by clear_demand
// Bearish setup (from supply) only invalidated by clear_supply
if eng_ob_active
    bool should_invalidate = false

    if eng_ob_is_bullish and clear_demand
        // Bullish setup invalidated by disabling demand zone
        should_invalidate := true
    else if not eng_ob_is_bullish and clear_supply
        // Bearish setup invalidated by disabling supply zone
        should_invalidate := true

    if should_invalidate
        eng_ob_active := false
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level := na

        // Clear MSS OB
        mss_ob_active := false
        mss_ob_entry := na
        mss_ob_tp := na
        mss_ob_sl := na

        // Delete yellow box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

        // Delete TP/SL boxes
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

// INVALIDATION: Clear setup when entering the OPPOSITE zone (fresh zone entry)
// Bullish setup (from demand) invalidated by entering supply zone
// Bearish setup (from supply) invalidated by entering demand zone
if barstate.isnew and was_outside_zones
    if eng_ob_active and eng_ob_is_bullish and in_supply
        // Bullish setup invalidated by entering supply zone
        eng_ob_active := false
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level := na

        // Clear MSS OB
        mss_ob_active := false
        mss_ob_entry := na
        mss_ob_tp := na
        mss_ob_sl := na

        // Delete yellow box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

        // Delete TP/SL boxes
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

    else if eng_ob_active and not eng_ob_is_bullish and in_demand
        // Bearish setup invalidated by entering demand zone
        eng_ob_active := false
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level := na

        // Clear MSS OB
        mss_ob_active := false
        mss_ob_entry := na
        mss_ob_tp := na
        mss_ob_sl := na

        // Delete yellow box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

        // Delete TP/SL boxes
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

// When ENG OB forms, activate it and record deepest level + capture the OB candle
if is_bullish_engulfing
    eng_ob_active := true
    eng_ob_is_bullish := true
    eng_ob_deepest_level := demand_lowest_low
    target_fractal_level := na  // Reset fractal search for new ENG OB

    // Determine which candle is the actual OB candle (the one that made the deepest low)
    // For bullish engulfing, the OB candle is whichever made the lowest low
    if low <= low[1]
        // Current candle made the deepest low - it's the OB candle
        eng_ob_bar_index := bar_index
        eng_ob_candle_high := high
        eng_ob_candle_low := low
    else
        // Previous candle made the deepest low - it's the OB candle
        eng_ob_bar_index := bar_index - 1
        eng_ob_candle_high := high[1]
        eng_ob_candle_low := low[1]

else if is_bearish_engulfing
    eng_ob_active := true
    eng_ob_is_bullish := false
    eng_ob_deepest_level := supply_highest_high
    target_fractal_level := na  // Reset fractal search for new ENG OB

    // Determine which candle is the actual OB candle (the one that made the highest high)
    // For bearish engulfing, the OB candle is whichever made the highest high
    if high >= high[1]
        // Current candle made the highest high - it's the OB candle
        eng_ob_bar_index := bar_index
        eng_ob_candle_high := high
        eng_ob_candle_low := low
    else
        // Previous candle made the highest high - it's the OB candle
        eng_ob_bar_index := bar_index - 1
        eng_ob_candle_high := high[1]
        eng_ob_candle_low := low[1]

// INVALIDATION: Price goes deeper into zone than ENG OB candle (before MSS OB is crossed)
// Only invalidate if price is IN the zone and goes deeper than the OB candle
// TODO: Once MSS OB crossing detection is implemented, add condition to stop invalidation after cross
if eng_ob_active
    if eng_ob_is_bullish and demand_triggered and not na(eng_ob_candle_low)
        // Bullish setup invalidated if price makes new lower low than ENG OB candle's low WHILE IN DEMAND ZONE
        if low < eng_ob_candle_low
            eng_ob_active := false
            eng_ob_is_bullish := false
            eng_ob_deepest_level := na
            eng_ob_bar_index := na
            eng_ob_candle_high := na
            eng_ob_candle_low := na
            target_fractal_level := na

            // Clear MSS OB
            mss_ob_active := false
            mss_ob_entry := na
            mss_ob_tp := na
            mss_ob_sl := na

            // Delete the yellow box when invalidated
            if not na(eng_ob_box)
                box.delete(eng_ob_box)
                eng_ob_box := na

            // Delete TP/SL boxes
            if not na(tp_box)
                box.delete(tp_box)
                tp_box := na
            if not na(sl_box)
                box.delete(sl_box)
                sl_box := na

    else if not eng_ob_is_bullish and supply_triggered and not na(eng_ob_candle_high)
        // Bearish setup invalidated if price makes new higher high than ENG OB candle's high WHILE IN SUPPLY ZONE
        if high > eng_ob_candle_high
            eng_ob_active := false
            eng_ob_is_bullish := false
            eng_ob_deepest_level := na
            eng_ob_bar_index := na
            eng_ob_candle_high := na
            eng_ob_candle_low := na
            target_fractal_level := na

            // Clear MSS OB
            mss_ob_active := false
            mss_ob_entry := na
            mss_ob_tp := na
            mss_ob_sl := na

            // Delete the yellow box when invalidated
            if not na(eng_ob_box)
                box.delete(eng_ob_box)
                eng_ob_box := na

            // Delete TP/SL boxes
            if not na(tp_box)
                box.delete(tp_box)
                tp_box := na
            if not na(sl_box)
                box.delete(sl_box)
                sl_box := na

// INVALIDATION: MSS OB invalidated when price reaches opposite zone
// This invalidation applies even if we haven't left both zones
// Bullish MSS OB invalidated by touching supply zone
// Bearish MSS OB invalidated by touching demand zone
if mss_ob_active
    bool should_invalidate_mss = false

    if eng_ob_is_bullish and in_supply
        // Bullish MSS OB invalidated by reaching supply zone
        should_invalidate_mss := true
    else if not eng_ob_is_bullish and in_demand
        // Bearish MSS OB invalidated by reaching demand zone
        should_invalidate_mss := true

    if should_invalidate_mss
        // Clear the entire setup
        eng_ob_active := false
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level := na

        // Clear MSS OB
        mss_ob_active := false
        mss_ob_entry := na
        mss_ob_tp := na
        mss_ob_sl := na

        // Delete the box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

        // Delete TP/SL boxes
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

// Track which candle made the deepest penetration (only show current)
var label deepest_demand_label = na
var label deepest_supply_label = na

// Update deepest marker when new deepest is found - place below/above candle to avoid covering it
if demand_triggered and not na(demand_lowest_low) and low == demand_lowest_low
    // Delete old label
    if not na(deepest_demand_label)
        label.delete(deepest_demand_label)
    // Create new label below the candle low
    deepest_demand_label := label.new(bar_index, low, "●", xloc=xloc.bar_index, yloc=yloc.price, color=color.new(color.white, 100), textcolor=color.blue, size=size.tiny, style=label.style_label_up, textalign=text.align_center)

if supply_triggered and not na(supply_highest_high) and high == supply_highest_high
    // Delete old label
    if not na(deepest_supply_label)
        label.delete(deepest_supply_label)
    // Create new label above the candle high
    deepest_supply_label := label.new(bar_index, high, "●", xloc=xloc.bar_index, yloc=yloc.price, color=color.new(color.white, 100), textcolor=color.orange, size=size.tiny, style=label.style_label_down, textalign=text.align_center)

// Plot diamonds for engulfing OB detection (smaller size)
plotshape(is_bullish_engulfing, title="Bullish Engulfing OB", style=shape.diamond, location=location.belowbar, color=color.black, size=size.tiny)
plotshape(is_bearish_engulfing, title="Bearish Engulfing OB", style=shape.diamond, location=location.abovebar, color=color.black, size=size.tiny)

// ============================================================================
// VISUAL DEBUG - ENG OB CANDLE BOX
// ============================================================================
// Draw a colored box around the ENG OB candle (green for bullish, red for bearish)
// Box extends to the right while setup is active
if is_bullish_engulfing or is_bearish_engulfing
    // Delete old box
    if not na(eng_ob_box)
        box.delete(eng_ob_box)

    // Draw new box around the OB candle we just identified
    if not na(eng_ob_bar_index)
        int box_left = eng_ob_bar_index
        int box_right = eng_ob_bar_index + 1
        float box_top = eng_ob_candle_high
        float box_bottom = eng_ob_candle_low

        // Use yellow for ENG OB (will turn blue when MSS OB is active)
        color box_color = color.yellow

        eng_ob_box := box.new(box_left, box_top, box_right, box_bottom,
                              border_color=box_color,
                              bgcolor=color.new(box_color, 90),
                              border_width=1,
                              extend=extend.none)

// Update the box to extend to current bar while setup is active (bar by bar, not infinite)
// Continue extending while setup is active (ENG OB or MSS OB active)
// Change color to blue when MSS OB is active
if (eng_ob_active or mss_ob_active) and not na(eng_ob_box)
    box.set_right(eng_ob_box, bar_index + 1)

    // Change box color to blue when MSS OB becomes active
    if mss_ob_active
        box.set_border_color(eng_ob_box, color.blue)
        box.set_bgcolor(eng_ob_box, color.new(color.blue, 90))

// ============================================================================
// LTF FRACTAL DETECTION (only when in AOI or active setup)
// ============================================================================
// Only detect fractals when we're in AOI or have an active setup
bool should_detect_fractals = supply_triggered or demand_triggered or eng_ob_active

// Fractal detection: 2-period lookback/forward (5 candle pattern)
bool is_bearish_fractal = false
bool is_bullish_fractal = false

if should_detect_fractals and bar_index >= 2
    // Bearish fractal: high is higher than 2 candles before and 2 candles after
    is_bearish_fractal := high[2] > high[4] and high[2] > high[3] and high[2] > high[1] and high[2] > high[0]

    // Bullish fractal: low is lower than 2 candles before and 2 candles after
    is_bullish_fractal := low[2] < low[4] and low[2] < low[3] and low[2] < low[1] and low[2] < low[0]

// Plot fractals for debugging (only when actively detecting)
plotshape(is_bearish_fractal, title="Bearish Fractal", style=shape.triangledown, location=location.abovebar, color=color.red, size=size.tiny, offset=-2)
plotshape(is_bullish_fractal, title="Bullish Fractal", style=shape.triangleup, location=location.belowbar, color=color.green, size=size.tiny, offset=-2)

// When ENG OB forms, search BACKWARD for the most recent opposite fractal
// This runs once when target_fractal_level is na (right after ENG OB forms)
if eng_ob_active and na(target_fractal_level) and bar_index >= 4
    // Search backward up to 20 bars for the most recent opposite fractal
    // Limit to avoid historical buffer issues (max lookback is bar_index, but fractal needs i+2)
    int lookback_limit = math.min(20, bar_index - 4)

    if eng_ob_is_bullish
        // Bullish setup: look for most recent bearish fractal (high point)
        for i = 2 to lookback_limit
            // Check if bar at offset i is a bearish fractal
            // Only check if we have enough history (i+2 bars back)
            if i + 2 <= bar_index
                bool is_bearish_frac = high[i] > high[i+2] and high[i] > high[i+1] and high[i] > high[i-1] and high[i] > high[i-2]
                if is_bearish_frac
                    // Found the most recent bearish fractal
                    target_fractal_level := high[i]
                    break
    else
        // Bearish setup: look for most recent bullish fractal (low point)
        for i = 2 to lookback_limit
            // Check if bar at offset i is a bullish fractal
            // Only check if we have enough history (i+2 bars back)
            if i + 2 <= bar_index
                bool is_bullish_frac = low[i] < low[i+2] and low[i] < low[i+1] and low[i] < low[i-1] and low[i] < low[i-2]
                if is_bullish_frac
                    // Found the most recent bullish fractal
                    target_fractal_level := low[i]
                    break

// ============================================================================
// MSS OB DETECTION - Price crosses fractal level
// ============================================================================
// Check if price has crossed the fractal level (wick or close through)
if eng_ob_active and not mss_ob_active and not na(target_fractal_level)
    bool fractal_crossed = false

    if eng_ob_is_bullish
        // Bullish setup: check if price crossed above the bearish fractal high
        fractal_crossed := high >= target_fractal_level
    else
        // Bearish setup: check if price crossed below the bullish fractal low
        fractal_crossed := low <= target_fractal_level

    if fractal_crossed
        // MSS OB is now valid - the ENG OB candle IS the MSS OB
        mss_ob_active := true

        // Set entry, TP, and SL based on the OB candle
        if eng_ob_is_bullish
            // Bullish: Entry at high of OB candle, SL at low, TP at 2:1 RR
            mss_ob_entry := eng_ob_candle_high
            mss_ob_sl := eng_ob_candle_low
            float risk = mss_ob_entry - mss_ob_sl
            mss_ob_tp := mss_ob_entry + (risk * 2)  // 2:1 reward to risk
        else
            // Bearish: Entry at low of OB candle, SL at high, TP at 2:1 RR
            mss_ob_entry := eng_ob_candle_low
            mss_ob_sl := eng_ob_candle_high
            float risk = mss_ob_sl - mss_ob_entry
            mss_ob_tp := mss_ob_entry - (risk * 2)  // 2:1 reward to risk

        // Calculate position size based on risk
        float risk_per_contract = math.abs(mss_ob_entry - mss_ob_sl)
        float position_size = risk_per_trade / risk_per_contract

        // Place limit order at entry level
        if eng_ob_is_bullish
            // Enter long position with limit order at entry level
            strategy.entry("Long", strategy.long, qty=position_size, limit=mss_ob_entry)
            strategy.exit("TP/SL Long", "Long", limit=mss_ob_tp, stop=mss_ob_sl)
        else
            // Enter short position with limit order at entry level
            strategy.entry("Short", strategy.short, qty=position_size, limit=mss_ob_entry)
            strategy.exit("TP/SL Short", "Short", limit=mss_ob_tp, stop=mss_ob_sl)

        // Create TP and SL indicator boxes
        // Delete old boxes first
        if not na(tp_box)
            box.delete(tp_box)
        if not na(sl_box)
            box.delete(sl_box)

        // Create new TP box (green) and SL box (red)
        if eng_ob_is_bullish
            // Bullish: TP is above entry
            tp_box := box.new(bar_index, mss_ob_tp, bar_index + 1, mss_ob_entry,
                             border_color=color.green,
                             bgcolor=color.new(color.green, 85),
                             border_width=1,
                             extend=extend.none)
            // SL is below entry
            sl_box := box.new(bar_index, mss_ob_entry, bar_index + 1, mss_ob_sl,
                             border_color=color.red,
                             bgcolor=color.new(color.red, 85),
                             border_width=1,
                             extend=extend.none)
        else
            // Bearish: TP is below entry
            tp_box := box.new(bar_index, mss_ob_entry, bar_index + 1, mss_ob_tp,
                             border_color=color.green,
                             bgcolor=color.new(color.green, 85),
                             border_width=1,
                             extend=extend.none)
            // SL is above entry
            sl_box := box.new(bar_index, mss_ob_sl, bar_index + 1, mss_ob_entry,
                             border_color=color.red,
                             bgcolor=color.new(color.red, 85),
                             border_width=1,
                             extend=extend.none)

// ============================================================================
// TRADE EXECUTION - Track when limit order is filled
// ============================================================================
// Check if limit order has been filled
if mss_ob_active and not trade_entered
    // Check if we now have an open position (limit order was filled)
    if strategy.position_size != 0
        trade_entered := true

// Check if trade has exited (TP or SL hit)
if trade_entered and strategy.position_size == 0
    // Trade has exited - clear all setup variables
    eng_ob_active := false
    eng_ob_is_bullish := false
    eng_ob_deepest_level := na
    eng_ob_bar_index := na
    eng_ob_candle_high := na
    eng_ob_candle_low := na
    target_fractal_level := na

    // Clear MSS OB
    mss_ob_active := false
    mss_ob_entry := na
    mss_ob_tp := na
    mss_ob_sl := na

    // Reset trade flag
    trade_entered := false

    // Delete all boxes
    if not na(eng_ob_box)
        box.delete(eng_ob_box)
        eng_ob_box := na
    if not na(tp_box)
        box.delete(tp_box)
        tp_box := na
    if not na(sl_box)
        box.delete(sl_box)
        sl_box := na

// Update TP/SL boxes to extend one bar at a time while MSS OB is active (awaiting entry or in trade)
if mss_ob_active and not na(tp_box) and not na(sl_box)
    box.set_right(tp_box, bar_index + 1)
    box.set_right(sl_box, bar_index + 1)

// ============================================================================
// DEBUG TABLE
// ============================================================================
var table debugTable = table.new(position.top_right, 2, 17, border_width=1)  // 17 rows: Position Size added

// Determine AOI status based on flow rules
string aoi_status = "-"
color label_bgcolor = color.new(color.black, 20)  // Dark background for labels (left column)
color value_bgcolor = color.new(color.gray, 30)   // Default background for values (right column)

// Track which zone type we're working with for value column color
bool is_supply_setup = supply_triggered or (eng_ob_active and not eng_ob_is_bullish)
bool is_demand_setup = demand_triggered or (eng_ob_active and eng_ob_is_bullish)

if trade_entered and strategy.position_size != 0
    // Trade is active - in position
    aoi_status := "IN TRADE"
    value_bgcolor := eng_ob_is_bullish ? color.new(color.blue, 50) : color.new(color.red, 50)
else if mss_ob_active
    // MSS OB is active - awaiting entry
    aoi_status := "AWAITING ENTRY"
    value_bgcolor := eng_ob_is_bullish ? color.new(color.blue, 50) : color.new(color.red, 50)
else if eng_ob_active
    // Once ENG OB forms, status is ACTIVE (even if price leaves AOI)
    aoi_status := "ACTIVE"
    value_bgcolor := eng_ob_is_bullish ? color.new(color.blue, 50) : color.new(color.red, 50)
else if supply_triggered or demand_triggered
    // In AOI but no ENG OB yet
    aoi_status := "IN AOI"
    value_bgcolor := supply_triggered ? color.new(color.red, 50) : color.new(color.blue, 50)
else
    // Not in AOI and no active setup
    aoi_status := "-"
    value_bgcolor := color.new(color.gray, 30)

// Pad the status text to keep column width consistent
string padded_status = aoi_status == "-" ? "  -   " : aoi_status

table.cell(debugTable, 0, 0, "AOI Status", text_color=color.white, bgcolor=label_bgcolor, text_size=size.normal)
table.cell(debugTable, 1, 0, padded_status, text_color=color.white, bgcolor=value_bgcolor, text_size=size.normal)

// Engulfing OB status - show checkmark when active
string eng_status = "-"
color eng_bgcolor = value_bgcolor
if eng_ob_active
    eng_status := "✓"
    // Keep the same background as the overall value column

table.cell(debugTable, 0, 1, "Engulfing OB", text_color=color.white, bgcolor=label_bgcolor, text_size=size.normal)
table.cell(debugTable, 1, 1, eng_status, text_color=color.white, bgcolor=eng_bgcolor, text_size=size.normal)

// MSS OB status - show checkmark when active
string mss_status = "-"
color mss_bgcolor = value_bgcolor
if mss_ob_active
    mss_status := "✓"
table.cell(debugTable, 0, 2, "MSS OB", text_color=color.white, bgcolor=label_bgcolor, text_size=size.normal)
table.cell(debugTable, 1, 2, mss_status, text_color=color.white, bgcolor=mss_bgcolor, text_size=size.normal)

// Fractal Level - show target price for MSS OB (only when setup is active)
string fractal_level = "-"
if eng_ob_active
    if not na(target_fractal_level)
        fractal_level := str.tostring(target_fractal_level, format.mintick) + (eng_ob_is_bullish ? " (↑)" : " (↓)")
    else
        // Show "SEARCHING" if we have an active ENG OB but no fractal yet
        fractal_level := "SEARCHING"
table.cell(debugTable, 0, 3, "Fractal Level", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 3, fractal_level, text_color=color.white, bgcolor=value_bgcolor, text_size=size.small)

// Position Size - debug to see strategy.position_size
string pos_size = str.tostring(strategy.position_size)
table.cell(debugTable, 0, 4, "Position Size", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 4, pos_size, text_color=color.white, bgcolor=value_bgcolor, text_size=size.small)

// Entry Price
string entry_price = "-"
if mss_ob_active and not na(mss_ob_entry)
    entry_price := str.tostring(mss_ob_entry, format.mintick)
table.cell(debugTable, 0, 5, "Entry Price", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 5, entry_price, text_color=color.white, bgcolor=value_bgcolor, text_size=size.small)

// Take Profit
string tp_price = "-"
if mss_ob_active and not na(mss_ob_tp)
    tp_price := str.tostring(mss_ob_tp, format.mintick)
table.cell(debugTable, 0, 6, "TP", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 6, tp_price, text_color=color.white, bgcolor=value_bgcolor, text_size=size.small)

// Stop Loss
string sl_price = "-"
if mss_ob_active and not na(mss_ob_sl)
    sl_price := str.tostring(mss_ob_sl, format.mintick)
table.cell(debugTable, 0, 7, "SL", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 7, sl_price, text_color=color.white, bgcolor=value_bgcolor, text_size=size.small)

// Bars Since Setup - show how many bars since ENG OB formed
string bars_since_setup = "-"
if eng_ob_active and not na(eng_ob_bar_index)
    bars_since_setup := str.tostring(bar_index - eng_ob_bar_index)
table.cell(debugTable, 0, 8, "Bars Since Setup", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 8, bars_since_setup, text_color=color.white, bgcolor=value_bgcolor, text_size=size.small)

// Supply zone levels - show DISABLED if disabled
string supply_zone = "-"
if clear_supply
    supply_zone := "DISABLED"
else if supply_configured
    supply_zone := str.tostring(supply_bottom, format.mintick) + " - " + str.tostring(supply_top, format.mintick)
table.cell(debugTable, 0, 9, "Supply Zone", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 9, supply_zone, text_color=color.white, bgcolor=value_bgcolor, text_size=size.small)

// Demand zone levels - show DISABLED if disabled
string demand_zone = "-"
color demand_zone_bgcolor = value_bgcolor
if clear_demand
    demand_zone := "DISABLED"
else if demand_configured
    demand_zone := str.tostring(demand_bottom, format.mintick) + " - " + str.tostring(demand_top, format.mintick)
    demand_zone_bgcolor := color.new(color.blue, 50)  // Always blue/green for demand
table.cell(debugTable, 0, 10, "Demand Zone", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 10, demand_zone, text_color=color.white, bgcolor=demand_zone_bgcolor, text_size=size.small)

// Session levels - show level or "X" if crossed
// Asian High
string asian_high_text = "-"
color asian_high_bg = label_bgcolor
if not na(asian_high)
    if asian_high_crossed
        asian_high_text := "✗ CROSSED"
        asian_high_bg := color.new(color.gray, 50)
    else
        asian_high_text := str.tostring(asian_high, format.mintick)
        asian_high_bg := color.new(color.red, 70)
table.cell(debugTable, 0, 11, "Asian High", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 11, asian_high_text, text_color=color.white, bgcolor=asian_high_bg, text_size=size.small)

// Asian Low
string asian_low_text = "-"
color asian_low_bg = label_bgcolor
if not na(asian_low)
    if asian_low_crossed
        asian_low_text := "✗ CROSSED"
        asian_low_bg := color.new(color.gray, 50)
    else
        asian_low_text := str.tostring(asian_low, format.mintick)
        asian_low_bg := color.new(color.green, 70)
table.cell(debugTable, 0, 12, "Asian Low", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 12, asian_low_text, text_color=color.white, bgcolor=asian_low_bg, text_size=size.small)

// London High
string london_high_text = "-"
color london_high_bg = label_bgcolor
if not na(london_high)
    if london_high_crossed
        london_high_text := "✗ CROSSED"
        london_high_bg := color.new(color.gray, 50)
    else
        london_high_text := str.tostring(london_high, format.mintick)
        london_high_bg := color.new(color.red, 70)
table.cell(debugTable, 0, 13, "London High", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 13, london_high_text, text_color=color.white, bgcolor=london_high_bg, text_size=size.small)

// London Low
string london_low_text = "-"
color london_low_bg = label_bgcolor
if not na(london_low)
    if london_low_crossed
        london_low_text := "✗ CROSSED"
        london_low_bg := color.new(color.gray, 50)
    else
        london_low_text := str.tostring(london_low, format.mintick)
        london_low_bg := color.new(color.green, 70)
table.cell(debugTable, 0, 14, "London Low", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 14, london_low_text, text_color=color.white, bgcolor=london_low_bg, text_size=size.small)

// Previous Day High
string prev_high_text = "-"
color prev_high_bg = label_bgcolor
if not na(prev_day_high)
    if prev_day_high_crossed
        prev_high_text := "✗ CROSSED"
        prev_high_bg := color.new(color.gray, 50)
    else
        prev_high_text := str.tostring(prev_day_high, format.mintick)
        prev_high_bg := color.new(color.red, 70)
table.cell(debugTable, 0, 15, "Prev Day High", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 15, prev_high_text, text_color=color.white, bgcolor=prev_high_bg, text_size=size.small)

// Previous Day Low
string prev_low_text = "-"
color prev_low_bg = label_bgcolor
if not na(prev_day_low)
    if prev_day_low_crossed
        prev_low_text := "✗ CROSSED"
        prev_low_bg := color.new(color.gray, 50)
    else
        prev_low_text := str.tostring(prev_day_low, format.mintick)
        prev_low_bg := color.new(color.green, 70)
table.cell(debugTable, 0, 16, "Prev Day Low", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 16, prev_low_text, text_color=color.white, bgcolor=prev_low_bg, text_size=size.small)
