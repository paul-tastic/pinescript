//@version=5
strategy("Nexus Strategy Manual", overlay=true, initial_capital=10000, default_qty_type=strategy.fixed, default_qty_value=1)

// ============================================================================
// INPUTS - MANUAL ZONES
// ============================================================================
supply_top = input.float(0.0, "Supply Zone Top", group="Manual Zones")
supply_bottom = input.float(0.0, "Supply Zone Bottom", group="Manual Zones")
clear_supply = input.bool(false, "Disable Supply Zone", group="Manual Zones", tooltip="Check to temporarily disable supply zone without clearing values")

demand_top = input.float(0.0, "Demand Zone Top", group="Manual Zones")
demand_bottom = input.float(0.0, "Demand Zone Bottom", group="Manual Zones")
clear_demand = input.bool(false, "Disable Demand Zone", group="Manual Zones", tooltip="Check to temporarily disable demand zone without clearing values")

// ============================================================================
// ZONE DETECTION
// ============================================================================
// Apply clear flags - if clear is checked, treat zone as not configured
bool supply_configured = not clear_supply and supply_top > 0 and supply_bottom > 0 and supply_top > supply_bottom
bool demand_configured = not clear_demand and demand_top > 0 and demand_bottom > 0 and demand_top > demand_bottom

// Check if candle touches zone (high/low overlap with zone range)
// Uses real-time high/low so it triggers immediately when zone is touched
bool in_supply = supply_configured and not (low > supply_top or high < supply_bottom)
bool in_demand = demand_configured and not (low > demand_top or high < demand_bottom)

// Track zone entry - once triggered, stays true for the entire bar + 1 more bar
var bool supply_triggered = false
var bool demand_triggered = false
var int supply_trigger_bar = -1
var int demand_trigger_bar = -1

// Track deepest penetration into zones (resets on fresh entry)
var float demand_lowest_low = na
var float supply_highest_high = na

// Track if we're completely outside both zones (ready to reset)
var bool was_outside_zones = true

// Track if ENG OB is active (declare early so it can be used in zone logic)
var bool eng_ob_active = false
var bool eng_ob_is_bullish = false
var float eng_ob_deepest_level = na
var float target_fractal_level = na
var int eng_ob_bar_index = na
var float eng_ob_candle_high = na
var float eng_ob_candle_low = na
var box eng_ob_box = na  // Yellow box around ENG OB candle for visual debug

// Track MSS OB (formed when price crosses fractal level)
var bool mss_ob_active = false
var float mss_ob_entry = na  // Entry price (high of OB candle for bullish, low for bearish)
var float mss_ob_tp = na     // Take profit level
var float mss_ob_sl = na     // Stop loss level

// Check if currently outside both zones
bool outside_both_zones = not in_supply and not in_demand

if barstate.isnew
    // Clear trigger only if it's been more than 1 bar since entry
    if bar_index - supply_trigger_bar > 1
        supply_triggered := false
    if bar_index - demand_trigger_bar > 1
        demand_triggered := false

    // Track when we're outside both zones
    // Only set was_outside_zones if there's NO active ENG OB setup
    if outside_both_zones and not eng_ob_active
        was_outside_zones := true

if in_supply
    supply_triggered := true
    supply_trigger_bar := bar_index

    // Reset deepest on fresh entry after being outside
    if was_outside_zones
        supply_highest_high := high
        was_outside_zones := false
    // Otherwise, track highest high in supply zone
    else if na(supply_highest_high) or high > supply_highest_high
        supply_highest_high := high

if in_demand
    demand_triggered := true
    demand_trigger_bar := bar_index

    // Reset deepest on fresh entry after being outside
    if was_outside_zones
        demand_lowest_low := low
        was_outside_zones := false
    // Otherwise, track lowest low in demand zone
    else if na(demand_lowest_low) or low < demand_lowest_low
        demand_lowest_low := low

// ============================================================================
// SETUP FLOW AND INVALIDATION RULES
// ============================================================================
// FLOW:
// 1. When AOI is entered, show "IN AOI"
// 2. If price leaves AOI without an ENG OB, return to "-"
// 3. If ENG OB forms, black diamond appears, ENG OB shows checkmark
//    - AOI status changes to "ACTIVE" (setup is now active)
//    - ENG OB stays checked until invalidated
// 4. Look BACKWARD for first opposite LTF fractal candle, place debug diamond above it
// 5. If price crosses fractal high (bullish) or low (bearish), MSS OB is formed
//    - Checkmark MSS OB row
//    - Draw entry OB from lowest candle in ENG OB setup (use that candle's high and low)
//    - Add debug row showing entry window
//    - Status changes to "AWAITING MSS OB ENTRY"
//
// INVALIDATION RULES:
// - ENG OB invalidated: if price goes deeper into zone than ENG OB candle before crossing fractal level (step 5)
// - MSS OB invalidated: if price touches opposite color zone (may add more criteria later)
//
// ============================================================================
// ENGULFING ORDER BLOCK DETECTION
// ============================================================================
bool is_bullish_engulfing = false
bool is_bearish_engulfing = false

// Only check for engulfing when in an AOI
if demand_triggered and bar_index > 0
    // Bullish engulfing: current candle close engulfs previous candle body
    bool current_bullish = close > open
    bool prev_bearish = close[1] < open[1]
    bool engulfs_body = close >= open[1]

    // Check if current or previous candle made the deepest low
    bool is_deepest = low <= demand_lowest_low or low[1] <= demand_lowest_low

    is_bullish_engulfing := current_bullish and prev_bearish and engulfs_body and is_deepest

if supply_triggered and bar_index > 0
    // Bearish engulfing: current candle close engulfs previous candle body
    bool current_bearish = close < open
    bool prev_bullish = close[1] > open[1]
    bool engulfs_body = close <= open[1]

    // Check if current or previous candle made the highest high
    bool is_deepest = high >= supply_highest_high or high[1] >= supply_highest_high

    is_bearish_engulfing := current_bearish and prev_bullish and engulfs_body and is_deepest

bool engulfing_ob_detected = is_bullish_engulfing or is_bearish_engulfing

// INVALIDATION: Clear setup when zones are disabled
// Only invalidate if the disabled zone MATCHES the setup's zone
// Bullish setup (from demand) only invalidated by clear_demand
// Bearish setup (from supply) only invalidated by clear_supply
if eng_ob_active
    bool should_invalidate = false

    if eng_ob_is_bullish and clear_demand
        // Bullish setup invalidated by disabling demand zone
        should_invalidate := true
        label.new(bar_index, high, "❌ ZONE DISABLED\nDemand zone",
                 color=color.purple, textcolor=color.white, style=label.style_label_down, size=size.small)
    else if not eng_ob_is_bullish and clear_supply
        // Bearish setup invalidated by disabling supply zone
        should_invalidate := true
        label.new(bar_index, high, "❌ ZONE DISABLED\nSupply zone",
                 color=color.purple, textcolor=color.white, style=label.style_label_down, size=size.small)

    if should_invalidate
        eng_ob_active := false
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level := na

        // Clear MSS OB
        mss_ob_active := false
        mss_ob_entry := na
        mss_ob_tp := na
        mss_ob_sl := na

        // Delete yellow box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

// INVALIDATION: Clear setup when entering the OPPOSITE zone (fresh zone entry)
// Bullish setup (from demand) invalidated by entering supply zone
// Bearish setup (from supply) invalidated by entering demand zone
if barstate.isnew and was_outside_zones
    if eng_ob_active and eng_ob_is_bullish and in_supply
        // DEBUG: Show opposite zone entry invalidation
        label.new(bar_index, high, "❌ OPPOSITE ZONE\nBullish setup → Supply",
                 color=color.purple, textcolor=color.white, style=label.style_label_down, size=size.small)

        // Bullish setup invalidated by entering supply zone
        eng_ob_active := false
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level := na

        // Clear MSS OB
        mss_ob_active := false
        mss_ob_entry := na
        mss_ob_tp := na
        mss_ob_sl := na

        // Delete yellow box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

    else if eng_ob_active and not eng_ob_is_bullish and in_demand
        // DEBUG: Show opposite zone entry invalidation
        label.new(bar_index, low, "❌ OPPOSITE ZONE\nBearish setup → Demand",
                 color=color.purple, textcolor=color.white, style=label.style_label_up, size=size.small)

        // Bearish setup invalidated by entering demand zone
        eng_ob_active := false
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level := na

        // Clear MSS OB
        mss_ob_active := false
        mss_ob_entry := na
        mss_ob_tp := na
        mss_ob_sl := na

        // Delete yellow box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

// When ENG OB forms, activate it and record deepest level + capture the OB candle
if is_bullish_engulfing
    eng_ob_active := true
    eng_ob_is_bullish := true
    eng_ob_deepest_level := demand_lowest_low
    target_fractal_level := na  // Reset fractal search for new ENG OB

    // Determine which candle is the actual OB candle (the one that made the deepest low)
    // For bullish engulfing, the OB candle is whichever made the lowest low
    if low <= low[1]
        // Current candle made the deepest low - it's the OB candle
        eng_ob_bar_index := bar_index
        eng_ob_candle_high := high
        eng_ob_candle_low := low
    else
        // Previous candle made the deepest low - it's the OB candle
        eng_ob_bar_index := bar_index - 1
        eng_ob_candle_high := high[1]
        eng_ob_candle_low := low[1]

else if is_bearish_engulfing
    eng_ob_active := true
    eng_ob_is_bullish := false
    eng_ob_deepest_level := supply_highest_high
    target_fractal_level := na  // Reset fractal search for new ENG OB

    // Determine which candle is the actual OB candle (the one that made the highest high)
    // For bearish engulfing, the OB candle is whichever made the highest high
    if high >= high[1]
        // Current candle made the highest high - it's the OB candle
        eng_ob_bar_index := bar_index
        eng_ob_candle_high := high
        eng_ob_candle_low := low
    else
        // Previous candle made the highest high - it's the OB candle
        eng_ob_bar_index := bar_index - 1
        eng_ob_candle_high := high[1]
        eng_ob_candle_low := low[1]

// INVALIDATION: Price goes deeper into zone than ENG OB candle (before MSS OB is crossed)
// Only invalidate if price is IN the zone and goes deeper than the OB candle
// TODO: Once MSS OB crossing detection is implemented, add condition to stop invalidation after cross
if eng_ob_active
    if eng_ob_is_bullish and demand_triggered and not na(eng_ob_candle_low)
        // Bullish setup invalidated if price makes new lower low than ENG OB candle's low WHILE IN DEMAND ZONE
        if low < eng_ob_candle_low
            // DEBUG: Show invalidation reason
            label.new(bar_index, low, "❌ INVAL\nlow:" + str.tostring(low, format.mintick) + "\nOB:" + str.tostring(eng_ob_candle_low, format.mintick),
                     color=color.red, textcolor=color.white, style=label.style_label_up, size=size.small)

            eng_ob_active := false
            eng_ob_is_bullish := false
            eng_ob_deepest_level := na
            eng_ob_bar_index := na
            eng_ob_candle_high := na
            eng_ob_candle_low := na
            target_fractal_level := na

            // Clear MSS OB
            mss_ob_active := false
            mss_ob_entry := na
            mss_ob_tp := na
            mss_ob_sl := na

            // Delete the yellow box when invalidated
            if not na(eng_ob_box)
                box.delete(eng_ob_box)
                eng_ob_box := na

    else if not eng_ob_is_bullish and supply_triggered and not na(eng_ob_candle_high)
        // Bearish setup invalidated if price makes new higher high than ENG OB candle's high WHILE IN SUPPLY ZONE
        if high > eng_ob_candle_high
            // DEBUG: Show invalidation reason
            label.new(bar_index, high, "❌ INVAL\nhigh:" + str.tostring(high, format.mintick) + "\nOB:" + str.tostring(eng_ob_candle_high, format.mintick),
                     color=color.red, textcolor=color.white, style=label.style_label_down, size=size.small)

            eng_ob_active := false
            eng_ob_is_bullish := false
            eng_ob_deepest_level := na
            eng_ob_bar_index := na
            eng_ob_candle_high := na
            eng_ob_candle_low := na
            target_fractal_level := na

            // Clear MSS OB
            mss_ob_active := false
            mss_ob_entry := na
            mss_ob_tp := na
            mss_ob_sl := na

            // Delete the yellow box when invalidated
            if not na(eng_ob_box)
                box.delete(eng_ob_box)
                eng_ob_box := na

// Track which candle made the deepest penetration (only show current)
var label deepest_demand_label = na
var label deepest_supply_label = na

// Update deepest marker when new deepest is found - place below/above candle to avoid covering it
if demand_triggered and not na(demand_lowest_low) and low == demand_lowest_low
    // Delete old label
    if not na(deepest_demand_label)
        label.delete(deepest_demand_label)
    // Create new label below the candle low
    deepest_demand_label := label.new(bar_index, low, "●", xloc=xloc.bar_index, yloc=yloc.price, color=color.new(color.white, 100), textcolor=color.blue, size=size.tiny, style=label.style_label_up, textalign=text.align_center)

if supply_triggered and not na(supply_highest_high) and high == supply_highest_high
    // Delete old label
    if not na(deepest_supply_label)
        label.delete(deepest_supply_label)
    // Create new label above the candle high
    deepest_supply_label := label.new(bar_index, high, "●", xloc=xloc.bar_index, yloc=yloc.price, color=color.new(color.white, 100), textcolor=color.orange, size=size.tiny, style=label.style_label_down, textalign=text.align_center)

// Plot diamonds for engulfing OB detection (smaller size)
plotshape(is_bullish_engulfing, title="Bullish Engulfing OB", style=shape.diamond, location=location.belowbar, color=color.black, size=size.tiny)
plotshape(is_bearish_engulfing, title="Bearish Engulfing OB", style=shape.diamond, location=location.abovebar, color=color.black, size=size.tiny)

// ============================================================================
// VISUAL DEBUG - ENG OB CANDLE BOX
// ============================================================================
// Draw a colored box around the ENG OB candle (green for bullish, red for bearish)
// Box extends to the right while setup is active
if is_bullish_engulfing or is_bearish_engulfing
    // Delete old box
    if not na(eng_ob_box)
        box.delete(eng_ob_box)

    // Draw new box around the OB candle we just identified
    if not na(eng_ob_bar_index)
        int box_left = eng_ob_bar_index
        int box_right = eng_ob_bar_index + 1
        float box_top = eng_ob_candle_high
        float box_bottom = eng_ob_candle_low

        // Use green for bullish, red for bearish
        color box_color = eng_ob_is_bullish ? color.green : color.red

        eng_ob_box := box.new(box_left, box_top, box_right, box_bottom,
                              border_color=box_color,
                              bgcolor=color.new(box_color, 90),
                              border_width=1,
                              extend=extend.none)

// Update the box to extend to current bar while setup is active (bar by bar, not infinite)
if eng_ob_active and not na(eng_ob_box)
    box.set_right(eng_ob_box, bar_index + 1)

// ============================================================================
// LTF FRACTAL DETECTION (only when in AOI or active setup)
// ============================================================================
// Only detect fractals when we're in AOI or have an active setup
bool should_detect_fractals = supply_triggered or demand_triggered or eng_ob_active

// Fractal detection: 2-period lookback/forward (5 candle pattern)
bool is_bearish_fractal = false
bool is_bullish_fractal = false

if should_detect_fractals and bar_index >= 2
    // Bearish fractal: high is higher than 2 candles before and 2 candles after
    is_bearish_fractal := high[2] > high[4] and high[2] > high[3] and high[2] > high[1] and high[2] > high[0]

    // Bullish fractal: low is lower than 2 candles before and 2 candles after
    is_bullish_fractal := low[2] < low[4] and low[2] < low[3] and low[2] < low[1] and low[2] < low[0]

// Plot fractals for debugging (only when actively detecting)
plotshape(is_bearish_fractal, title="Bearish Fractal", style=shape.triangledown, location=location.abovebar, color=color.red, size=size.tiny, offset=-2)
plotshape(is_bullish_fractal, title="Bullish Fractal", style=shape.triangleup, location=location.belowbar, color=color.green, size=size.tiny, offset=-2)

// When ENG OB forms, search BACKWARD for the most recent opposite fractal
// This runs once when target_fractal_level is na (right after ENG OB forms)
if eng_ob_active and na(target_fractal_level) and bar_index >= 4
    // Search backward up to 50 bars for the most recent opposite fractal
    int lookback_limit = 50

    if eng_ob_is_bullish
        // Bullish setup: look for most recent bearish fractal (high point)
        for i = 2 to math.min(lookback_limit, bar_index - 2)
            // Check if bar at offset i is a bearish fractal
            bool is_bearish_frac = high[i] > high[i+2] and high[i] > high[i+1] and high[i] > high[i-1] and high[i] > high[i-2]
            if is_bearish_frac
                // Found the most recent bearish fractal
                target_fractal_level := high[i]
                break
    else
        // Bearish setup: look for most recent bullish fractal (low point)
        for i = 2 to math.min(lookback_limit, bar_index - 2)
            // Check if bar at offset i is a bullish fractal
            bool is_bullish_frac = low[i] < low[i+2] and low[i] < low[i+1] and low[i] < low[i-1] and low[i] < low[i-2]
            if is_bullish_frac
                // Found the most recent bullish fractal
                target_fractal_level := low[i]
                break

// ============================================================================
// MSS OB DETECTION - Price crosses fractal level
// ============================================================================
// Check if price has crossed the fractal level (wick or close through)
if eng_ob_active and not mss_ob_active and not na(target_fractal_level)
    bool fractal_crossed = false

    if eng_ob_is_bullish
        // Bullish setup: check if price crossed above the bearish fractal high
        fractal_crossed := high >= target_fractal_level
    else
        // Bearish setup: check if price crossed below the bullish fractal low
        fractal_crossed := low <= target_fractal_level

    if fractal_crossed
        // MSS OB is now valid - the ENG OB candle IS the MSS OB
        mss_ob_active := true

        // Set entry, TP, and SL based on the OB candle
        if eng_ob_is_bullish
            // Bullish: Entry at high of OB candle, SL at low, TP at 2:1 RR
            mss_ob_entry := eng_ob_candle_high
            mss_ob_sl := eng_ob_candle_low
            float risk = mss_ob_entry - mss_ob_sl
            mss_ob_tp := mss_ob_entry + (risk * 2)  // 2:1 reward to risk
        else
            // Bearish: Entry at low of OB candle, SL at high, TP at 2:1 RR
            mss_ob_entry := eng_ob_candle_low
            mss_ob_sl := eng_ob_candle_high
            float risk = mss_ob_sl - mss_ob_entry
            mss_ob_tp := mss_ob_entry - (risk * 2)  // 2:1 reward to risk

// ============================================================================
// DEBUG TABLE
// ============================================================================
var table debugTable = table.new(position.bottom_left, 2, 9, border_width=1)  // Increased from 6 to 9 rows

// Determine AOI status based on flow rules
string aoi_status = "-"
color label_bgcolor = color.new(color.black, 20)  // Dark background for labels (left column)
color value_bgcolor = color.new(color.gray, 30)   // Default background for values (right column)

// Track which zone type we're working with for value column color
bool is_supply_setup = supply_triggered or (eng_ob_active and not eng_ob_is_bullish)
bool is_demand_setup = demand_triggered or (eng_ob_active and eng_ob_is_bullish)

if mss_ob_active
    // MSS OB is active - awaiting entry
    aoi_status := "AWAITING ENTRY"
    value_bgcolor := eng_ob_is_bullish ? color.new(color.blue, 50) : color.new(color.orange, 50)
else if eng_ob_active
    // Once ENG OB forms, status is ACTIVE (even if price leaves AOI)
    aoi_status := "ACTIVE"
    value_bgcolor := eng_ob_is_bullish ? color.new(color.blue, 50) : color.new(color.orange, 50)
else if supply_triggered or demand_triggered
    // In AOI but no ENG OB yet
    aoi_status := "IN AOI"
    value_bgcolor := supply_triggered ? color.new(color.orange, 50) : color.new(color.blue, 50)
else
    // Not in AOI and no active setup
    aoi_status := "-"
    value_bgcolor := color.new(color.gray, 30)

// Pad the status text to keep column width consistent
string padded_status = aoi_status == "-" ? "  -   " : aoi_status

table.cell(debugTable, 0, 0, "AOI Status", text_color=color.white, bgcolor=label_bgcolor, text_size=size.normal)
table.cell(debugTable, 1, 0, padded_status, text_color=color.white, bgcolor=value_bgcolor, text_size=size.normal)

// Engulfing OB status - show checkmark when active
string eng_status = "-"
color eng_bgcolor = value_bgcolor
if eng_ob_active
    eng_status := "✓"
    // Keep the same background as the overall value column

table.cell(debugTable, 0, 1, "Engulfing OB", text_color=color.white, bgcolor=label_bgcolor, text_size=size.normal)
table.cell(debugTable, 1, 1, eng_status, text_color=color.white, bgcolor=eng_bgcolor, text_size=size.normal)

// MSS OB status - show checkmark when active
string mss_status = "-"
color mss_bgcolor = value_bgcolor
if mss_ob_active
    mss_status := "✓"
table.cell(debugTable, 0, 2, "MSS OB", text_color=color.white, bgcolor=label_bgcolor, text_size=size.normal)
table.cell(debugTable, 1, 2, mss_status, text_color=color.white, bgcolor=mss_bgcolor, text_size=size.normal)

// Fractal Level - show target price for MSS OB (only when setup is active)
string fractal_level = "-"
if eng_ob_active
    if not na(target_fractal_level)
        fractal_level := str.tostring(target_fractal_level, format.mintick) + (eng_ob_is_bullish ? " (↑)" : " (↓)")
    else
        // Show "SEARCHING" if we have an active ENG OB but no fractal yet
        fractal_level := "SEARCHING"
table.cell(debugTable, 0, 3, "Fractal Level", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 3, fractal_level, text_color=color.white, bgcolor=value_bgcolor, text_size=size.small)

// Entry Price
string entry_price = "-"
if mss_ob_active and not na(mss_ob_entry)
    entry_price := str.tostring(mss_ob_entry, format.mintick)
table.cell(debugTable, 0, 4, "Entry Price", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 4, entry_price, text_color=color.white, bgcolor=value_bgcolor, text_size=size.small)

// Take Profit
string tp_price = "-"
if mss_ob_active and not na(mss_ob_tp)
    tp_price := str.tostring(mss_ob_tp, format.mintick)
table.cell(debugTable, 0, 5, "TP", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 5, tp_price, text_color=color.white, bgcolor=value_bgcolor, text_size=size.small)

// Stop Loss
string sl_price = "-"
if mss_ob_active and not na(mss_ob_sl)
    sl_price := str.tostring(mss_ob_sl, format.mintick)
table.cell(debugTable, 0, 6, "SL", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 6, sl_price, text_color=color.white, bgcolor=value_bgcolor, text_size=size.small)

// Supply zone levels - show DISABLED if disabled
string supply_zone = "-"
if clear_supply
    supply_zone := "DISABLED"
else if supply_configured
    supply_zone := str.tostring(supply_bottom, format.mintick) + " - " + str.tostring(supply_top, format.mintick)
table.cell(debugTable, 0, 7, "Supply Zone", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 7, supply_zone, text_color=color.white, bgcolor=value_bgcolor, text_size=size.small)

// Demand zone levels - show DISABLED if disabled
string demand_zone = "-"
if clear_demand
    demand_zone := "DISABLED"
else if demand_configured
    demand_zone := str.tostring(demand_bottom, format.mintick) + " - " + str.tostring(demand_top, format.mintick)
table.cell(debugTable, 0, 8, "Demand Zone", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 8, demand_zone, text_color=color.white, bgcolor=value_bgcolor, text_size=size.small)
