//@version=5
strategy("Nexus Strategy Manual", overlay=true, initial_capital=10000, default_qty_type=strategy.fixed, default_qty_value=1)

// ============================================================================
// INPUTS - MANUAL ZONES
// ============================================================================
supply_top = input.float(0.0, "Supply Zone Top", group="Manual Zones")
supply_bottom = input.float(0.0, "Supply Zone Bottom", group="Manual Zones")
clear_supply = input.bool(false, "Disable Supply Zone", group="Manual Zones", tooltip="Check to temporarily disable supply zone without clearing values")

demand_top = input.float(0.0, "Demand Zone Top", group="Manual Zones")
demand_bottom = input.float(0.0, "Demand Zone Bottom", group="Manual Zones")
clear_demand = input.bool(false, "Disable Demand Zone", group="Manual Zones", tooltip="Check to temporarily disable demand zone without clearing values")

show_zones = input.bool(true, "Show Zones", group="Manual Zones", tooltip="Show/hide zone boxes on chart")

// ============================================================================
// INPUTS - TRADING WINDOW
// ============================================================================
trading_start_hour = input.int(9, "Trading Start Hour", minval=0, maxval=23, group="Trading Window", tooltip="Hour to start trading (NY time)")
trading_start_minute = input.int(30, "Trading Start Minute", minval=0, maxval=59, group="Trading Window", tooltip="Minute to start trading (NY time)")
trading_end_hour = input.int(16, "Trading End Hour", minval=0, maxval=23, group="Trading Window", tooltip="Hour to end trading (NY time)")
trading_end_minute = input.int(45, "Trading End Minute", minval=0, maxval=59, group="Trading Window", tooltip="Minute to end trading (NY time)")

// ============================================================================
// INPUTS - TRADE SETTINGS
// ============================================================================
risk_per_trade = input.float(500.0, "Risk Per Trade ($)", minval=1.0, group="Trade Settings", tooltip="Dollar amount to risk per trade")
max_setup_bars = input.int(100, "Max Setup Age (bars)", minval=1, group="Trade Settings", tooltip="Maximum number of bars before setup is invalidated")
setup_timeout_bars = input.int(30, "Setup Timeout (bars)", minval=1, group="Trade Settings", tooltip="Invalidate setup after this many bars if no entry signal triggers")
entry_timeout_bars = input.int(20, "Entry Timeout (bars)", minval=1, group="Trade Settings", tooltip="Invalidate entry signal after this many bars if trade doesn't execute")
grace_ticks = input.float(0.0, "Grace Ticks (SL Padding)", minval=0.0, step=0.25, group="Trade Settings", tooltip="Add extra ticks to stop loss for safety margin (maintains 2:1 RR)")
use_trailing_stop = input.bool(true, "Enable Trailing Stop at TP", group="Trade Settings", tooltip="At TP: close 50%, move SL to breakeven+tick, trail remaining 50%")
trailing_atr_multiplier = input.float(2.0, "Trailing Stop ATR Multiplier", minval=0.5, step=0.5, group="Trade Settings", tooltip="ATR multiplier for trailing stop distance")
trailing_atr_length = input.int(14, "ATR Length for Trailing", minval=1, group="Trade Settings", tooltip="Period for ATR calculation")

// ============================================================================
// INPUTS - ENTRY STRATEGIES (can enable multiple)
// ============================================================================
use_mss_ob = input.bool(true, "MSS OB", group="Entry Strategies", tooltip="Market Structure Shift Order Block - enters when price crosses opposite fractal level")
use_bpr_fvg = input.bool(false, "Balanced Price Range FVG", group="Entry Strategies", tooltip="Fair Value Gap within balanced price range")
bpr_fvg_min_ticks = input.float(2.0, "BPR FVG Min Size (ticks)", minval=0.0, step=0.25, group="Entry Strategies", tooltip="Minimum FVG size in ticks - smaller FVGs will be ignored")
use_inverted_fvg = input.bool(false, "Inverted FVG", group="Entry Strategies", tooltip="Inverted Fair Value Gap entry")
use_breaker_block = input.bool(false, "Breaker Block", group="Entry Strategies", tooltip="Breaker Block entry pattern")

// ============================================================================
// INPUTS - DEBUG
// ============================================================================
debug_mode = input.bool(false, "Debug Mode", group="Debug", tooltip="Show debug labels on chart (FVG counters, etc.)")

// ============================================================================
// ZONE DETECTION
// ============================================================================
// Apply clear flags - if clear is checked, treat zone as not configured
bool supply_configured = not clear_supply and supply_top > 0 and supply_bottom > 0 and supply_top > supply_bottom
bool demand_configured = not clear_demand and demand_top > 0 and demand_bottom > 0 and demand_top > demand_bottom

// Check if candle touches zone (high/low overlap with zone range)
// Uses real-time high/low so it triggers immediately when zone is touched
bool in_supply = supply_configured and not (low > supply_top or high < supply_bottom)
bool in_demand = demand_configured and not (low > demand_top or high < demand_bottom)

// ============================================================================
// TRADING WINDOW CHECK
// ============================================================================
// Convert current time to minutes since midnight for easier comparison
int current_time_minutes = hour(time, "America/New_York") * 60 + minute(time, "America/New_York")
int trading_start_minutes = trading_start_hour * 60 + trading_start_minute
int trading_end_minutes = trading_end_hour * 60 + trading_end_minute

// Check if we're within trading window
bool in_trading_window = current_time_minutes >= trading_start_minutes and current_time_minutes <= trading_end_minutes

// Shade non-trading hours with light grey background
bgcolor(not in_trading_window ? color.new(color.gray, 90) : na, title="Non-Trading Hours")


// ============================================================================
// SESSION HIGH/LOW TRACKING
// ============================================================================
// Session times (America/New_York):
// - Asian: 20:00 - 00:00 (previous day 8pm to midnight)
// - London: 03:00 - 12:00
// - Previous Day: 00:00 - 00:00 (full previous trading day)

// Track session highs and lows
var float asian_high = na
var float asian_low = na
var float london_high = na
var float london_low = na
var float prev_day_high = na
var float prev_day_low = na

// Track if sessions have been crossed (invalidated)
var bool asian_high_crossed = false
var bool asian_low_crossed = false
var bool london_high_crossed = false
var bool london_low_crossed = false
var bool prev_day_high_crossed = false
var bool prev_day_low_crossed = false

// Track lines for visual display
var line asian_high_line = na
var line asian_low_line = na
var line london_high_line = na
var line london_low_line = na
var line prev_day_high_line = na
var line prev_day_low_line = na

// Get current time
int hour_et = hour(time, "America/New_York")
int day_of_month = dayofmonth(time, "America/New_York")

// Track session high/low during their respective periods
// Asian session: 20:00 - 00:00 (8pm to midnight)
bool in_asian_session = hour_et >= 20 or hour_et < 0
if in_asian_session
    if na(asian_high) or high > asian_high
        asian_high := high
    if na(asian_low) or low < asian_low
        asian_low := low

        // do NOT reset asian hi/lo at NY midnight. instead of resetting at midnight, reset at next asian session
else if hour_et == 0 and minute(time, "America/New_York") == 0
    // Reset at midnight (start of new day)
    asian_high := na
    asian_low := na
    asian_high_crossed := false
    asian_low_crossed := false

// London session: 03:00 - 12:00
bool in_london_session = hour_et >= 3 and hour_et < 12
if in_london_session
    if na(london_high) or high > london_high
        london_high := high
    if na(london_low) or low < london_low
        london_low := low
else if hour_et == 3 and minute(time, "America/New_York") == 0
    // Reset at London open
    london_high := na
    london_low := na
    london_high_crossed := false
    london_low_crossed := false

// Previous Day high/low: track full previous day, reset at midnight
var float temp_day_high = na
var float temp_day_low = na
var int last_tracked_day = na

if barstate.isnew
    int current_day = dayofmonth(time, "America/New_York")

    // At start of new day (midnight ET), save yesterday's high/low as prev_day
    if not na(last_tracked_day) and current_day != last_tracked_day
        prev_day_high := temp_day_high
        prev_day_low := temp_day_low
        prev_day_high_crossed := false
        prev_day_low_crossed := false

        // Reset temp tracking for new day
        temp_day_high := high
        temp_day_low := low
    else
        // Continue tracking current day's high/low
        if na(temp_day_high) or high > temp_day_high
            temp_day_high := high
        if na(temp_day_low) or low < temp_day_low
            temp_day_low := low

    last_tracked_day := current_day

// Check for crosses and invalidate levels
if not asian_high_crossed and not na(asian_high) and high >= asian_high
    asian_high_crossed := true
if not asian_low_crossed and not na(asian_low) and low <= asian_low
    asian_low_crossed := true

if not london_high_crossed and not na(london_high) and high >= london_high
    london_high_crossed := true
if not london_low_crossed and not na(london_low) and low <= london_low
    london_low_crossed := true

if not prev_day_high_crossed and not na(prev_day_high) and high >= prev_day_high
    prev_day_high_crossed := true
if not prev_day_low_crossed and not na(prev_day_low) and low <= prev_day_low
    prev_day_low_crossed := true

// Session level lines removed - keep it simple

// ============================================================================
// ZONE VISUALIZATION - Draw zones during trading window on current day
// ============================================================================
// Get current time info
int current_hour = hour(time, "America/New_York")
int current_minute = minute(time, "America/New_York")
bool is_new_day = ta.change(dayofmonth(time, "America/New_York")) != 0

// Track zone boxes
var box supply_zone_box = na
var box demand_zone_box = na
var int zone_start_bar = na

// At trading window start, create new zone boxes for the day
// Create boxes when entering trading window on a new day OR if boxes don't exist yet
bool at_trading_start = current_hour == trading_start_hour and current_minute == trading_start_minute
bool should_create_boxes = at_trading_start and (is_new_day or na(supply_zone_box) or na(demand_zone_box))

if should_create_boxes
    zone_start_bar := bar_index

    // Delete old boxes
    if not na(supply_zone_box)
        box.delete(supply_zone_box)
    if not na(demand_zone_box)
        box.delete(demand_zone_box)

    // Create supply zone box (only if show_zones is enabled)
    if show_zones and supply_configured
        supply_zone_box := box.new(bar_index, supply_top, bar_index + 1, supply_bottom,
                                   border_color=color.red,
                                   bgcolor=color.new(color.red, 90),
                                   border_width=1,
                                   extend=extend.none)

    // Create demand zone box (only if show_zones is enabled)
    if show_zones and demand_configured
        demand_zone_box := box.new(bar_index, demand_top, bar_index + 1, demand_bottom,
                                   border_color=color.blue,
                                   bgcolor=color.new(color.blue, 90),
                                   border_width=1,
                                   extend=extend.none)

// Update zone boxes to extend to current bar + 2 bars into future (within trading window)
if show_zones and in_trading_window
    if supply_configured and not na(supply_zone_box)
        box.set_right(supply_zone_box, bar_index + 3)
    if demand_configured and not na(demand_zone_box)
        box.set_right(demand_zone_box, bar_index + 3)
else if show_zones and current_hour == trading_end_hour and current_minute == trading_end_minute
    // Stop extending at trading window end
    if supply_configured and not na(supply_zone_box)
        box.set_right(supply_zone_box, bar_index)
    if demand_configured and not na(demand_zone_box)
        box.set_right(demand_zone_box, bar_index)

// If show_zones is disabled OR outside trading window, delete any existing boxes
if not show_zones or not in_trading_window
    if not na(supply_zone_box)
        box.delete(supply_zone_box)
        supply_zone_box := na
    if not na(demand_zone_box)
        box.delete(demand_zone_box)
        demand_zone_box := na

// Track zone entry - stays true while in zone OR while setup is active
var bool supply_triggered = false
var bool demand_triggered = false
var int supply_trigger_bar = -1
var int demand_trigger_bar = -1

// Track deepest penetration into zones (resets on fresh entry)
var float demand_lowest_low = na
var float supply_highest_high = na

// Track if we're completely outside both zones (ready to reset)
var bool was_outside_zones = true

// Track if ENG OB is active (declare early so it can be used in zone logic)
var bool eng_ob_active = false
var bool eng_ob_is_bullish = false
var float eng_ob_deepest_level = na
var int eng_ob_bar_index = na
var float eng_ob_candle_high = na
var float eng_ob_candle_low = na
var box eng_ob_box = na  // Yellow box around ENG OB candle for visual debug
var label eng_ob_diamond = na  // Black diamond marker for ENG OB detection

// Track ENTRY SIGNALS - generic for all entry strategies
var bool entry_signal_active = false  // Any entry strategy has triggered
var string active_entry_strategy = ""  // Which strategy triggered (for display/debug)
var bool entry_is_bullish = false  // Trade direction: true = long, false = short
var float entry_price = na  // Entry price (regardless of strategy)
var float entry_tp = na     // Take profit level
var float entry_sl = na     // Stop loss level
var int entry_signal_bar_index = na  // Bar index when entry signal triggered (for timeout tracking)

// Track MSS OB specific state (one of four entry strategies)
var float target_fractal_level_mss = na  // Fractal level for MSS OB strategy
var int mss_ob_confirmed_bar = na  // Bar index when MSS OB was confirmed (for icon plotting)

// Track latest fractals in real-time (for MSS OB strategy)
var float latest_bullish_fractal = na  // Most recent bullish fractal low
var float latest_bearish_fractal = na  // Most recent bearish fractal high

// Track BPR FVG specific state
var bool bpr_fvg_active = false  // BPR FVG has been detected
var bool bpr_fvg_is_bullish = false  // True = bullish FVG (in supply), False = bearish FVG (in demand)
var float bpr_fvg_top = na  // Top of the FVG
var float bpr_fvg_bottom = na  // Bottom of the FVG
var float bpr_fvg_invalidation_level = na  // Highest/lowest of 3-candle pattern for invalidation
var int bpr_fvg_bar_index = na  // Bar index where FVG was detected
var float bpr_fvg_candle_high = na  // High of the candle that created the FVG (for SL)
var float bpr_fvg_candle_low = na  // Low of the candle that created the FVG (for SL)
var box bpr_fvg_box = na  // Yellow box around FVG
var string bpr_fvg_invalidation_reason = ""  // Track why BPR FVG was cleared (for debugging)

// Track Inverted FVG specific state
var bool inv_fvg_active = false  // Inverted FVG has been detected (overlap found)
var bool inv_fvg_is_bullish = false  // Trade direction: true = long, false = short
var float inv_fvg_overlap_top = na  // Top of overlap zone (entry for bearish)
var float inv_fvg_overlap_bottom = na  // Bottom of overlap zone (entry for bullish)
var float inv_fvg_reversal_candle_high = na  // High of reversal FVG candle (for SL in bearish)
var float inv_fvg_reversal_candle_low = na  // Low of reversal FVG candle (for SL in bullish)
var int inv_fvg_bar_index = na  // Bar index where Inverted FVG was detected
var box inv_fvg_overlap_box = na  // Purple box for overlap visualization
var string inv_fvg_invalidation_reason = ""  // Track why Inverted FVG was cleared (for debugging)

// Track Breaker Block specific state
// TODO: Add Breaker Block variables when implementing

// Track TP/SL indicator boxes - use arrays to persist multiple boxes throughout the day
var array<box> daily_tp_boxes = array.new<box>()
var array<box> daily_sl_boxes = array.new<box>()
var box tp_box = na  // Current active TP box
var box sl_box = na  // Current active SL box

// Track if we've already entered a trade for this setup
var bool trade_entered = false

// Track trailing stop state
var bool tp_hit = false  // TP was hit, 50% closed, now trailing remaining 50%
var float breakeven_plus_tick = na  // Breakeven + 1 tick level (direction-aware)

// Track if limit order has been placed for current entry signal
var bool order_placed = false
var int order_placed_bar = -1  // Track which bar the order was placed on

// Track the bar on which the last trade exited (prevent same-bar re-entry)
var int last_exit_bar = -1

// Track bars to wait after exit before allowing new setups (cooldown period)
cooldown_bars = input.int(2, "Cooldown After Exit (bars)", minval=0, group="Trade Settings", tooltip="Number of bars to wait after trade exit before detecting new setups")

// ============================================================================
// DAILY PERFORMANCE TRACKING
// ============================================================================
var int today_trade_count = 0
var int today_wins = 0
var int today_losses = 0
var float today_pnl = 0.0
var int last_trade_day = na
var float last_position_entry = na  // Track entry price to calculate P&L

// Reset daily stats at midnight and clear old boxes at 20:00 (start of Asian session)
if barstate.isnew
    int current_day = dayofmonth(time, "America/New_York")
    int current_hour = hour(time, "America/New_York")
    int current_minute = minute(time, "America/New_York")

    // At midnight, reset daily stats
    if not na(last_trade_day) and current_day != last_trade_day
        today_trade_count := 0
        today_wins := 0
        today_losses := 0
        today_pnl := 0.0

    last_trade_day := current_day

// DEBUG: Track if clearing logic actually executes
// Reset to NO on every tick, then set to YES only when clearing runs
var string clearing_logic_ran = "NO - not executed"
clearing_logic_ran := "NO - not executed"

// CLEAR ALL SETUPS OUTSIDE TRADING WINDOW
// SIMPLIFIED: If we're outside trading hours, nuke EVERYTHING unconditionally
// No checks, no conditions - just clear it all
// IMPORTANT: This runs on EVERY TICK (not just barstate.isnew) for replay mode compatibility
if not in_trading_window
    // DEBUG: Mark that clearing logic is running
    clearing_logic_ran := "YES - EXECUTED!"

    // Close any open positions and cancel pending orders
    strategy.close_all()
    strategy.cancel_all()

    // Clear ENG OB state
    eng_ob_active := false
    if not na(eng_ob_diamond)
        label.delete(eng_ob_diamond)
        eng_ob_diamond := na
    eng_ob_is_bullish := false
    eng_ob_deepest_level := na
    eng_ob_bar_index := na
    eng_ob_candle_high := na
    eng_ob_candle_low := na
    target_fractal_level_mss := na

    // Delete ENG OB diamond marker
    if not na(eng_ob_diamond)
        label.delete(eng_ob_diamond)
        eng_ob_diamond := na
    mss_ob_confirmed_bar := na

    // Clear entry signals (all strategies)
    entry_signal_active := false
    active_entry_strategy := ""
    entry_is_bullish := false
    entry_price := na
    entry_tp := na
    entry_sl := na
    entry_signal_bar_index := na

    // Reset trade flags
    trade_entered := false
    order_placed := false
    order_placed_bar := -1

    // Reset trailing stop state
    tp_hit := false
    breakeven_plus_tick := na

    // Delete yellow box
    if not na(eng_ob_box)
        box.delete(eng_ob_box)
        eng_ob_box := na

    // Delete TP/SL boxes
    if not na(tp_box)
        box.delete(tp_box)
        tp_box := na
    if not na(sl_box)
        box.delete(sl_box)
        sl_box := na

    // Clear BPR FVG state
    if not na(bpr_fvg_box)
        box.delete(bpr_fvg_box)
        bpr_fvg_box := na
    bpr_fvg_active := false
    bpr_fvg_is_bullish := false
    bpr_fvg_top := na
    bpr_fvg_bottom := na
    bpr_fvg_invalidation_level := na
    bpr_fvg_bar_index := na
    bpr_fvg_candle_high := na
    bpr_fvg_candle_low := na
    bpr_fvg_invalidation_reason := "Outside trading window"

    // Clear Inverted FVG state
    if not na(inv_fvg_overlap_box)
        box.delete(inv_fvg_overlap_box)
        inv_fvg_overlap_box := na
    inv_fvg_active := false
    inv_fvg_is_bullish := false
    inv_fvg_overlap_top := na
    inv_fvg_overlap_bottom := na
    inv_fvg_reversal_candle_high := na
    inv_fvg_reversal_candle_low := na
    inv_fvg_bar_index := na
    inv_fvg_invalidation_reason := "Outside trading window"

// Track when trade enters
if entry_signal_active and not trade_entered and strategy.position_size != 0
    last_position_entry := strategy.position_avg_price

// Track when trade exits and calculate P&L using strategy's closed trade P&L
var int last_closed_trades = 0
int current_closed_trades = strategy.closedtrades

if current_closed_trades > last_closed_trades
    // A new trade just closed - get the P&L from the most recent closed trade
    float trade_pnl = strategy.closedtrades.profit(strategy.closedtrades - 1)

    // Update daily stats
    today_trade_count += 1
    today_pnl += trade_pnl

    if trade_pnl > 0
        today_wins += 1
    else
        today_losses += 1

    last_closed_trades := current_closed_trades

// ============================================================================
// FORCE CLOSE AT TRADING WINDOW END - TOP LEVEL (runs every bar)
// ============================================================================
int check_hour = hour(time, "America/New_York")
int check_minute = minute(time, "America/New_York")
int check_time_mins = check_hour * 60 + check_minute
int end_time_mins = trading_end_hour * 60 + trading_end_minute

// Check if we're past trading end time and have an open position
if check_time_mins >= end_time_mins and strategy.position_size != 0
    // FIRST cancel all pending orders (including TP/SL exits)
    strategy.cancel_all()

    // THEN close the position
    if strategy.position_size > 0
        strategy.close("Long", comment="EOD Close")
    else if strategy.position_size < 0
        strategy.close("Short", comment="EOD Close")

// Check if currently outside both zones
bool outside_both_zones = not in_supply and not in_demand

if barstate.isnew
    // Clear trigger only if it's been more than 1 bar since entry AND no active setup
    // This keeps supply_triggered/demand_triggered true while a setup is tracking
    bool has_supply_setup = (eng_ob_active and not eng_ob_is_bullish) or (bpr_fvg_active and bpr_fvg_is_bullish)
    bool has_demand_setup = (eng_ob_active and eng_ob_is_bullish) or (bpr_fvg_active and not bpr_fvg_is_bullish)

    if bar_index - supply_trigger_bar > 1 and not has_supply_setup
        supply_triggered := false
    if bar_index - demand_trigger_bar > 1 and not has_demand_setup
        demand_triggered := false

    // Track when we're outside both zones
    // Only set was_outside_zones if there's NO active ENG OB setup
    if outside_both_zones and not eng_ob_active
        was_outside_zones := true

if in_supply
    supply_triggered := true
    supply_trigger_bar := bar_index

    // Reset deepest on fresh entry after being outside
    if was_outside_zones
        supply_highest_high := high
        was_outside_zones := false
    // Otherwise, track highest high in supply zone
    else if na(supply_highest_high) or high > supply_highest_high
        supply_highest_high := high

if in_demand
    demand_triggered := true
    demand_trigger_bar := bar_index

    // Reset deepest on fresh entry after being outside
    if was_outside_zones
        demand_lowest_low := low
        was_outside_zones := false
    // Otherwise, track lowest low in demand zone
    else if na(demand_lowest_low) or low < demand_lowest_low
        demand_lowest_low := low

// ============================================================================
// SETUP FLOW AND INVALIDATION RULES
// ============================================================================
// FLOW:
// 1. When AOI is entered, show "IN AOI"
// 2. If price leaves AOI without an ENG OB, return to "-"
// 3. If ENG OB forms, black diamond appears, ENG OB shows checkmark
//    - AOI status changes to "ACTIVE" (setup is now active)
//    - ENG OB stays checked until invalidated
// 4. Look BACKWARD for first opposite LTF fractal candle, place debug diamond above it
// 5. If price crosses fractal high (bullish) or low (bearish), MSS OB is formed
//    - Checkmark MSS OB row
//    - Draw entry OB from lowest candle in ENG OB setup (use that candle's high and low)
//    - Add debug row showing entry window
//    - Status changes to "AWAITING MSS OB ENTRY"
//
// INVALIDATION RULES:
// - ENG OB invalidated: if price goes deeper into zone than ENG OB candle before crossing fractal level (step 5)
// - MSS OB invalidated: if price touches opposite color zone (may add more criteria later)
//
// ============================================================================
// ENGULFING ORDER BLOCK DETECTION
// ============================================================================
bool is_bullish_engulfing = false
bool is_bearish_engulfing = false

// Only check for engulfing when in an AOI, within trading window, and NO active ENG OB setup
// This prevents the detection from running every bar and invalidating itself
if demand_triggered and bar_index > 0 and in_trading_window and not eng_ob_active
    // Bullish engulfing: current candle close engulfs previous candle body
    bool current_bullish = close > open
    bool prev_bearish = close[1] < open[1]
    bool engulfs_body = close >= open[1]

    // Check if current or previous candle made the deepest low FOR THIS ZONE ENTRY
    bool is_deepest = low <= demand_lowest_low or low[1] <= demand_lowest_low

    is_bullish_engulfing := current_bullish and prev_bearish and engulfs_body and is_deepest

if supply_triggered and bar_index > 0 and in_trading_window and not eng_ob_active
    // Bearish engulfing: current candle close engulfs previous candle body
    bool current_bearish = close < open
    bool prev_bullish = close[1] > open[1]
    bool engulfs_body = close <= open[1]

    // Check if current or previous candle made the highest high FOR THIS ZONE ENTRY
    bool is_deepest = high >= supply_highest_high or high[1] >= supply_highest_high

    is_bearish_engulfing := current_bearish and prev_bullish and engulfs_body and is_deepest

bool engulfing_ob_detected = is_bullish_engulfing or is_bearish_engulfing

// NOTE: Engulfing detection only runs when NO active ENG OB exists
// This prevents the detection from running every bar and invalidating itself
// Once ENG OB is detected, the setup remains active until invalidated or trade exits

// INVALIDATION: Setup expires after max_setup_bars (only if not in trade) or at trading end time
if eng_ob_active and not na(eng_ob_bar_index)
    bool should_invalidate_timeout = false
    string timeout_reason = ""

    // Check if setup has exceeded max bars (ONLY if not in a trade)
    if not trade_entered
        int bars_since_setup = bar_index - eng_ob_bar_index
        if bars_since_setup >= max_setup_bars
            should_invalidate_timeout := true
            timeout_reason := "Max bars (" + str.tostring(max_setup_bars) + ")"

    // Check if it's past trading end time (applies to ALL setups, including active trades)
    int current_hour = hour(time, "America/New_York")
    int current_minute = minute(time, "America/New_York")
    int current_time_mins = current_hour * 60 + current_minute
    int end_time_mins = trading_end_hour * 60 + trading_end_minute

    if current_time_mins >= end_time_mins
        should_invalidate_timeout := true
        string end_time_str = str.tostring(trading_end_hour) + ":" + (trading_end_minute < 10 ? "0" : "") + str.tostring(trading_end_minute)
        timeout_reason := timeout_reason == "" ? end_time_str + " NY time" : timeout_reason + " + " + end_time_str

    if should_invalidate_timeout
        label.new(bar_index, eng_ob_is_bullish ? low : high, "âŒ TIMEOUT\n" + timeout_reason,
                 color=color.purple, textcolor=color.white,
                 style=eng_ob_is_bullish ? label.style_label_up : label.style_label_down,
                 size=size.small)

        // Close any open positions and cancel pending orders
        strategy.close_all()
        strategy.cancel_all()

        eng_ob_active := false
        if not na(eng_ob_diamond)
            label.delete(eng_ob_diamond)
            eng_ob_diamond := na
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level_mss := na
        mss_ob_confirmed_bar := na

        // Clear entry signals (all strategies)
        entry_signal_active := false
        active_entry_strategy := ""
        entry_price := na
        entry_tp := na
        entry_sl := na

        // Reset trade flag
        trade_entered := false

        // Clear BPR FVG state (may be active alongside ENG OB)
        bpr_fvg_active := false
        bpr_fvg_is_bullish := false
        bpr_fvg_top := na
        bpr_fvg_bottom := na
        bpr_fvg_invalidation_level := na
        bpr_fvg_bar_index := na
        bpr_fvg_candle_high := na
        bpr_fvg_candle_low := na
        if not na(bpr_fvg_box)
            box.delete(bpr_fvg_box)
            bpr_fvg_box := na

        // Clear Inverted FVG state (may be active alongside ENG OB)
        inv_fvg_active := false
        inv_fvg_is_bullish := false
        inv_fvg_overlap_top := na
        inv_fvg_overlap_bottom := na
        inv_fvg_reversal_candle_high := na
        inv_fvg_reversal_candle_low := na
        inv_fvg_bar_index := na
        if not na(inv_fvg_overlap_box)
            box.delete(inv_fvg_overlap_box)
            inv_fvg_overlap_box := na

        // Delete yellow box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

        // Delete TP/SL boxes
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

// INVALIDATION: Clear setup when zones are disabled
// Only invalidate if the disabled zone MATCHES the setup's zone
// Bullish setup (from demand) only invalidated by clear_demand
// Bearish setup (from supply) only invalidated by clear_supply
if eng_ob_active
    bool should_invalidate = false

    if eng_ob_is_bullish and clear_demand
        // Bullish setup invalidated by disabling demand zone
        should_invalidate := true
    else if not eng_ob_is_bullish and clear_supply
        // Bearish setup invalidated by disabling supply zone
        should_invalidate := true

    if should_invalidate
        eng_ob_active := false
        if not na(eng_ob_diamond)
            label.delete(eng_ob_diamond)
            eng_ob_diamond := na
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level_mss := na
        mss_ob_confirmed_bar := na

        // Clear entry signals (all strategies)
        entry_signal_active := false
        active_entry_strategy := ""
        entry_price := na
        entry_tp := na
        entry_sl := na

        // Clear BPR FVG state (may be active alongside ENG OB)
        bpr_fvg_active := false
        bpr_fvg_is_bullish := false
        bpr_fvg_top := na
        bpr_fvg_bottom := na
        bpr_fvg_invalidation_level := na
        bpr_fvg_bar_index := na
        bpr_fvg_candle_high := na
        bpr_fvg_candle_low := na
        if not na(bpr_fvg_box)
            box.delete(bpr_fvg_box)
            bpr_fvg_box := na

        // Clear Inverted FVG state (may be active alongside ENG OB)
        inv_fvg_active := false
        inv_fvg_is_bullish := false
        inv_fvg_overlap_top := na
        inv_fvg_overlap_bottom := na
        inv_fvg_reversal_candle_high := na
        inv_fvg_reversal_candle_low := na
        inv_fvg_bar_index := na
        if not na(inv_fvg_overlap_box)
            box.delete(inv_fvg_overlap_box)
            inv_fvg_overlap_box := na

        // Delete yellow box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

        // Delete TP/SL boxes
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

// INVALIDATION: Clear BPR FVG when zones are disabled (INDEPENDENT of ENG OB)
if bpr_fvg_active
    bool should_invalidate_bpr = false

    if bpr_fvg_is_bullish and clear_supply
        // Bullish FVG (bearish trade) invalidated by disabling supply zone
        should_invalidate_bpr := true
    else if not bpr_fvg_is_bullish and clear_demand
        // Bearish FVG (bullish trade) invalidated by disabling demand zone
        should_invalidate_bpr := true

    if should_invalidate_bpr
        bpr_fvg_active := false
        bpr_fvg_is_bullish := false
        bpr_fvg_top := na
        bpr_fvg_bottom := na
        bpr_fvg_invalidation_level := na
        bpr_fvg_bar_index := na
        bpr_fvg_candle_high := na
        bpr_fvg_candle_low := na
        bpr_fvg_invalidation_reason := "Zone disabled"
        if not na(bpr_fvg_box)
            box.delete(bpr_fvg_box)
            bpr_fvg_box := na

        // If BPR FVG had an active entry signal, clear it
        if entry_signal_active and active_entry_strategy == "BPR FVG"
            entry_signal_active := false
            active_entry_strategy := ""
            entry_price := na
            entry_tp := na
            entry_sl := na
            entry_signal_bar_index := na
            order_placed := false

            if not na(tp_box)
                box.delete(tp_box)
                tp_box := na
            if not na(sl_box)
                box.delete(sl_box)
                sl_box := na

// INVALIDATION: Clear Inverted FVG when zones are disabled (INDEPENDENT of ENG OB)
if inv_fvg_active
    bool should_invalidate_inv = false

    if inv_fvg_is_bullish and clear_demand
        // Bullish Inverted FVG invalidated by disabling demand zone
        should_invalidate_inv := true
    else if not inv_fvg_is_bullish and clear_supply
        // Bearish Inverted FVG invalidated by disabling supply zone
        should_invalidate_inv := true

    if should_invalidate_inv
        inv_fvg_active := false
        inv_fvg_is_bullish := false
        inv_fvg_overlap_top := na
        inv_fvg_overlap_bottom := na
        inv_fvg_reversal_candle_high := na
        inv_fvg_reversal_candle_low := na
        inv_fvg_bar_index := na
        inv_fvg_invalidation_reason := "Zone disabled"
        if not na(inv_fvg_overlap_box)
            box.delete(inv_fvg_overlap_box)
            inv_fvg_overlap_box := na

        // If Inverted FVG had an active entry signal, clear it
        if entry_signal_active and active_entry_strategy == "Inverted FVG"
            entry_signal_active := false
            active_entry_strategy := ""
            entry_price := na
            entry_tp := na
            entry_sl := na
            entry_signal_bar_index := na
            order_placed := false

            if not na(tp_box)
                box.delete(tp_box)
                tp_box := na
            if not na(sl_box)
                box.delete(sl_box)
                sl_box := na

// INVALIDATION: Clear setup when entering the OPPOSITE zone (fresh zone entry)
// Bullish setup (from demand) invalidated by entering supply zone
// Bearish setup (from supply) invalidated by entering demand zone
if barstate.isnew and was_outside_zones
    if eng_ob_active and eng_ob_is_bullish and in_supply
        // Bullish setup invalidated by entering supply zone
        eng_ob_active := false
        if not na(eng_ob_diamond)
            label.delete(eng_ob_diamond)
            eng_ob_diamond := na
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level_mss := na
        mss_ob_confirmed_bar := na

        // Clear entry signals (all strategies)
        entry_signal_active := false
        active_entry_strategy := ""
        entry_price := na
        entry_tp := na
        entry_sl := na

        // Clear BPR FVG state (may be active alongside ENG OB)
        bpr_fvg_active := false
        bpr_fvg_is_bullish := false
        bpr_fvg_top := na
        bpr_fvg_bottom := na
        bpr_fvg_invalidation_level := na
        bpr_fvg_bar_index := na
        bpr_fvg_candle_high := na
        bpr_fvg_candle_low := na
        if not na(bpr_fvg_box)
            box.delete(bpr_fvg_box)
            bpr_fvg_box := na

        // Clear Inverted FVG state (may be active alongside ENG OB)
        inv_fvg_active := false
        inv_fvg_is_bullish := false
        inv_fvg_overlap_top := na
        inv_fvg_overlap_bottom := na
        inv_fvg_reversal_candle_high := na
        inv_fvg_reversal_candle_low := na
        inv_fvg_bar_index := na
        if not na(inv_fvg_overlap_box)
            box.delete(inv_fvg_overlap_box)
            inv_fvg_overlap_box := na

        // Delete yellow box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

        // Delete TP/SL boxes
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

    else if eng_ob_active and not eng_ob_is_bullish and in_demand
        // Bearish setup invalidated by entering demand zone
        eng_ob_active := false
        if not na(eng_ob_diamond)
            label.delete(eng_ob_diamond)
            eng_ob_diamond := na
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level_mss := na
        mss_ob_confirmed_bar := na

        // Clear entry signals (all strategies)
        entry_signal_active := false
        active_entry_strategy := ""
        entry_price := na
        entry_tp := na
        entry_sl := na

        // Clear BPR FVG state (may be active alongside ENG OB)
        bpr_fvg_active := false
        bpr_fvg_is_bullish := false
        bpr_fvg_top := na
        bpr_fvg_bottom := na
        bpr_fvg_invalidation_level := na
        bpr_fvg_bar_index := na
        bpr_fvg_candle_high := na
        bpr_fvg_candle_low := na
        if not na(bpr_fvg_box)
            box.delete(bpr_fvg_box)
            bpr_fvg_box := na

        // Clear Inverted FVG state (may be active alongside ENG OB)
        inv_fvg_active := false
        inv_fvg_is_bullish := false
        inv_fvg_overlap_top := na
        inv_fvg_overlap_bottom := na
        inv_fvg_reversal_candle_high := na
        inv_fvg_reversal_candle_low := na
        inv_fvg_bar_index := na
        if not na(inv_fvg_overlap_box)
            box.delete(inv_fvg_overlap_box)
            inv_fvg_overlap_box := na

        // Delete yellow box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

        // Delete TP/SL boxes
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

// INVALIDATION: Clear BPR FVG when entering OPPOSITE zone (INDEPENDENT of ENG OB)
if barstate.isnew and was_outside_zones and bpr_fvg_active
    bool should_invalidate_bpr_zone = false

    if bpr_fvg_is_bullish and in_demand
        // Bullish FVG (bearish trade) invalidated by entering demand zone
        should_invalidate_bpr_zone := true
    else if not bpr_fvg_is_bullish and in_supply
        // Bearish FVG (bullish trade) invalidated by entering supply zone
        should_invalidate_bpr_zone := true

    if should_invalidate_bpr_zone
        bpr_fvg_active := false
        bpr_fvg_is_bullish := false
        bpr_fvg_top := na
        bpr_fvg_bottom := na
        bpr_fvg_invalidation_level := na
        bpr_fvg_bar_index := na
        bpr_fvg_candle_high := na
        bpr_fvg_candle_low := na
        bpr_fvg_invalidation_reason := "Entered opposite zone"
        if not na(bpr_fvg_box)
            box.delete(bpr_fvg_box)
            bpr_fvg_box := na

        // If BPR FVG had an active entry signal, clear it
        if entry_signal_active and active_entry_strategy == "BPR FVG"
            entry_signal_active := false
            active_entry_strategy := ""
            entry_price := na
            entry_tp := na
            entry_sl := na
            entry_signal_bar_index := na
            order_placed := false

            if not na(tp_box)
                box.delete(tp_box)
                tp_box := na
            if not na(sl_box)
                box.delete(sl_box)
                sl_box := na

// INVALIDATION: Clear Inverted FVG when entering OPPOSITE zone (INDEPENDENT of ENG OB)
if barstate.isnew and was_outside_zones and inv_fvg_active
    bool should_invalidate_inv_zone = false

    if inv_fvg_is_bullish and in_supply
        // Bullish Inverted FVG invalidated by entering supply zone
        should_invalidate_inv_zone := true
    else if not inv_fvg_is_bullish and in_demand
        // Bearish Inverted FVG invalidated by entering demand zone
        should_invalidate_inv_zone := true

    if should_invalidate_inv_zone
        inv_fvg_active := false
        inv_fvg_is_bullish := false
        inv_fvg_overlap_top := na
        inv_fvg_overlap_bottom := na
        inv_fvg_reversal_candle_high := na
        inv_fvg_reversal_candle_low := na
        inv_fvg_bar_index := na
        inv_fvg_invalidation_reason := "Entered opposite zone"
        if not na(inv_fvg_overlap_box)
            box.delete(inv_fvg_overlap_box)
            inv_fvg_overlap_box := na

        // If Inverted FVG had an active entry signal, clear it
        if entry_signal_active and active_entry_strategy == "Inverted FVG"
            entry_signal_active := false
            active_entry_strategy := ""
            entry_price := na
            entry_tp := na
            entry_sl := na
            entry_signal_bar_index := na
            order_placed := false

            if not na(tp_box)
                box.delete(tp_box)
                tp_box := na
            if not na(sl_box)
                box.delete(sl_box)
                sl_box := na

// When ENG OB forms, activate it and record deepest level + capture the OB candle
if is_bullish_engulfing
    eng_ob_active := true
    eng_ob_is_bullish := true
    eng_ob_deepest_level := demand_lowest_low
    target_fractal_level_mss := na
    mss_ob_confirmed_bar := na  // Reset fractal search for new ENG OB

    // Determine which candle is the actual OB candle (the one that made the deepest low)
    // For bullish engulfing, the OB candle is whichever made the lowest low
    if low <= low[1]
        // Current candle made the deepest low - it's the OB candle
        eng_ob_bar_index := bar_index
        eng_ob_candle_high := high
        eng_ob_candle_low := low
    else
        // Previous candle made the deepest low - it's the OB candle
        eng_ob_bar_index := bar_index - 1
        eng_ob_candle_high := high[1]
        eng_ob_candle_low := low[1]

else if is_bearish_engulfing
    eng_ob_active := true
    eng_ob_is_bullish := false
    eng_ob_deepest_level := supply_highest_high
    target_fractal_level_mss := na
    mss_ob_confirmed_bar := na  // Reset fractal search for new ENG OB

    // Determine which candle is the actual OB candle (the one that made the highest high)
    // For bearish engulfing, the OB candle is whichever made the highest high
    if high >= high[1]
        // Current candle made the highest high - it's the OB candle
        eng_ob_bar_index := bar_index
        eng_ob_candle_high := high
        eng_ob_candle_low := low
    else
        // Previous candle made the highest high - it's the OB candle
        eng_ob_bar_index := bar_index - 1
        eng_ob_candle_high := high[1]
        eng_ob_candle_low := low[1]

// INVALIDATION: Price goes deeper into zone than ENG OB candle (before MSS OB is crossed)
// Only invalidate if price is IN the zone and goes deeper than the OB candle
// TODO: Once MSS OB crossing detection is implemented, add condition to stop invalidation after cross
if eng_ob_active
    if eng_ob_is_bullish and demand_triggered and not na(eng_ob_candle_low)
        // Bullish setup invalidated if price makes new lower low than ENG OB candle's low WHILE IN DEMAND ZONE
        if low < eng_ob_candle_low
            eng_ob_active := false
            if not na(eng_ob_diamond)
                label.delete(eng_ob_diamond)
                eng_ob_diamond := na
            eng_ob_is_bullish := false
            eng_ob_deepest_level := na
            eng_ob_bar_index := na
            eng_ob_candle_high := na
            eng_ob_candle_low := na
            target_fractal_level_mss := na
            mss_ob_confirmed_bar := na

            // Clear entry signals (all strategies)
            entry_signal_active := false
            active_entry_strategy := ""
            entry_price := na
            entry_tp := na
            entry_sl := na

            // Delete the yellow box when invalidated
            if not na(eng_ob_box)
                box.delete(eng_ob_box)
                eng_ob_box := na

            // Delete TP/SL boxes
            if not na(tp_box)
                box.delete(tp_box)
                tp_box := na
            if not na(sl_box)
                box.delete(sl_box)
                sl_box := na

    else if not eng_ob_is_bullish and supply_triggered and not na(eng_ob_candle_high)
        // Bearish setup invalidated if price makes new higher high than ENG OB candle's high WHILE IN SUPPLY ZONE
        if high > eng_ob_candle_high
            eng_ob_active := false
            if not na(eng_ob_diamond)
                label.delete(eng_ob_diamond)
                eng_ob_diamond := na
            eng_ob_is_bullish := false
            eng_ob_deepest_level := na
            eng_ob_bar_index := na
            eng_ob_candle_high := na
            eng_ob_candle_low := na
            target_fractal_level_mss := na
            mss_ob_confirmed_bar := na

            // Clear entry signals (all strategies)
            entry_signal_active := false
            active_entry_strategy := ""
            entry_price := na
            entry_tp := na
            entry_sl := na

            // Delete the yellow box when invalidated
            if not na(eng_ob_box)
                box.delete(eng_ob_box)
                eng_ob_box := na

            // Delete TP/SL boxes
            if not na(tp_box)
                box.delete(tp_box)
                tp_box := na
            if not na(sl_box)
                box.delete(sl_box)
                sl_box := na

// INVALIDATION: Entry signal invalidated when price reaches opposite zone
// This invalidation applies even if we haven't left both zones
// Bullish entry invalidated by touching supply zone
// Bearish entry invalidated by touching demand zone
if entry_signal_active
    bool should_invalidate_entry = false

    // Use entry_is_bullish (generic for all strategies) instead of eng_ob_is_bullish (ENG OB specific)
    if entry_is_bullish and in_supply
        // Bullish entry invalidated by reaching supply zone
        should_invalidate_entry := true
    else if not entry_is_bullish and in_demand
        // Bearish entry invalidated by reaching demand zone
        should_invalidate_entry := true

    if should_invalidate_entry
        // Clear strategy-specific state based on which strategy placed the order
        if active_entry_strategy == "MSS OB"
            // MSS OB strategy - clear ENG OB state
            eng_ob_active := false
            if not na(eng_ob_diamond)
                label.delete(eng_ob_diamond)
                eng_ob_diamond := na
            eng_ob_is_bullish := false
            eng_ob_deepest_level := na
            eng_ob_bar_index := na
            eng_ob_candle_high := na
            eng_ob_candle_low := na
            target_fractal_level_mss := na
            mss_ob_confirmed_bar := na

            // Delete the ENG OB box
            if not na(eng_ob_box)
                box.delete(eng_ob_box)
                eng_ob_box := na

        else if active_entry_strategy == "BPR FVG"
            // BPR FVG strategy - clear BPR FVG state
            bpr_fvg_active := false
            bpr_fvg_is_bullish := false
            bpr_fvg_top := na
            bpr_fvg_bottom := na
            bpr_fvg_invalidation_level := na
            bpr_fvg_bar_index := na
            bpr_fvg_candle_high := na
            bpr_fvg_candle_low := na
            bpr_fvg_invalidation_reason := "Opposite zone reached"

            // Delete the BPR FVG box
            if not na(bpr_fvg_box)
                box.delete(bpr_fvg_box)
                bpr_fvg_box := na

        else if active_entry_strategy == "Inverted FVG"
            // Inverted FVG strategy - clear both BPR FVG and Inverted FVG state
            bpr_fvg_active := false
            bpr_fvg_is_bullish := false
            bpr_fvg_top := na
            bpr_fvg_bottom := na
            bpr_fvg_invalidation_level := na
            bpr_fvg_bar_index := na
            bpr_fvg_candle_high := na
            bpr_fvg_candle_low := na
            bpr_fvg_invalidation_reason := "Opposite zone reached"

            inv_fvg_active := false
            inv_fvg_is_bullish := false
            inv_fvg_overlap_top := na
            inv_fvg_overlap_bottom := na
            inv_fvg_reversal_candle_high := na
            inv_fvg_reversal_candle_low := na
            inv_fvg_bar_index := na
            inv_fvg_invalidation_reason := "Opposite zone reached"

            // Delete the BPR FVG box and Inverted FVG overlap box
            if not na(bpr_fvg_box)
                box.delete(bpr_fvg_box)
                bpr_fvg_box := na
            if not na(inv_fvg_overlap_box)
                box.delete(inv_fvg_overlap_box)
                inv_fvg_overlap_box := na

        else if active_entry_strategy == "Breaker Block"
            // Breaker Block strategy - clear ENG OB state
            eng_ob_active := false
            if not na(eng_ob_diamond)
                label.delete(eng_ob_diamond)
                eng_ob_diamond := na
            eng_ob_is_bullish := false
            eng_ob_deepest_level := na
            eng_ob_bar_index := na
            eng_ob_candle_high := na
            eng_ob_candle_low := na
            target_fractal_level_mss := na
            mss_ob_confirmed_bar := na

            // Delete the ENG OB box
            if not na(eng_ob_box)
                box.delete(eng_ob_box)
                eng_ob_box := na

        // Clear entry signals (all strategies)
        entry_signal_active := false
        active_entry_strategy := ""
        entry_price := na
        entry_tp := na
        entry_sl := na

        // Delete TP/SL boxes (shared across all strategies)
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

// Track which candle made the deepest penetration (only show current)
var label deepest_demand_label = na
var label deepest_supply_label = na

// Update deepest marker when new deepest is found - place below/above candle to avoid covering it
if demand_triggered and not na(demand_lowest_low) and low == demand_lowest_low
    // Delete old label
    if not na(deepest_demand_label)
        label.delete(deepest_demand_label)
    // Create new label below the candle low
    deepest_demand_label := label.new(bar_index, low, "â—", xloc=xloc.bar_index, yloc=yloc.price, color=color.new(color.white, 100), textcolor=color.blue, size=size.tiny, style=label.style_label_up, textalign=text.align_center)

if supply_triggered and not na(supply_highest_high) and high == supply_highest_high
    // Delete old label
    if not na(deepest_supply_label)
        label.delete(deepest_supply_label)
    // Create new label above the candle high
    deepest_supply_label := label.new(bar_index, high, "â—", xloc=xloc.bar_index, yloc=yloc.price, color=color.new(color.white, 100), textcolor=color.orange, size=size.tiny, style=label.style_label_down, textalign=text.align_center)

// ============================================================================
// SETUP ICONS - Visual indicators for each setup type
// ============================================================================

// ENG OB Detection: Black diamond when engulfing pattern detected
// Using label instead of plotshape so it can be deleted when invalidated
if is_bullish_engulfing
    eng_ob_diamond := label.new(bar_index, low, "â—†", xloc=xloc.bar_index, yloc=yloc.price, color=color.new(color.white, 100), textcolor=color.black, size=size.normal, style=label.style_none, textalign=text.align_center)
else if is_bearish_engulfing
    eng_ob_diamond := label.new(bar_index, high, "â—†", xloc=xloc.bar_index, yloc=yloc.price, color=color.new(color.white, 100), textcolor=color.black, size=size.normal, style=label.style_none, textalign=text.align_center)

// MSS OB Confirmation: Red/green diamond stacked on ENG OB when MSS fractal broken
// Show ONLY on the bar where MSS OB was confirmed (not every bar after)
// Uses labels with vertical offset so both ENG OB and MSS OB diamonds are visible
bool show_mss_bullish = not na(mss_ob_confirmed_bar) and bar_index == mss_ob_confirmed_bar and entry_is_bullish and active_entry_strategy == "MSS OB"
bool show_mss_bearish = not na(mss_ob_confirmed_bar) and bar_index == mss_ob_confirmed_bar and not entry_is_bullish and active_entry_strategy == "MSS OB"

// Calculate offset for MSS diamond positioning
float mss_offset = (high - low) * 1.5

// Bullish trade: MSS diamond below ENG OB diamond (both below candle)
if show_mss_bullish
    label.new(bar_index, low - mss_offset, "â—†", xloc=xloc.bar_index, yloc=yloc.price, color=color.new(color.white, 100), textcolor=color.green, size=size.normal, style=label.style_none, textalign=text.align_center)

// Bearish trade: MSS diamond above ENG OB diamond (both above candle)
if show_mss_bearish
    label.new(bar_index, high + mss_offset, "â—†", xloc=xloc.bar_index, yloc=yloc.price, color=color.new(color.white, 100), textcolor=color.red, size=size.normal, style=label.style_none, textalign=text.align_center)

// BPR FVG Detection: Square when BPR FVG detected (ONLY on detection bar)
// Maroon = bullish FVG in supply (leads to bearish trade)
// Blue = bearish FVG in demand (leads to bullish trade)
// Show icon ONLY on the bar where BPR FVG was detected
bool show_bpr_fvg_bullish_trade = not na(bpr_fvg_bar_index) and bar_index == bpr_fvg_bar_index and not bpr_fvg_is_bullish  // Bearish FVG = bullish trade
bool show_bpr_fvg_bearish_trade = not na(bpr_fvg_bar_index) and bar_index == bpr_fvg_bar_index and bpr_fvg_is_bullish  // Bullish FVG = bearish trade

// Inverted FVG: Purple square stacked on BPR FVG when overlap detected (ONLY on detection bar)
// Shows both the original BPR color and purple to indicate the inversion
// Show icon ONLY on the bar where Inverted FVG was detected
bool show_inv_fvg_bullish_trade = not na(inv_fvg_bar_index) and bar_index == inv_fvg_bar_index and inv_fvg_is_bullish  // Bullish inverted trade
bool show_inv_fvg_bearish_trade = not na(inv_fvg_bar_index) and bar_index == inv_fvg_bar_index and not inv_fvg_is_bullish  // Bearish inverted trade

// Calculate offset: Use ATR or fixed tick offset for consistent vertical spacing
// Base offset: 2x the candle range (more spacing than before)
float base_icon_offset = (high - low) * 2.0

// BULLISH TRADE ICONS (stacked below candle) - shown on detection bar only
if show_bpr_fvg_bullish_trade or show_inv_fvg_bullish_trade
    // BPR FVG icon (maroon square) - closest to candle
    if show_bpr_fvg_bullish_trade
        label.new(bar_index, low, "â– ", xloc=xloc.bar_index, yloc=yloc.price, color=color.new(color.white, 100), textcolor=color.maroon, size=size.normal, style=label.style_none, textalign=text.align_center)

    // INV FVG icon (purple square) - stacked below BPR icon with offset
    if show_inv_fvg_bullish_trade
        label.new(bar_index, low - base_icon_offset, "â– ", xloc=xloc.bar_index, yloc=yloc.price, color=color.new(color.white, 100), textcolor=color.purple, size=size.normal, style=label.style_none, textalign=text.align_center)

// BEARISH TRADE ICONS (stacked above candle) - shown on detection bar only
if show_bpr_fvg_bearish_trade or show_inv_fvg_bearish_trade
    // BPR FVG icon (blue square) - closest to candle
    if show_bpr_fvg_bearish_trade
        label.new(bar_index, high, "â– ", xloc=xloc.bar_index, yloc=yloc.price, color=color.new(color.white, 100), textcolor=color.blue, size=size.normal, style=label.style_none, textalign=text.align_center)

    // INV FVG icon (purple square) - stacked above BPR icon with offset
    if show_inv_fvg_bearish_trade
        label.new(bar_index, high + base_icon_offset, "â– ", xloc=xloc.bar_index, yloc=yloc.price, color=color.new(color.white, 100), textcolor=color.purple, size=size.normal, style=label.style_none, textalign=text.align_center)

// ============================================================================
// BPR FVG DETECTION
// ============================================================================
// FVG = Fair Value Gap = gap between candle 1 high/low and candle 3 low/high
// Bullish FVG: low[0] > high[2] (gap up)
// Bearish FVG: high[0] < low[2] (gap down)
// BPR = Balanced Price Range = FVG that forms in AOI

// Detect BPR FVG when in AOI and within trading window (no ENG OB requirement)
// Check if ANY of the 3 FVG candles touched the zone
// Don't detect new FVGs when we already have an active entry signal, active trade, or within cooldown
bool in_cooldown = last_exit_bar >= 0 and (bar_index - last_exit_bar) < cooldown_bars
if use_bpr_fvg and not bpr_fvg_active and not entry_signal_active and not trade_entered and not in_cooldown and bar_index >= 2 and in_trading_window and (in_supply or in_demand)
    // Bearish setup: detect bullish FVG in supply zone
    // Check if current candle OR previous 2 candles touched supply zone
    bool supply_touched_by_fvg_candles = false
    if supply_configured
        // Check current candle (candle 3)
        bool c0_in_supply = not (low > supply_top or high < supply_bottom)
        // Check candle 1 bar ago (candle 2)
        bool c1_in_supply = not (low[1] > supply_top or high[1] < supply_bottom)
        // Check candle 2 bars ago (candle 1)
        bool c2_in_supply = not (low[2] > supply_top or high[2] < supply_bottom)

        supply_touched_by_fvg_candles := c0_in_supply or c1_in_supply or c2_in_supply

    if supply_touched_by_fvg_candles
        // Bullish FVG: current low > high of 2 bars ago (gap up)
        bool has_bullish_fvg = low > high[2]

        if has_bullish_fvg
            // Calculate FVG size in ticks
            float fvg_size = low - high[2]
            float fvg_size_ticks = fvg_size / syminfo.mintick

            // Only activate if FVG meets minimum tick size requirement
            if fvg_size_ticks >= bpr_fvg_min_ticks
                bpr_fvg_active := true
                bpr_fvg_is_bullish := true
                bpr_fvg_bottom := high[2]  // Bottom of gap
                bpr_fvg_top := low  // Top of gap
                bpr_fvg_bar_index := bar_index

                // Track candle for SL - whichever of the 3 candles made the highest high
                if high >= high[1] and high >= high[2]
                    bpr_fvg_candle_high := high
                    bpr_fvg_candle_low := low
                else if high[1] >= high[2]
                    bpr_fvg_candle_high := high[1]
                    bpr_fvg_candle_low := low[1]
                else
                    bpr_fvg_candle_high := high[2]
                    bpr_fvg_candle_low := low[2]

                // Invalidation level: highest high of the 3 candles involved
                bpr_fvg_invalidation_level := math.max(high[2], math.max(high[1], high))

    // Bullish setup: detect bearish FVG in demand zone
    // Check if current candle OR previous 2 candles touched demand zone
    bool demand_touched_by_fvg_candles = false
    if demand_configured
        // Check current candle (candle 3)
        bool c0_in_demand = not (low > demand_top or high < demand_bottom)
        // Check candle 1 bar ago (candle 2)
        bool c1_in_demand = not (low[1] > demand_top or high[1] < demand_bottom)
        // Check candle 2 bars ago (candle 1)
        bool c2_in_demand = not (low[2] > demand_top or high[2] < demand_bottom)

        demand_touched_by_fvg_candles := c0_in_demand or c1_in_demand or c2_in_demand

    if demand_touched_by_fvg_candles
        // Bearish FVG: current high < low of 2 bars ago (gap down)
        bool has_bearish_fvg = high < low[2]

        if has_bearish_fvg
            // Calculate FVG size in ticks
            float fvg_size = low[2] - high
            float fvg_size_ticks = fvg_size / syminfo.mintick

            // Only activate if FVG meets minimum tick size requirement
            if fvg_size_ticks >= bpr_fvg_min_ticks
                bpr_fvg_active := true
                bpr_fvg_is_bullish := false
                bpr_fvg_top := low[2]  // Top of gap
                bpr_fvg_bottom := high  // Bottom of gap
                bpr_fvg_bar_index := bar_index

                // Track candle for SL - whichever of the 3 candles made the lowest low
                if low <= low[1] and low <= low[2]
                    bpr_fvg_candle_high := high
                    bpr_fvg_candle_low := low
                else if low[1] <= low[2]
                    bpr_fvg_candle_high := high[1]
                    bpr_fvg_candle_low := low[1]
                else
                    bpr_fvg_candle_high := high[2]
                    bpr_fvg_candle_low := low[2]

                // Invalidation level: lowest low of the 3 candles involved
                bpr_fvg_invalidation_level := math.min(low[2], math.min(low[1], low))

// INVALIDATION: Price closes beyond invalidation level (deeper into zone)
// This catches price going BACK INTO the zone (wrong direction), not price breaching THROUGH the FVG
// Don't run this invalidation once entry signal is active
if bpr_fvg_active and not entry_signal_active
    bool should_invalidate_fvg = false

    if bpr_fvg_is_bullish
        // Bullish FVG (bearish trade): invalidated if close goes HIGHER than invalidation level (back into supply)
        if close > bpr_fvg_invalidation_level
            should_invalidate_fvg := true
            bpr_fvg_invalidation_reason := "Price beyond invalidation (" + str.tostring(close, format.mintick) + " > " + str.tostring(bpr_fvg_invalidation_level, format.mintick) + ")"
    else
        // Bearish FVG (bullish trade): invalidated if close goes LOWER than invalidation level (back into demand)
        if close < bpr_fvg_invalidation_level
            should_invalidate_fvg := true
            bpr_fvg_invalidation_reason := "Price beyond invalidation (" + str.tostring(close, format.mintick) + " < " + str.tostring(bpr_fvg_invalidation_level, format.mintick) + ")"

    if should_invalidate_fvg
        bpr_fvg_active := false
        bpr_fvg_is_bullish := false
        bpr_fvg_top := na
        bpr_fvg_bottom := na
        bpr_fvg_invalidation_level := na
        bpr_fvg_bar_index := na
        bpr_fvg_candle_high := na
        bpr_fvg_candle_low := na

        // Delete FVG box
        if not na(bpr_fvg_box)
            box.delete(bpr_fvg_box)
            bpr_fvg_box := na

        // Clear Inverted FVG state when BPR FVG is invalidated
        inv_fvg_active := false
        inv_fvg_is_bullish := false
        inv_fvg_overlap_top := na
        inv_fvg_overlap_bottom := na
        inv_fvg_bar_index := na
        inv_fvg_reversal_candle_high := na
        inv_fvg_reversal_candle_low := na
        if not na(inv_fvg_overlap_box)
            box.delete(inv_fvg_overlap_box)
            inv_fvg_overlap_box := na

// INVALIDATION: BPR FVG timeout after N bars without entry signal
if bpr_fvg_active and not entry_signal_active and not na(bpr_fvg_bar_index)
    int bars_since_bpr = bar_index - bpr_fvg_bar_index
    if bars_since_bpr >= setup_timeout_bars
        bpr_fvg_invalidation_reason := "Timeout (" + str.tostring(bars_since_bpr) + " bars)"

        bpr_fvg_active := false
        bpr_fvg_is_bullish := false
        bpr_fvg_top := na
        bpr_fvg_bottom := na
        bpr_fvg_invalidation_level := na
        bpr_fvg_bar_index := na
        bpr_fvg_candle_high := na
        bpr_fvg_candle_low := na

        // Delete FVG box
        if not na(bpr_fvg_box)
            box.delete(bpr_fvg_box)
            bpr_fvg_box := na

        // Clear Inverted FVG state when BPR FVG is invalidated
        inv_fvg_active := false
        inv_fvg_is_bullish := false
        inv_fvg_overlap_top := na
        inv_fvg_overlap_bottom := na
        inv_fvg_bar_index := na
        inv_fvg_reversal_candle_high := na
        inv_fvg_reversal_candle_low := na
        if not na(inv_fvg_overlap_box)
            box.delete(inv_fvg_overlap_box)
            inv_fvg_overlap_box := na

// INVALIDATION: Clear BPR FVG when zones are disabled
if bpr_fvg_active
    bool should_invalidate_fvg_zone = false

    if bpr_fvg_is_bullish and clear_supply
        should_invalidate_fvg_zone := true
        bpr_fvg_invalidation_reason := "Supply zone disabled"
    else if not bpr_fvg_is_bullish and clear_demand
        should_invalidate_fvg_zone := true
        bpr_fvg_invalidation_reason := "Demand zone disabled"

    if should_invalidate_fvg_zone
        bpr_fvg_active := false
        bpr_fvg_is_bullish := false
        bpr_fvg_top := na
        bpr_fvg_bottom := na
        bpr_fvg_invalidation_level := na
        bpr_fvg_bar_index := na
        bpr_fvg_candle_high := na
        bpr_fvg_candle_low := na

        // Delete FVG box
        if not na(bpr_fvg_box)
            box.delete(bpr_fvg_box)
            bpr_fvg_box := na

        // Clear Inverted FVG state when BPR FVG is invalidated
        inv_fvg_active := false
        inv_fvg_is_bullish := false
        inv_fvg_overlap_top := na
        inv_fvg_overlap_bottom := na
        inv_fvg_bar_index := na
        inv_fvg_reversal_candle_high := na
        inv_fvg_reversal_candle_low := na
        if not na(inv_fvg_overlap_box)
            box.delete(inv_fvg_overlap_box)
            inv_fvg_overlap_box := na

// INVALIDATION: Clear BPR FVG when entering opposite zone
if barstate.isnew and was_outside_zones and bpr_fvg_active
    bool should_invalidate_opposite = false

    if bpr_fvg_is_bullish and in_demand
        should_invalidate_opposite := true
        bpr_fvg_invalidation_reason := "Entered opposite zone (demand)"
    else if not bpr_fvg_is_bullish and in_supply
        should_invalidate_opposite := true
        bpr_fvg_invalidation_reason := "Entered opposite zone (supply)"

    if should_invalidate_opposite
        bpr_fvg_active := false
        bpr_fvg_is_bullish := false
        bpr_fvg_top := na
        bpr_fvg_bottom := na
        bpr_fvg_invalidation_level := na
        bpr_fvg_bar_index := na
        bpr_fvg_candle_high := na
        bpr_fvg_candle_low := na

        // Delete FVG box
        if not na(bpr_fvg_box)
            box.delete(bpr_fvg_box)
            bpr_fvg_box := na

        // Clear Inverted FVG state when BPR FVG is invalidated
        inv_fvg_active := false
        inv_fvg_is_bullish := false
        inv_fvg_overlap_top := na
        inv_fvg_overlap_bottom := na
        inv_fvg_bar_index := na
        inv_fvg_reversal_candle_high := na
        inv_fvg_reversal_candle_low := na
        if not na(inv_fvg_overlap_box)
            box.delete(inv_fvg_overlap_box)
            inv_fvg_overlap_box := na

// Visualize BPR FVG with dotted blue outline and darker yellow fill
if bpr_fvg_active
    // Create box on first detection
    if na(bpr_fvg_box)
        bpr_fvg_box := box.new(bpr_fvg_bar_index, bpr_fvg_top, bpr_fvg_bar_index + 1, bpr_fvg_bottom,
                               border_color=color.blue,
                               border_style=line.style_dotted,
                               bgcolor=color.new(color.yellow, 70),
                               border_width=1,
                               extend=extend.none)
    else
        // Extend box to current bar
        box.set_right(bpr_fvg_box, bar_index + 1)

// ============================================================================
// INVERTED FVG DETECTION
// ============================================================================
// Inverted FVG = BPR FVG + opposite direction FVG that overlaps
// Entry is at the overlap zone, not at the FVG breach
// Every Inverted FVG starts as a BPR FVG, but not every BPR FVG becomes Inverted

// Detect Inverted FVG when we have an active BPR FVG (not yet triggered entry)
// Look for opposite direction FVG that overlaps the initial BPR FVG
// Don't detect when entry signal is already active or trade is entered
if use_inverted_fvg and bpr_fvg_active and not inv_fvg_active and not entry_signal_active and not trade_entered and bar_index >= 2
    // Check for opposite direction FVG
    if bpr_fvg_is_bullish
        // Initial FVG is bullish (gap up) - look for bearish FVG (gap down) that overlaps
        // Bearish FVG: current high < low of 2 bars ago
        // IMPORTANT: Close must be BELOW the BPR FVG BOTTOM (fully breach the FVG range)
        bool has_bearish_reversal_fvg = high < low[2] and close < bpr_fvg_bottom

        if has_bearish_reversal_fvg
            // Check if reversal FVG overlaps initial FVG
            float reversal_fvg_top = low[2]
            float reversal_fvg_bottom = high

            // Overlap exists if reversal bottom < initial top AND reversal top > initial bottom
            bool has_overlap = reversal_fvg_bottom < bpr_fvg_top and reversal_fvg_top > bpr_fvg_bottom

            if has_overlap
                // Calculate overlap zone
                float overlap_top = math.min(reversal_fvg_top, bpr_fvg_top)
                float overlap_bottom = math.max(reversal_fvg_bottom, bpr_fvg_bottom)

                // Activate Inverted FVG
                inv_fvg_active := true
                inv_fvg_is_bullish := false  // Bearish trade (reversal FVG is bearish)
                inv_fvg_overlap_top := overlap_top
                inv_fvg_overlap_bottom := overlap_bottom
                inv_fvg_bar_index := bar_index

                // Track reversal candle for SL - whichever of the 3 candles made the highest high
                if high >= high[1] and high >= high[2]
                    inv_fvg_reversal_candle_high := high
                    inv_fvg_reversal_candle_low := low
                else if high[1] >= high[2]
                    inv_fvg_reversal_candle_high := high[1]
                    inv_fvg_reversal_candle_low := low[1]
                else
                    inv_fvg_reversal_candle_high := high[2]
                    inv_fvg_reversal_candle_low := low[2]
    else
        // Initial FVG is bearish (gap down) - look for bullish FVG (gap up) that overlaps
        // Bullish FVG: current low > high of 2 bars ago
        // IMPORTANT: Close must be ABOVE the BPR FVG TOP (fully breach the FVG range)
        bool has_bullish_reversal_fvg = low > high[2] and close > bpr_fvg_top

        if has_bullish_reversal_fvg
            // Check if reversal FVG overlaps initial FVG
            float reversal_fvg_top = low
            float reversal_fvg_bottom = high[2]

            // Overlap exists if reversal bottom < initial top AND reversal top > initial bottom
            bool has_overlap = reversal_fvg_bottom < bpr_fvg_top and reversal_fvg_top > bpr_fvg_bottom

            if has_overlap
                // Calculate overlap zone
                float overlap_top = math.min(reversal_fvg_top, bpr_fvg_top)
                float overlap_bottom = math.max(reversal_fvg_bottom, bpr_fvg_bottom)

                // Activate Inverted FVG
                inv_fvg_active := true
                inv_fvg_is_bullish := true  // Bullish trade (reversal FVG is bullish)
                inv_fvg_overlap_top := overlap_top
                inv_fvg_overlap_bottom := overlap_bottom
                inv_fvg_bar_index := bar_index

                // Track reversal candle for SL - whichever of the 3 candles made the lowest low
                if low <= low[1] and low <= low[2]
                    inv_fvg_reversal_candle_high := high
                    inv_fvg_reversal_candle_low := low
                else if low[1] <= low[2]
                    inv_fvg_reversal_candle_high := high[1]
                    inv_fvg_reversal_candle_low := low[1]
                else
                    inv_fvg_reversal_candle_high := high[2]
                    inv_fvg_reversal_candle_low := low[2]

// INVALIDATION: Clear Inverted FVG when zones are disabled
if inv_fvg_active
    bool should_invalidate_inv_fvg_zone = false

    if inv_fvg_is_bullish and clear_demand
        should_invalidate_inv_fvg_zone := true
        inv_fvg_invalidation_reason := "Demand zone disabled"
    else if not inv_fvg_is_bullish and clear_supply
        should_invalidate_inv_fvg_zone := true
        inv_fvg_invalidation_reason := "Supply zone disabled"

    if should_invalidate_inv_fvg_zone
        inv_fvg_active := false
        inv_fvg_is_bullish := false
        inv_fvg_overlap_top := na
        inv_fvg_overlap_bottom := na
        inv_fvg_reversal_candle_high := na
        inv_fvg_reversal_candle_low := na
        inv_fvg_bar_index := na

        // Delete overlap box
        if not na(inv_fvg_overlap_box)
            box.delete(inv_fvg_overlap_box)
            inv_fvg_overlap_box := na

// INVALIDATION: Inverted FVG timeout after N bars without entry signal
if inv_fvg_active and not entry_signal_active and not na(inv_fvg_bar_index)
    int bars_since_inv = bar_index - inv_fvg_bar_index
    if bars_since_inv >= setup_timeout_bars
        inv_fvg_invalidation_reason := "Timeout (" + str.tostring(bars_since_inv) + " bars)"

        inv_fvg_active := false
        inv_fvg_is_bullish := false
        inv_fvg_overlap_top := na
        inv_fvg_overlap_bottom := na
        inv_fvg_reversal_candle_high := na
        inv_fvg_reversal_candle_low := na
        inv_fvg_bar_index := na

        // Delete overlap box
        if not na(inv_fvg_overlap_box)
            box.delete(inv_fvg_overlap_box)
            inv_fvg_overlap_box := na

// INVALIDATION: Clear Inverted FVG when entering opposite zone
if barstate.isnew and was_outside_zones and inv_fvg_active
    bool should_invalidate_inv_opposite = false

    if inv_fvg_is_bullish and in_supply
        should_invalidate_inv_opposite := true
        inv_fvg_invalidation_reason := "Entered opposite zone (supply)"
    else if not inv_fvg_is_bullish and in_demand
        should_invalidate_inv_opposite := true
        inv_fvg_invalidation_reason := "Entered opposite zone (demand)"

    if should_invalidate_inv_opposite
        inv_fvg_active := false
        inv_fvg_is_bullish := false
        inv_fvg_overlap_top := na
        inv_fvg_overlap_bottom := na
        inv_fvg_reversal_candle_high := na
        inv_fvg_reversal_candle_low := na
        inv_fvg_bar_index := na

        // Delete overlap box
        if not na(inv_fvg_overlap_box)
            box.delete(inv_fvg_overlap_box)
            inv_fvg_overlap_box := na

// Visualize Inverted FVG overlap with dotted blue outline and darker yellow fill
if inv_fvg_active
    // Create overlap box on first detection
    if na(inv_fvg_overlap_box)
        inv_fvg_overlap_box := box.new(inv_fvg_bar_index, inv_fvg_overlap_top, inv_fvg_bar_index + 1, inv_fvg_overlap_bottom,
                                       border_color=color.blue,
                                       border_style=line.style_dotted,
                                       bgcolor=color.new(color.yellow, 70),
                                       border_width=1,
                                       extend=extend.none)
    else
        // Extend overlap box to current bar
        box.set_right(inv_fvg_overlap_box, bar_index + 1)

// ============================================================================
// ENTRY ZONE VISUALIZATION - Works for ALL entry strategies
// ============================================================================
// Standard visual flow for all 4 entry strategies:
// 1. YELLOW box = ENG OB detected (entry zone identified)
// 2. BLUE box = Entry signal active (limit order placed, awaiting fill)
// 3. GREEN/RED boxes = Trade entered (TP/SL shown when position is open)

// STEP 1: Create YELLOW box with dotted blue outline when ENG OB forms
if is_bullish_engulfing or is_bearish_engulfing
    // Delete old box
    if not na(eng_ob_box)
        box.delete(eng_ob_box)

    // Draw new box around the OB candle we just identified
    if not na(eng_ob_bar_index)
        int box_left = eng_ob_bar_index
        int box_right = eng_ob_bar_index + 1
        float box_top = eng_ob_candle_high
        float box_bottom = eng_ob_candle_low

        // Use darker yellow fill with dotted blue outline for ENG OB (entry zone)
        eng_ob_box := box.new(box_left, box_top, box_right, box_bottom,
                              border_color=color.blue,
                              border_style=line.style_dotted,
                              bgcolor=color.new(color.yellow, 70),
                              border_width=1,
                              extend=extend.none)

// STEP 2: Extend box and change fill to BLUE when entry signal activates
if (eng_ob_active or entry_signal_active) and not na(eng_ob_box)
    box.set_right(eng_ob_box, bar_index + 1)

    // Change fill to blue ONLY when MSS OB or other ENG OB-based strategies activate (not BPR FVG)
    // Border stays dotted blue throughout
    if entry_signal_active and active_entry_strategy != "BPR FVG"
        box.set_bgcolor(eng_ob_box, color.new(color.blue, 90))

// STEP 2: Extend BPR FVG box and change fill to BLUE when entry signal activates
if bpr_fvg_active and not na(bpr_fvg_box)
    box.set_right(bpr_fvg_box, bar_index + 1)

    // Change fill to blue when BPR FVG entry strategy activates (limit order placed)
    // Border stays dotted blue throughout
    if entry_signal_active and active_entry_strategy == "BPR FVG"
        box.set_bgcolor(bpr_fvg_box, color.new(color.blue, 90))

// STEP 2: Extend Inverted FVG overlap box and change fill to BLUE when entry signal activates
if inv_fvg_active and not na(inv_fvg_overlap_box)
    box.set_right(inv_fvg_overlap_box, bar_index + 1)

    // Change fill to blue when Inverted FVG entry strategy activates (limit order placed)
    // Border stays dotted blue throughout
    if entry_signal_active and active_entry_strategy == "Inverted FVG"
        box.set_bgcolor(inv_fvg_overlap_box, color.new(color.blue, 90))

// ============================================================================
// LTF FRACTAL DETECTION (only when in AOI or active setup)
// ============================================================================
// Only detect fractals when we're in AOI or have an active setup
bool should_detect_fractals = supply_triggered or demand_triggered or eng_ob_active

// Fractal detection: 2-period lookback/forward (5 candle pattern)
bool is_bearish_fractal = false
bool is_bullish_fractal = false

if should_detect_fractals and bar_index >= 2
    // Bearish fractal: high is higher than 2 candles before and 2 candles after
    is_bearish_fractal := high[2] > high[4] and high[2] > high[3] and high[2] > high[1] and high[2] > high[0]

    // Bullish fractal: low is lower than 2 candles before and 2 candles after
    is_bullish_fractal := low[2] < low[4] and low[2] < low[3] and low[2] < low[1] and low[2] < low[0]

    // Store latest fractals in real-time (for MSS OB strategy)
    if is_bearish_fractal
        latest_bearish_fractal := high[2]
    if is_bullish_fractal
        latest_bullish_fractal := low[2]

// Plot fractals for debugging (only when actively detecting)
plotshape(is_bearish_fractal, title="Bearish Fractal", style=shape.triangledown, location=location.abovebar, color=color.red, size=size.tiny, offset=-2)
plotshape(is_bullish_fractal, title="Bullish Fractal", style=shape.triangleup, location=location.belowbar, color=color.green, size=size.tiny, offset=-2)

// ============================================================================
// MSS OB STRATEGY - Fractal Detection
// ============================================================================
// Use the latest opposite fractal that was detected in real-time
// Continue checking on every bar until a fractal is found
if use_mss_ob and eng_ob_active and na(target_fractal_level_mss)
    if eng_ob_is_bullish
        // Bullish setup: use bearish fractal ONLY if it's ABOVE the engulfing candle high
        // This ensures we're breaking structure upward (bullish MSS)
        if not na(latest_bearish_fractal) and not na(eng_ob_candle_high) and latest_bearish_fractal > eng_ob_candle_high
            target_fractal_level_mss := latest_bearish_fractal
    else
        // Bearish setup: use bullish fractal ONLY if it's BELOW the engulfing candle low
        // This ensures we're breaking structure downward (bearish MSS)
        if not na(latest_bullish_fractal) and not na(eng_ob_candle_low) and latest_bullish_fractal < eng_ob_candle_low
            target_fractal_level_mss := latest_bullish_fractal

// ============================================================================
// MSS OB STRATEGY - Entry Signal Detection
// ============================================================================
// Check if price has crossed the fractal level (wick or close through)
// Don't trigger new entries while a trade is active, on same bar as exit, or within cooldown
if use_mss_ob and eng_ob_active and not entry_signal_active and not trade_entered and not in_cooldown and not na(target_fractal_level_mss)
    bool fractal_crossed = false

    if eng_ob_is_bullish
        // Bullish setup: check if price crossed above the bearish fractal high
        fractal_crossed := high >= target_fractal_level_mss
    else
        // Bearish setup: check if price crossed below the bullish fractal low
        fractal_crossed := low <= target_fractal_level_mss

    if fractal_crossed
        // MSS OB entry signal triggered
        entry_signal_active := true
        entry_signal_bar_index := bar_index
        active_entry_strategy := "MSS OB"
        entry_is_bullish := eng_ob_is_bullish
        mss_ob_confirmed_bar := bar_index  // Record when MSS OB was confirmed for icon plotting

        // Set entry, TP, and SL based on the OB candle
        if eng_ob_is_bullish
            // Bullish: Entry at high of OB candle, SL at low (with grace ticks), TP at 2:1 RR
            entry_price := eng_ob_candle_high
            entry_sl := eng_ob_candle_low - grace_ticks  // Pad SL below the low
            float risk = entry_price - entry_sl
            entry_tp := entry_price + (risk * 2)  // 2:1 reward to risk
        else
            // Bearish: Entry at low of OB candle, SL at high (with grace ticks), TP at 2:1 RR
            entry_price := eng_ob_candle_low
            entry_sl := eng_ob_candle_high + grace_ticks  // Pad SL above the high
            float risk = entry_sl - entry_price
            entry_tp := entry_price - (risk * 2)  // 2:1 reward to risk

// ============================================================================
// BPR FVG STRATEGY - Entry Signal Detection
// ============================================================================
// Entry triggered when price CLOSES below FVG bottom (bearish) or above FVG top (bullish)
// Don't trigger new entries while a trade is active or within cooldown period
// IMPORTANT: Only check at bar close (barstate.isconfirmed) to wait for candle to fully close
if use_bpr_fvg and bpr_fvg_active and not entry_signal_active and not trade_entered and not in_cooldown and barstate.isconfirmed
    bool close_through_fvg = false

    if bpr_fvg_is_bullish
        // Bearish setup: wait for close BELOW FVG bottom (fully breached)
        close_through_fvg := close < bpr_fvg_bottom
    else
        // Bullish setup: wait for close ABOVE FVG top (fully breached)
        close_through_fvg := close > bpr_fvg_top

    if close_through_fvg
        entry_signal_active := true
        entry_signal_bar_index := bar_index
        active_entry_strategy := "BPR FVG"
        entry_is_bullish := not bpr_fvg_is_bullish  // Inverse: bullish FVG = bearish trade

        if bpr_fvg_is_bullish
            // Bearish setup: Entry at bottom of FVG, SL at HIGH of FVG candle (with grace ticks), TP at 2:1 RR
            entry_price := bpr_fvg_bottom
            entry_sl := bpr_fvg_candle_high + grace_ticks  // Pad SL above the candle high
            float risk = entry_sl - entry_price
            entry_tp := entry_price - (risk * 2)  // 2:1 reward to risk
        else
            // Bullish setup: Entry at top of FVG, SL at LOW of FVG candle (with grace ticks), TP at 2:1 RR
            entry_price := bpr_fvg_top
            entry_sl := bpr_fvg_candle_low - grace_ticks  // Pad SL below the candle low
            float risk = entry_price - entry_sl
            entry_tp := entry_price + (risk * 2)  // 2:1 reward to risk

        // DON'T clear BPR FVG state here - keep it for debug table display
        // It will be cleared when trade exits or is invalidated

// ============================================================================
// INVERTED FVG STRATEGY - Entry Signal Detection
// ============================================================================
// Entry triggered when Inverted FVG is detected (overlap found)
// Entry is at top of overlap (bearish) or bottom of overlap (bullish)
// SL is at high/low of reversal FVG candle, TP is 2:1 RR
if use_inverted_fvg and inv_fvg_active and not entry_signal_active and not trade_entered and not in_cooldown
    // Inverted FVG entry triggers immediately when overlap is detected
    entry_signal_active := true
    entry_signal_bar_index := bar_index
    active_entry_strategy := "Inverted FVG"
    entry_is_bullish := inv_fvg_is_bullish

    if inv_fvg_is_bullish
        // Bullish setup: Entry at TOP of overlap, SL at LOW of reversal candle
        entry_price := inv_fvg_overlap_top
        entry_sl := inv_fvg_reversal_candle_low - grace_ticks
        float risk = entry_price - entry_sl
        entry_tp := entry_price + (risk * 2)  // 2:1 RR
    else
        // Bearish setup: Entry at BOTTOM of overlap, SL at HIGH of reversal candle
        entry_price := inv_fvg_overlap_bottom
        entry_sl := inv_fvg_reversal_candle_high + grace_ticks
        float risk = entry_sl - entry_price
        entry_tp := entry_price - (risk * 2)  // 2:1 RR

// ============================================================================
// BREAKER BLOCK STRATEGY - Entry Signal Detection
// ============================================================================
// TODO: Implement Breaker Block detection
if use_breaker_block and eng_ob_active and not entry_signal_active
    // Placeholder for Breaker Block strategy
    bool breaker_triggered = false  // TODO: Add actual detection logic

    if breaker_triggered
        entry_signal_active := true
        active_entry_strategy := "Breaker Block"
        // TODO: Set entry_price, entry_tp, entry_sl

// ============================================================================
// ENTRY SIGNAL TIMEOUT - Works for ALL strategies
// ============================================================================
// Invalidate entry signal after N bars if limit order doesn't fill
if entry_signal_active and not trade_entered and not na(entry_signal_bar_index)
    int bars_since_entry_signal = bar_index - entry_signal_bar_index
    if bars_since_entry_signal >= entry_timeout_bars
        // Entry signal timed out - clear ALL strategy-specific state
        if active_entry_strategy == "MSS OB" or active_entry_strategy == "Breaker Block"
            // ENG OB-based strategies
            eng_ob_active := false
            if not na(eng_ob_diamond)
                label.delete(eng_ob_diamond)
                eng_ob_diamond := na
            eng_ob_is_bullish := false
            eng_ob_deepest_level := na
            eng_ob_bar_index := na
            eng_ob_candle_high := na
            eng_ob_candle_low := na
            target_fractal_level_mss := na
            mss_ob_confirmed_bar := na
            if not na(eng_ob_box)
                box.delete(eng_ob_box)
                eng_ob_box := na
        else if active_entry_strategy == "BPR FVG"
            // BPR FVG strategy
            bpr_fvg_active := false
            bpr_fvg_is_bullish := false
            bpr_fvg_top := na
            bpr_fvg_bottom := na
            bpr_fvg_invalidation_level := na
            bpr_fvg_bar_index := na
            bpr_fvg_candle_high := na
            bpr_fvg_candle_low := na
            bpr_fvg_invalidation_reason := "Entry timeout"
            if not na(bpr_fvg_box)
                box.delete(bpr_fvg_box)
                bpr_fvg_box := na
        else if active_entry_strategy == "Inverted FVG"
            // Inverted FVG strategy (clears both BPR FVG and Inverted FVG state)
            bpr_fvg_active := false
            bpr_fvg_is_bullish := false
            bpr_fvg_top := na
            bpr_fvg_bottom := na
            bpr_fvg_invalidation_level := na
            bpr_fvg_bar_index := na
            bpr_fvg_candle_high := na
            bpr_fvg_candle_low := na
            bpr_fvg_invalidation_reason := "Entry timeout"
            if not na(bpr_fvg_box)
                box.delete(bpr_fvg_box)
                bpr_fvg_box := na
            inv_fvg_active := false
            inv_fvg_is_bullish := false
            inv_fvg_overlap_top := na
            inv_fvg_overlap_bottom := na
            inv_fvg_reversal_candle_high := na
            inv_fvg_reversal_candle_low := na
            inv_fvg_bar_index := na
            inv_fvg_invalidation_reason := "Entry timeout"
            if not na(inv_fvg_overlap_box)
                box.delete(inv_fvg_overlap_box)
                inv_fvg_overlap_box := na

        // Clear generic entry signal state (all strategies)
        entry_signal_active := false
        entry_signal_bar_index := na
        active_entry_strategy := ""
        entry_is_bullish := false
        entry_price := na
        entry_tp := na
        entry_sl := na
        order_placed := false

        // Delete TP/SL boxes
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

// ============================================================================
// GENERIC ENTRY EXECUTION - Works for all strategies
// ============================================================================
// When any entry signal becomes active, place the trade ONCE
if entry_signal_active and not trade_entered and not order_placed and not na(entry_price)
    // Calculate position size based on risk
    float risk_per_contract = math.abs(entry_price - entry_sl)
    float position_size = risk_per_trade / risk_per_contract

    // Calculate breakeven + 1 tick (direction-aware for commission coverage)
    if entry_is_bullish
        breakeven_plus_tick := entry_price + syminfo.mintick
    else
        breakeven_plus_tick := entry_price - syminfo.mintick

    // Place limit order at entry level
    if entry_is_bullish
        // Enter long position with limit order at entry level
        strategy.entry("Long", strategy.long, qty=position_size, limit=entry_price)

        if use_trailing_stop
            // Initial: full position with TP/SL until TP is hit
            strategy.exit("Initial Exit", "Long", limit=entry_tp, stop=entry_sl)
        else
            // Standard exit: full position at TP/SL
            strategy.exit("TP/SL Long", "Long", limit=entry_tp, stop=entry_sl)
    else
        // Enter short position with limit order at entry level
        strategy.entry("Short", strategy.short, qty=position_size, limit=entry_price)

        if use_trailing_stop
            // Initial: full position with TP/SL until TP is hit
            strategy.exit("Initial Exit", "Short", limit=entry_tp, stop=entry_sl)
        else
            // Standard exit: full position at TP/SL
            strategy.exit("TP/SL Short", "Short", limit=entry_tp, stop=entry_sl)

    // Mark that order has been placed for this signal
    order_placed := true
    order_placed_bar := bar_index

// ============================================================================
// TRADE EXECUTION - Track when limit order is filled
// ============================================================================
// STEP 3: Create GREEN/RED boxes when trade is entered (generic for all strategies)
if entry_signal_active and not trade_entered
    // Check if we now have an open position (limit order was filled)
    if strategy.position_size != 0
        trade_entered := true

        // Create TP and SL indicator boxes (only when trade is actually entered)
        // This completes the standard visual flow: YELLOW â†’ BLUE â†’ GREEN/RED
        // Delete old boxes first
        if not na(tp_box)
            box.delete(tp_box)
        if not na(sl_box)
            box.delete(sl_box)

        // Create new TP box (green) and SL box (red)
        if entry_is_bullish
            // Bullish: TP is above entry
            tp_box := box.new(bar_index, entry_tp, bar_index + 1, entry_price,
                             border_color=color.green,
                             bgcolor=color.new(color.green, 85),
                             border_width=1,
                             extend=extend.none)
            // SL is below entry
            sl_box := box.new(bar_index, entry_price, bar_index + 1, entry_sl,
                             border_color=color.red,
                             bgcolor=color.new(color.red, 85),
                             border_width=1,
                             extend=extend.none)
        else
            // Bearish: TP is below entry
            tp_box := box.new(bar_index, entry_price, bar_index + 1, entry_tp,
                             border_color=color.green,
                             bgcolor=color.new(color.green, 85),
                             border_width=1,
                             extend=extend.none)
            // SL is above entry
            sl_box := box.new(bar_index, entry_sl, bar_index + 1, entry_price,
                             border_color=color.red,
                             bgcolor=color.new(color.red, 85),
                             border_width=1,
                             extend=extend.none)

// ============================================================================
// TRAILING STOP ACTIVATION - When TP is hit, switch to trailing stop
// ============================================================================
// Monitor if TP was hit and activate trailing stop for remaining 50%
if use_trailing_stop and trade_entered and not tp_hit
    bool tp_reached = false

    if entry_is_bullish
        // Bullish: check if price reached TP level
        tp_reached := high >= entry_tp
    else
        // Bearish: check if price reached TP level
        tp_reached := low <= entry_tp

    if tp_reached
        // TP was hit - now we need to:
        // 1. Cancel the "Initial Exit" order
        // 2. Close 50% at market
        // 3. Set trailing stop for remaining 50%
        tp_hit := true

        // Calculate ATR for trailing stop
        float atr_value = ta.atr(trailing_atr_length)
        float trail_offset = atr_value * trailing_atr_multiplier

        // Cancel the initial exit order
        strategy.cancel("Initial Exit")

        // Close 50% at market
        if entry_is_bullish
            strategy.close("Long", qty_percent=50, comment="TP 50%")
            // Set trailing stop for remaining 50%, starting at breakeven + tick
            strategy.exit("Trail", "Long", stop=breakeven_plus_tick, trail_offset=trail_offset)
        else
            strategy.close("Short", qty_percent=50, comment="TP 50%")
            // Set trailing stop for remaining 50%, starting at breakeven - tick
            strategy.exit("Trail", "Short", stop=breakeven_plus_tick, trail_offset=trail_offset)

// Check if trade has exited (TP or SL hit)
if trade_entered and strategy.position_size == 0
    // FIRST: Cancel all pending orders to prevent re-entry from lingering limit order
    strategy.cancel_all()

    // Record the exit bar to prevent same-bar re-entry
    last_exit_bar := bar_index

    // Trade has exited - clear all setup variables
    eng_ob_active := false
    if not na(eng_ob_diamond)
        label.delete(eng_ob_diamond)
        eng_ob_diamond := na
    eng_ob_is_bullish := false
    eng_ob_deepest_level := na
    eng_ob_bar_index := na
    eng_ob_candle_high := na
    eng_ob_candle_low := na
    target_fractal_level_mss := na
    mss_ob_confirmed_bar := na

    // Clear entry signals (all strategies)
    entry_signal_active := false
    active_entry_strategy := ""
    entry_is_bullish := false
    entry_price := na
    entry_tp := na
    entry_sl := na

    // Reset trade flag and order placement flag
    trade_entered := false
    order_placed := false
    order_placed_bar := -1

    // Reset trailing stop state
    tp_hit := false
    breakeven_plus_tick := na

    // Persist TP/SL boxes for the day (don't delete, just stop extending)
    // Add them to daily arrays so they stay visible until 20:00
    if not na(tp_box)
        array.push(daily_tp_boxes, tp_box)
        tp_box := na
    if not na(sl_box)
        array.push(daily_sl_boxes, sl_box)
        sl_box := na

    // Delete eng_ob_box since it's just for active setup
    if not na(eng_ob_box)
        box.delete(eng_ob_box)
        eng_ob_box := na

    // Delete bpr_fvg_box since it's just for active setup
    if not na(bpr_fvg_box)
        box.delete(bpr_fvg_box)
        bpr_fvg_box := na

    // Clear BPR FVG state
    bpr_fvg_active := false
    bpr_fvg_is_bullish := false
    bpr_fvg_top := na
    bpr_fvg_bottom := na
    bpr_fvg_invalidation_level := na
    bpr_fvg_bar_index := na
    bpr_fvg_candle_high := na
    bpr_fvg_candle_low := na
    bpr_fvg_invalidation_reason := "Trade exited"

    // Delete inv_fvg_overlap_box since it's just for active setup
    if not na(inv_fvg_overlap_box)
        box.delete(inv_fvg_overlap_box)
        inv_fvg_overlap_box := na

    // Clear Inverted FVG state
    inv_fvg_active := false
    inv_fvg_is_bullish := false
    inv_fvg_overlap_top := na
    inv_fvg_overlap_bottom := na
    inv_fvg_reversal_candle_high := na
    inv_fvg_reversal_candle_low := na
    inv_fvg_bar_index := na
    inv_fvg_invalidation_reason := "Trade exited"

// ============================================================================
// INTRABAR TRADE CLEANUP - REMOVED
// ============================================================================
// Intrabar cleanup has been removed to simplify the strategy logic
// The regular exit handler handles all trade exits (including intrabar fills)
// Unfilled limit orders will be cleaned up at 9 AM reset or when new setups form

// Update TP/SL boxes to extend one bar at a time while trade is entered (only show when in trade)
if trade_entered and not na(tp_box) and not na(sl_box)
    box.set_right(tp_box, bar_index + 1)
    box.set_right(sl_box, bar_index + 1)

// ============================================================================
// COMPREHENSIVE ZOMBIE STATE DETECTION - Run right before debug table
// ============================================================================
// This catches any inconsistent state where bpr_fvg_active is TRUE but should be FALSE
// Common zombie causes:
// 1. bpr_fvg_active = TRUE but not in supply/demand zone AND not in trading window
// 2. bpr_fvg_active = TRUE but zone was disabled (clear_supply or clear_demand)
// 3. bpr_fvg_active = TRUE but bpr_fvg_bar_index is na
// 4. bpr_fvg_active = TRUE but exceeded timeout

if bpr_fvg_active
    bool should_clear_zombie = false
    string zombie_reason = ""

    // Check 6: Inconsistent state - bpr_fvg_active = TRUE but conditions don't support it
    // This catches replay mode zombies where the state is stuck from a previous bar
    // CRITICAL: Run this check FIRST before timeout/zone checks, as it's the most specific zombie detector
    if not entry_signal_active and not trade_entered
        // BPR FVG should only be active if we're CURRENTLY IN the zone that spawned it
        // in_supply/in_demand check if current bar's high/low actually touch the zone range
        bool in_correct_zone = (bpr_fvg_is_bullish and in_supply) or (not bpr_fvg_is_bullish and in_demand)
        if not in_correct_zone
            should_clear_zombie := true
            zombie_reason := "not in spawning zone"

    // Check 1: bar_index is na (already caught by safety check, but double-check)
    if not should_clear_zombie and na(bpr_fvg_bar_index)
        should_clear_zombie := true
        zombie_reason := "bar_index is na"

    // Check 2: Zone disabled
    if not should_clear_zombie and ((bpr_fvg_is_bullish and clear_supply) or (not bpr_fvg_is_bullish and clear_demand))
        should_clear_zombie := true
        zombie_reason := "zone disabled"

    // Check 3: Timeout exceeded
    if not should_clear_zombie and not entry_signal_active and not na(bpr_fvg_bar_index)
        int bars_since_detect = bar_index - bpr_fvg_bar_index
        if bars_since_detect >= setup_timeout_bars
            should_clear_zombie := true
            zombie_reason := "timeout (" + str.tostring(bars_since_detect) + " bars)"

    // Check 4: Not in zone AND not in trading window (stale state from previous session)
    if not should_clear_zombie and not in_supply and not in_demand and not in_trading_window
        should_clear_zombie := true
        zombie_reason := "not in zone and not in window"

    // Check 5: Entered opposite zone (fresh entry after being outside both zones)
    if not should_clear_zombie and barstate.isnew and was_outside_zones
        if (bpr_fvg_is_bullish and in_demand) or (not bpr_fvg_is_bullish and in_supply)
            should_clear_zombie := true
            zombie_reason := "entered opposite zone"

    if should_clear_zombie
        bpr_fvg_active := false
        bpr_fvg_is_bullish := false
        bpr_fvg_top := na
        bpr_fvg_bottom := na
        bpr_fvg_invalidation_level := na
        bpr_fvg_bar_index := na
        bpr_fvg_candle_high := na
        bpr_fvg_candle_low := na
        bpr_fvg_invalidation_reason := "ZOMBIE CLEARED: " + zombie_reason

        if not na(bpr_fvg_box)
            box.delete(bpr_fvg_box)
            bpr_fvg_box := na

// Same zombie detection for Inverted FVG
if inv_fvg_active
    bool should_clear_inv_zombie = false
    string inv_zombie_reason = ""

    // Check 1: bar_index is na
    if na(inv_fvg_bar_index)
        should_clear_inv_zombie := true
        inv_zombie_reason := "bar_index is na"

    // Check 2: Zone disabled
    else if (inv_fvg_is_bullish and clear_demand) or (not inv_fvg_is_bullish and clear_supply)
        should_clear_inv_zombie := true
        inv_zombie_reason := "zone disabled"

    // Check 3: Timeout exceeded
    else if not entry_signal_active and not na(inv_fvg_bar_index)
        int bars_since_inv_detect = bar_index - inv_fvg_bar_index
        if bars_since_inv_detect >= setup_timeout_bars
            should_clear_inv_zombie := true
            inv_zombie_reason := "timeout (" + str.tostring(bars_since_inv_detect) + " bars)"

    // Check 4: Not in zone AND not in trading window
    else if not in_supply and not in_demand and not in_trading_window
        should_clear_inv_zombie := true
        inv_zombie_reason := "not in zone and not in window"

    // Check 5: Entered opposite zone
    else if barstate.isnew and was_outside_zones
        if (inv_fvg_is_bullish and in_supply) or (not inv_fvg_is_bullish and in_demand)
            should_clear_inv_zombie := true
            inv_zombie_reason := "entered opposite zone"

    if should_clear_inv_zombie
        inv_fvg_active := false
        inv_fvg_is_bullish := false
        inv_fvg_overlap_top := na
        inv_fvg_overlap_bottom := na
        inv_fvg_reversal_candle_high := na
        inv_fvg_reversal_candle_low := na
        inv_fvg_bar_index := na
        inv_fvg_invalidation_reason := "ZOMBIE CLEARED: " + inv_zombie_reason

        if not na(inv_fvg_overlap_box)
            box.delete(inv_fvg_overlap_box)
            inv_fvg_overlap_box := na

// ============================================================================
// DEBUG TABLE - DYNAMIC (expands based on active setup)
// ============================================================================
// Calculate max rows needed (will adjust dynamically)
var int MAX_DEBUG_ROWS = 50
var table debugTable = table.new(position.top_right, 2, MAX_DEBUG_ROWS, border_width=1)

// Clear the table on each bar to remove stale data
table.clear(debugTable, 0, 0, 1, MAX_DEBUG_ROWS - 1)

// Initialize row counter for dynamic table
var int row = 0
row := 0

// Common colors - SUBTLE
color label_bgcolor = color.new(color.gray, 20)  // Dark gray background for labels (left column)
color value_bgcolor = color.new(color.gray, 85)   // Light gray background for values (right column)

// ============================================================================
// BASE TABLE (ALWAYS VISIBLE)
// ============================================================================

// Determine AOI status based on flow rules
string aoi_status = "-"
if trade_entered and strategy.position_size != 0
    aoi_status := "IN TRADE"
    value_bgcolor := entry_is_bullish ? color.new(color.green, 80) : color.new(color.red, 80)
else if entry_signal_active
    aoi_status := "AWAITING ENTRY"
    value_bgcolor := entry_is_bullish ? color.new(color.green, 80) : color.new(color.red, 80)
else if eng_ob_active
    aoi_status := "ACTIVE"
    value_bgcolor := eng_ob_is_bullish ? color.new(color.green, 85) : color.new(color.red, 85)
else if bpr_fvg_active or inv_fvg_active
    aoi_status := "ACTIVE"
    // For BPR FVG, trade direction is INVERTED from FVG direction
    // Bullish FVG = bearish trade (red), Bearish FVG = bullish trade (blue)
    // For Inverted FVG, trade direction matches the variable
    value_bgcolor := (bpr_fvg_active ? not bpr_fvg_is_bullish : inv_fvg_is_bullish) ? color.new(color.green, 85) : color.new(color.red, 85)
else if supply_triggered or demand_triggered
    aoi_status := "IN AOI"
    value_bgcolor := supply_triggered ? color.new(color.red, 85) : color.new(color.green, 85)
else
    aoi_status := "-"
    value_bgcolor := color.new(color.gray, 85)

string padded_status = aoi_status == "-" ? "  -   " : aoi_status
table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". AOI Status", text_color=color.white, bgcolor=label_bgcolor, text_size=size.normal)
table.cell(debugTable, 1, row, padded_status, text_color=color.black, bgcolor=value_bgcolor, text_size=size.normal)
row := row + 1

// Entry Strategy - show which strategy is active (detected or triggered)
string entry_strategy_text = "-"
color entry_strategy_bgcolor = value_bgcolor
if entry_signal_active
    entry_strategy_text := active_entry_strategy
    entry_strategy_bgcolor := entry_is_bullish ? color.new(color.green, 85) : color.new(color.red, 85)
else if inv_fvg_active
    entry_strategy_text := "Inverted FVG (detected)"
    entry_strategy_bgcolor := value_bgcolor
else if bpr_fvg_active
    entry_strategy_text := "BPR FVG (detected)"
    entry_strategy_bgcolor := value_bgcolor
else if eng_ob_active
    entry_strategy_text := "MSS OB (detected)"
    entry_strategy_bgcolor := value_bgcolor
table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". Entry Strategy", text_color=color.white, bgcolor=label_bgcolor, text_size=size.normal)
table.cell(debugTable, 1, row, entry_strategy_text, text_color=color.black, bgcolor=entry_strategy_bgcolor, text_size=size.normal)
row := row + 1

// Combined: Entry + TP + SL
string entry_tp_sl_text = "-"
if entry_signal_active and not na(entry_price) and not na(entry_tp) and not na(entry_sl)
    entry_tp_sl_text := "Entry: " + str.tostring(entry_price, format.mintick) + " | TP: " + str.tostring(entry_tp, format.mintick) + " | SL: " + str.tostring(entry_sl, format.mintick)
table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". Entry/TP/SL", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, row, entry_tp_sl_text, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)
row := row + 1

// Position Size
string pos_size = str.tostring(strategy.position_size)
table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". Position Size", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, row, pos_size, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)
row := row + 1

// Trading Window status - DETAILED
string trading_window_text = in_trading_window ? "âœ“ IN" : "âœ— OUT"
string time_details = " | " + str.tostring(current_time_minutes) + " mins (start:" + str.tostring(trading_start_minutes) + " end:" + str.tostring(trading_end_minutes) + ")"
trading_window_text := trading_window_text + time_details
color trading_window_bg = in_trading_window ? color.new(color.green, 85) : color.new(color.red, 85)
table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". Trading Window", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, row, trading_window_text, text_color=color.black, bgcolor=trading_window_bg, text_size=size.small)
row := row + 1

// Cooldown status
string cooldown_text = in_cooldown ? "âœ— YES (blocked)" : "âœ“ NO"
if last_exit_bar >= 0
    int bars_since_exit = bar_index - last_exit_bar
    cooldown_text := cooldown_text + " (" + str.tostring(bars_since_exit) + " bars)"
color cooldown_bg = in_cooldown ? color.new(color.red, 85) : color.new(color.green, 85)
table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". Cooldown", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, row, cooldown_text, text_color=color.black, bgcolor=cooldown_bg, text_size=size.small)
row := row + 1

// ENGULFING DETECTION DIAGNOSTIC (ALWAYS VISIBLE)
table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". ENG OB DIAGNOSTIC", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.small)
table.cell(debugTable, 1, row, "", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.small)
row := row + 1

// Zone triggered status
string zone_triggered_text = "-"
if supply_triggered
    zone_triggered_text := "âœ“ SUPPLY"
else if demand_triggered
    zone_triggered_text := "âœ“ DEMAND"
else
    zone_triggered_text := "âœ— NONE"
table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". Zone Triggered", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, row, zone_triggered_text, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)
row := row + 1

// Engulfing pattern conditions (bullish)
if demand_triggered and bar_index > 0
    bool current_bullish = close > open
    bool prev_bearish = close[1] < open[1]
    bool engulfs_body = close >= open[1]
    bool is_deepest = low <= demand_lowest_low or low[1] <= demand_lowest_low

    string bullish_eng_text = ""
    bullish_eng_text := bullish_eng_text + (current_bullish ? "âœ“" : "âœ—") + "cur_bull "
    bullish_eng_text := bullish_eng_text + (prev_bearish ? "âœ“" : "âœ—") + "prv_bear "
    bullish_eng_text := bullish_eng_text + (engulfs_body ? "âœ“" : "âœ—") + "engulf "
    bullish_eng_text := bullish_eng_text + (is_deepest ? "âœ“" : "âœ—") + "deep"

    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". Bullish Eng Conds", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, bullish_eng_text, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)
    row := row + 1

// Engulfing pattern conditions (bearish)
if supply_triggered and bar_index > 0
    bool current_bearish = close < open
    bool prev_bullish = close[1] > open[1]
    bool engulfs_body = close <= open[1]
    bool is_deepest = high >= supply_highest_high or high[1] >= supply_highest_high

    string bearish_eng_text = ""
    bearish_eng_text := bearish_eng_text + (current_bearish ? "âœ“" : "âœ—") + "cur_bear "
    bearish_eng_text := bearish_eng_text + (prev_bullish ? "âœ“" : "âœ—") + "prv_bull "
    bearish_eng_text := bearish_eng_text + (engulfs_body ? "âœ“" : "âœ—") + "engulf "
    bearish_eng_text := bearish_eng_text + (is_deepest ? "âœ“" : "âœ—") + "deep"

    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". Bearish Eng Conds", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, bearish_eng_text, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)
    row := row + 1

// BPR FVG Active Status (ALWAYS VISIBLE for zombie diagnosis)
string bpr_fvg_active_text = bpr_fvg_active ? "âœ“ TRUE" : "âœ— FALSE"
color bpr_fvg_active_bg = bpr_fvg_active ? color.new(color.red, 85) : value_bgcolor
table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". BPR FVG Active", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, row, bpr_fvg_active_text, text_color=color.black, bgcolor=bpr_fvg_active_bg, text_size=size.small)
row := row + 1

// INV FVG Active Status (ALWAYS VISIBLE for zombie diagnosis)
string inv_fvg_active_text = inv_fvg_active ? "âœ“ TRUE" : "âœ— FALSE"
color inv_fvg_active_bg = inv_fvg_active ? color.new(color.red, 85) : value_bgcolor
table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". INV FVG Active", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, row, inv_fvg_active_text, text_color=color.black, bgcolor=inv_fvg_active_bg, text_size=size.small)
row := row + 1

// Trade Entry Bar (ALWAYS VISIBLE for stuck trade diagnosis)
string entry_bar_text = "-"
color entry_bar_bg = value_bgcolor
if order_placed_bar >= 0
    int bars_ago = bar_index - order_placed_bar
    entry_bar_text := str.tostring(order_placed_bar) + " (" + str.tostring(bars_ago) + " bars ago)"
    entry_bar_bg := bars_ago > 20 ? color.new(color.orange, 85) : value_bgcolor  // Highlight if old
table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". Trade Entry Bar", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, row, entry_bar_text, text_color=color.black, bgcolor=entry_bar_bg, text_size=size.small)
row := row + 1

// S&D Zone Levels
string supply_zone = "-"
if clear_supply
    supply_zone := "DISABLED"
else if supply_configured
    supply_zone := str.tostring(supply_bottom, format.mintick) + " - " + str.tostring(supply_top, format.mintick)
table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". Supply Zone", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, row, supply_zone, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)
row := row + 1

string demand_zone = "-"
color demand_zone_bgcolor = value_bgcolor
if clear_demand
    demand_zone := "DISABLED"
else if demand_configured
    demand_zone := str.tostring(demand_bottom, format.mintick) + " - " + str.tostring(demand_top, format.mintick)
table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". Demand Zone", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, row, demand_zone, text_color=color.black, bgcolor=demand_zone_bgcolor, text_size=size.small)
row := row + 1

// ENG OB Active Status (ALWAYS VISIBLE)
string eng_ob_active_text = eng_ob_active ? "âœ“ TRUE" : "âœ— FALSE"
color eng_ob_active_bg = eng_ob_active ? color.new(color.green, 85) : value_bgcolor
table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". ENG OB Active", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, row, eng_ob_active_text, text_color=color.black, bgcolor=eng_ob_active_bg, text_size=size.small)
row := row + 1

// MSS OB Active Status (ALWAYS VISIBLE) - shows if MSS entry logic is active
bool mss_ob_looking_for_entry = eng_ob_active and use_mss_ob and not entry_signal_active
string mss_ob_active_text = mss_ob_looking_for_entry ? "âœ“ TRUE" : "âœ— FALSE"
color mss_ob_active_bg = mss_ob_looking_for_entry ? color.new(color.green, 85) : value_bgcolor
table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". MSS OB Active", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, row, mss_ob_active_text, text_color=color.black, bgcolor=mss_ob_active_bg, text_size=size.small)
row := row + 1

// Session Levels - REMOVED (rows 11-13 reserved for future use)
// If re-enabled, use hardcoded row numbers like:
// table.cell(debugTable, 0, 11, "#11. London Low", ...)
// table.cell(debugTable, 0, 12, "#12. Prev Day High", ...)
// table.cell(debugTable, 0, 13, "#13. Prev Day Low", ...)

// ============================================================================
// MSS OB SPECIFIC (only when eng_ob_active AND bar_index is valid)
// ============================================================================
if eng_ob_active and not na(eng_ob_bar_index)
    // Divider
    color eng_divider_color = color.new(color.gray, 50)
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". MSS OB DEBUG", text_color=color.white, bgcolor=eng_divider_color, text_size=size.small)
    table.cell(debugTable, 1, row, "", text_color=color.black, bgcolor=eng_divider_color, text_size=size.small)
    row := row + 1

    // DIAGNOSTIC: What are the ACTUAL values when this section renders?
    string diagnostic_active = "active=" + str.tostring(eng_ob_active)
    string diagnostic_bar = "ob_bar=" + (na(eng_ob_bar_index) ? "na" : str.tostring(eng_ob_bar_index))
    string diagnostic_current = "cur=" + str.tostring(bar_index)
    string diagnostic_window = "in_window=" + str.tostring(in_trading_window)
    string diagnostic_new = "new=" + str.tostring(barstate.isnew)
    string diagnostic_all = diagnostic_active + " | " + diagnostic_bar + " | " + diagnostic_current + " | " + diagnostic_window + " | " + diagnostic_new
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". DIAGNOSTIC", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, diagnostic_all, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)
    row := row + 1

    // Engulfing OB Status
    string eng_status = "âœ“"
    color eng_bgcolor = value_bgcolor
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". Engulfing OB", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, eng_status, text_color=color.black, bgcolor=eng_bgcolor, text_size=size.small)
    row := row + 1

    // MSS Fractal Level
    string fractal_level = "-"
    if use_mss_ob
        if not na(target_fractal_level_mss)
            fractal_level := str.tostring(target_fractal_level_mss, format.mintick) + (eng_ob_is_bullish ? " (â†‘)" : " (â†“)")
        else
            fractal_level := "SEARCHING"
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". MSS Fractal", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, fractal_level, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)
    row := row + 1

    // ENG OB Bar Index (shows where the ENG OB candle is)
    string eng_bar_text = na(eng_ob_bar_index) ? "na" : str.tostring(eng_ob_bar_index)
    if not na(eng_ob_bar_index)
        int bars_ago = bar_index - eng_ob_bar_index
        // EXPLICIT DEBUG: Show the actual calculation
        eng_bar_text := eng_bar_text + " | cur=" + str.tostring(bar_index) + " | diff=" + str.tostring(bars_ago)
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". ENG OB Bar", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, eng_bar_text, text_color=color.black, bgcolor=color.new(color.yellow, 0), text_size=size.small)
    row := row + 1

    // Should Invalidate Timeout (shows if timeout logic would fire)
    // Recalculate the timeout logic here for display
    bool should_invalidate_timeout_display = false
    string timeout_reason_display = "-"
    if not na(eng_ob_bar_index)
        if not trade_entered
            int bars_since_setup = bar_index - eng_ob_bar_index
            if bars_since_setup >= max_setup_bars
                should_invalidate_timeout_display := true
                timeout_reason_display := "Max bars (" + str.tostring(bars_since_setup) + "/" + str.tostring(max_setup_bars) + ")"

        int current_hour = hour(time, "America/New_York")
        int current_minute = minute(time, "America/New_York")
        int current_time_mins = current_hour * 60 + current_minute
        int end_time_mins = trading_end_hour * 60 + trading_end_minute

        if current_time_mins >= end_time_mins
            should_invalidate_timeout_display := true
            string end_time_str = str.tostring(trading_end_hour) + ":" + (trading_end_minute < 10 ? "0" : "") + str.tostring(trading_end_minute)
            timeout_reason_display := timeout_reason_display == "-" ? end_time_str + " NY time" : timeout_reason_display + " + " + end_time_str

    string timeout_text = should_invalidate_timeout_display ? "YES: " + timeout_reason_display : "NO"
    color timeout_bg = should_invalidate_timeout_display ? color.new(color.red, 85) : color.new(color.green, 85)
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". Should Timeout", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, timeout_text, text_color=color.black, bgcolor=timeout_bg, text_size=size.small)
    row := row + 1

// ============================================================================
// BPR FVG / INVERTED FVG DEBUG (combined - only when either is active)
// ============================================================================
if bpr_fvg_active or inv_fvg_active
    // Divider
    color fvg_divider_color = color.new(color.gray, 50)
    string fvg_title = bpr_fvg_active ? "BPR FVG DEBUG" : "INVERTED FVG DEBUG"
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". " + fvg_title, text_color=color.white, bgcolor=fvg_divider_color, text_size=size.small)
    table.cell(debugTable, 1, row, "", text_color=color.white, bgcolor=fvg_divider_color, text_size=size.small)
    row := row + 1

    // Determine if entry is active for this FVG type
    bool fvg_entry_active = entry_signal_active and (active_entry_strategy == "BPR FVG" or active_entry_strategy == "Inverted FVG")

    // Determine trade direction to use correct colors - SUBTLE
    // For BPR FVG: trade direction is INVERTED from FVG direction
    // For Inverted FVG: trade direction matches the variable
    bool fvg_trade_is_bullish = bpr_fvg_active ? not bpr_fvg_is_bullish : inv_fvg_is_bullish
    color valid_color = fvg_trade_is_bullish ? color.new(color.green, 85) : color.new(color.red, 85)
    color invalid_color = fvg_trade_is_bullish ? color.new(color.red, 85) : color.new(color.green, 85)
    color neutral_color = value_bgcolor

    // RAW BOOLEAN DEBUG - Shows the actual variable states (ALWAYS VISIBLE for zombie diagnosis)
    // Header row
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". BOOL DEBUG", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.small)
    table.cell(debugTable, 1, row, "", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.small)
    row := row + 1

    // bpr_fvg_active
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". bpr_fvg_active", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    color bpr_active_bg = bpr_fvg_active ? color.new(color.red, 85) : value_bgcolor
    table.cell(debugTable, 1, row, str.tostring(bpr_fvg_active), text_color=color.black, bgcolor=bpr_active_bg, text_size=size.small)
    row := row + 1

    // inv_fvg_active
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". inv_fvg_active", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    color inv_active_bg = inv_fvg_active ? color.new(color.red, 85) : value_bgcolor
    table.cell(debugTable, 1, row, str.tostring(inv_fvg_active), text_color=color.black, bgcolor=inv_active_bg, text_size=size.small)
    row := row + 1

    // entry_signal_active
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". entry_signal_active", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, str.tostring(entry_signal_active), text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)
    row := row + 1

    // trade_entered
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". trade_entered", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, str.tostring(trade_entered), text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)
    row := row + 1

    // order_placed
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". order_placed", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, str.tostring(order_placed), text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)
    row := row + 1

    // bpr_fvg_bar_index
    string fvg_bar_index_str = na(bpr_fvg_bar_index) ? "na" : str.tostring(bpr_fvg_bar_index)
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". bpr_fvg_bar_index", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, fvg_bar_index_str, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)
    row := row + 1

    // bar_index
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". bar_index", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, str.tostring(bar_index), text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)
    row := row + 1

    // Bars since BPR FVG was last set to true (helps debug zombie states)
    string bars_since_active = "never"
    if not na(bpr_fvg_bar_index)
        int bars_ago = bar_index - bpr_fvg_bar_index
        bars_since_active := str.tostring(bars_ago) + " bars ago"
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". bars since detect", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, bars_since_active, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)
    row := row + 1

    // BARS BACK - Shows how long ago FVG was detected
    string bars_back_text = "NEVER"
    color bars_back_bg = value_bgcolor
    if not na(bpr_fvg_bar_index)
        int bars_back = bar_index - bpr_fvg_bar_index
        bars_back_text := str.tostring(bars_back) + " bars ago"
        // Red if zombie (bar_index set but not active)
        bars_back_bg := bpr_fvg_active ? value_bgcolor : color.new(color.red, 85)
    else if not na(inv_fvg_bar_index)
        int bars_back = bar_index - inv_fvg_bar_index
        bars_back_text := str.tostring(bars_back) + " bars ago"
        bars_back_bg := inv_fvg_active ? value_bgcolor : color.new(color.red, 85)
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". BARS BACK", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, bars_back_text, text_color=color.black, bgcolor=bars_back_bg, text_size=size.small)
    row := row + 1

    // SETUP TIMEOUT COUNTER - Shows bars since FVG detection and timeout progress (moved below BARS BACK)
    string setup_timeout_debug = "-"
    color setup_timeout_bg = value_bgcolor
    if not na(bpr_fvg_bar_index)
        int bars_since_detection = bar_index - bpr_fvg_bar_index
        setup_timeout_debug := str.tostring(bars_since_detection) + " / " + str.tostring(setup_timeout_bars) + " bars"
        // Subtle red if past timeout, otherwise color code by proximity
        if bars_since_detection >= setup_timeout_bars
            setup_timeout_bg := color.new(color.red, 85)
        else if bars_since_detection >= setup_timeout_bars * 0.8
            setup_timeout_bg := color.new(color.red, 90)
        else if bars_since_detection >= setup_timeout_bars * 0.6
            setup_timeout_bg := value_bgcolor
        else
            setup_timeout_bg := color.new(color.green, 90)
    else if not na(inv_fvg_bar_index)
        int bars_since_detection = bar_index - inv_fvg_bar_index
        setup_timeout_debug := str.tostring(bars_since_detection) + " / " + str.tostring(setup_timeout_bars) + " bars"
        if bars_since_detection >= setup_timeout_bars
            setup_timeout_bg := color.new(color.red, 85)
        else if bars_since_detection >= setup_timeout_bars * 0.8
            setup_timeout_bg := color.new(color.red, 90)
        else if bars_since_detection >= setup_timeout_bars * 0.6
            setup_timeout_bg := value_bgcolor
        else
            setup_timeout_bg := color.new(color.green, 90)
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". SETUP TIMEOUT", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, setup_timeout_debug, text_color=color.black, bgcolor=setup_timeout_bg, text_size=size.small)
    row := row + 1

    // Close Price Check - moved up before ENTRY TIMEOUT
    string close_check_text = "-"
    bool close_check_valid = false
    if bpr_fvg_active
        string comparison = ""
        bool would_breach = false
        if bpr_fvg_is_bullish
            would_breach := close < bpr_fvg_bottom
            comparison := str.tostring(close, format.mintick) + " < " + str.tostring(bpr_fvg_bottom, format.mintick)
        else
            would_breach := close > bpr_fvg_top
            comparison := str.tostring(close, format.mintick) + " > " + str.tostring(bpr_fvg_top, format.mintick)
        close_check_text := (would_breach ? "âœ“ " : "âœ— ") + comparison
        close_check_valid := would_breach
    else if inv_fvg_active
        bool in_overlap = close >= inv_fvg_overlap_bottom and close <= inv_fvg_overlap_top
        close_check_text := (in_overlap ? "âœ“ " : "âœ— ") + "In Overlap"
        close_check_valid := in_overlap
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". Close Check", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, close_check_text, text_color=color.black, bgcolor=close_check_valid ? valid_color : invalid_color, text_size=size.small)
    row := row + 1

    // ENTRY TIMEOUT COUNTER - Shows bars since entry signal and timeout progress
    string entry_timeout_debug = "-"
    color entry_timeout_bg = value_bgcolor
    if entry_signal_active and not na(entry_signal_bar_index)
        int bars_since_entry = bar_index - entry_signal_bar_index
        entry_timeout_debug := str.tostring(bars_since_entry) + " / " + str.tostring(entry_timeout_bars) + " bars"
        // Color code: green if far from timeout, subtle variations
        if bars_since_entry >= entry_timeout_bars
            entry_timeout_bg := color.new(color.red, 85)
        else if bars_since_entry >= entry_timeout_bars * 0.8
            entry_timeout_bg := color.new(color.red, 90)
        else if bars_since_entry >= entry_timeout_bars * 0.6
            entry_timeout_bg := value_bgcolor
        else
            entry_timeout_bg := color.new(color.green, 90)
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". ENTRY TIMEOUT", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, entry_timeout_debug, text_color=color.black, bgcolor=entry_timeout_bg, text_size=size.small)
    row := row + 1

    // Size + Levels (consolidated)
    string fvg_size_text = "-"
    bool size_valid = false
    if bpr_fvg_active and not na(bpr_fvg_top) and not na(bpr_fvg_bottom)
        float fvg_size = bpr_fvg_top - bpr_fvg_bottom
        float fvg_ticks = fvg_size / syminfo.mintick
        fvg_size_text := str.tostring(fvg_ticks, "#.#") + " ticks | " + str.tostring(bpr_fvg_bottom, format.mintick) + " - " + str.tostring(bpr_fvg_top, format.mintick)
        size_valid := fvg_ticks >= bpr_fvg_min_ticks
    else if inv_fvg_active and not na(inv_fvg_overlap_top) and not na(inv_fvg_overlap_bottom)
        float overlap_size = inv_fvg_overlap_top - inv_fvg_overlap_bottom
        float overlap_ticks = overlap_size / syminfo.mintick
        fvg_size_text := str.tostring(overlap_ticks, "#.#") + " ticks | " + str.tostring(inv_fvg_overlap_bottom, format.mintick) + " - " + str.tostring(inv_fvg_overlap_top, format.mintick)
        size_valid := true  // Inverted FVG always valid once formed
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". Size + Levels", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, fvg_size_text, text_color=color.black, bgcolor=size_valid ? valid_color : neutral_color, text_size=size.small)
    row := row + 1

    // Strategy Enabled Check
    string enabled_text = "-"
    bool strategy_enabled = false
    if bpr_fvg_active
        enabled_text := use_bpr_fvg ? "âœ“ Enabled" : "âœ— Disabled"
        strategy_enabled := use_bpr_fvg
    else if inv_fvg_active
        enabled_text := use_inverted_fvg ? "âœ“ Enabled" : "âœ— Disabled"
        strategy_enabled := use_inverted_fvg
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". Strategy", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, enabled_text, text_color=color.black, bgcolor=strategy_enabled ? valid_color : invalid_color, text_size=size.small)
    row := row + 1

    // ========================================================================
    // SETUP MONITOR ROWS (appended from separate table)
    // ========================================================================

    // Common colors for setup monitor
    color setup_valid_bg = color.new(color.green, 85)
    color setup_invalid_bg = color.new(color.red, 85)
    color setup_neutral_bg = value_bgcolor

    // 1. FVG Pattern Type
    string setup_pattern_type = inv_fvg_active ? "INV FVG" : "BPR FVG"
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". Pattern Type", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, setup_pattern_type, text_color=color.black, bgcolor=setup_valid_bg, text_size=size.small)
    row := row + 1

    // 2. Bars Back (middle candle)
    string setup_bars_back_text = "-"
    if not na(bpr_fvg_bar_index)
        int setup_bars_back = bar_index - bpr_fvg_bar_index
        setup_bars_back_text := str.tostring(setup_bars_back) + " bars ago"
    else if not na(inv_fvg_bar_index)
        int setup_bars_back = bar_index - inv_fvg_bar_index
        setup_bars_back_text := str.tostring(setup_bars_back) + " bars ago"
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". Bars Back", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, setup_bars_back_text, text_color=color.black, bgcolor=setup_neutral_bg, text_size=size.small)
    row := row + 1

    // 3. Min Tick Size (show comparison: actual vs required)
    string setup_tick_size_text = "-"
    bool setup_tick_size_valid = false
    if bpr_fvg_active and not na(bpr_fvg_top) and not na(bpr_fvg_bottom)
        float setup_fvg_size = bpr_fvg_top - bpr_fvg_bottom
        float setup_actual_ticks = setup_fvg_size / syminfo.mintick
        float setup_required_ticks = bpr_fvg_min_ticks

        // Format: "2.5 > 2.0" or "1.5 < 2.0" or "2.0 = 2.0"
        string setup_comparison = setup_actual_ticks > setup_required_ticks ? " > " : (setup_actual_ticks < setup_required_ticks ? " < " : " = ")
        setup_tick_size_text := str.tostring(setup_actual_ticks, "#.#") + setup_comparison + str.tostring(setup_required_ticks, "#.#")
        setup_tick_size_valid := setup_actual_ticks >= setup_required_ticks
    else if inv_fvg_active and not na(inv_fvg_overlap_top) and not na(inv_fvg_overlap_bottom)
        float setup_overlap_size = inv_fvg_overlap_top - inv_fvg_overlap_bottom
        float setup_actual_ticks = setup_overlap_size / syminfo.mintick
        float setup_required_ticks = bpr_fvg_min_ticks  // Use same min tick requirement

        string setup_comparison = setup_actual_ticks > setup_required_ticks ? " > " : (setup_actual_ticks < setup_required_ticks ? " < " : " = ")
        setup_tick_size_text := str.tostring(setup_actual_ticks, "#.#") + setup_comparison + str.tostring(setup_required_ticks, "#.#")
        setup_tick_size_valid := setup_actual_ticks >= setup_required_ticks
    color setup_tick_bg = setup_tick_size_valid ? setup_valid_bg : setup_invalid_bg
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". Tick Size", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, setup_tick_size_text, text_color=color.black, bgcolor=setup_tick_bg, text_size=size.small)
    row := row + 1

    // 4. Close Below/Above FVG
    string setup_close_breach_text = "-"
    bool setup_close_breached = false
    if bpr_fvg_active
        if bpr_fvg_is_bullish
            // Bullish FVG (bearish trade): check close < FVG bottom
            setup_close_breached := close < bpr_fvg_bottom
            setup_close_breach_text := (setup_close_breached ? "âœ“ " : "âœ— ") + "Close < FVG"
        else
            // Bearish FVG (bullish trade): check close > FVG top
            setup_close_breached := close > bpr_fvg_top
            setup_close_breach_text := (setup_close_breached ? "âœ“ " : "âœ— ") + "Close > FVG"
    else if inv_fvg_active
        // Inverted FVG: check if close is in overlap zone
        setup_close_breached := close >= inv_fvg_overlap_bottom and close <= inv_fvg_overlap_top
        setup_close_breach_text := (setup_close_breached ? "âœ“ " : "âœ— ") + "In Overlap"
    color setup_close_bg = setup_close_breached ? setup_valid_bg : setup_invalid_bg
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". Entry Trigger", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, setup_close_breach_text, text_color=color.black, bgcolor=setup_close_bg, text_size=size.small)
    row := row + 1

    // 5. INV FVG Formed
    string setup_inv_formed_text = inv_fvg_active ? "âœ“ YES" : "âœ— NO"
    color setup_inv_bg = inv_fvg_active ? setup_valid_bg : setup_neutral_bg
    table.cell(debugTable, 0, row, "#" + str.tostring(row) + ". INV FVG", text_color=color.white, bgcolor=label_bgcolor, text_size=size.small)
    table.cell(debugTable, 1, row, setup_inv_formed_text, text_color=color.black, bgcolor=setup_inv_bg, text_size=size.small)
    row := row + 1

// ============================================================================
// DAILY STATS TABLE (HIDDEN FOR DEBUGGING)
// ============================================================================
// var table statsTable = table.new(position.bottom_right, 2, 5, border_width=1)
//
// color stats_label_bg = color.new(color.black, 20)
// color stats_value_bg = color.new(color.gray, 30)
//
// // Title row
// table.cell(statsTable, 0, 0, "TODAY'S STATS", text_color=color.white, bgcolor=color.new(color.blue, 30), text_size=size.normal)
// table.cell(statsTable, 1, 0, "", text_color=color.white, bgcolor=color.new(color.blue, 30), text_size=size.normal)
//
// // Trades count
// string trades_text = str.tostring(today_trade_count)
// table.cell(statsTable, 0, 1, "Trades", text_color=color.white, bgcolor=stats_label_bg, text_size=size.normal)
// table.cell(statsTable, 1, 1, trades_text, text_color=color.white, bgcolor=stats_value_bg, text_size=size.normal)
//
// // Wins
// string wins_text = str.tostring(today_wins)
// table.cell(statsTable, 0, 2, "Wins", text_color=color.white, bgcolor=stats_label_bg, text_size=size.normal)
// table.cell(statsTable, 1, 2, wins_text, text_color=color.white, bgcolor=color.new(color.green, 50), text_size=size.normal)
//
// // Losses
// string losses_text = str.tostring(today_losses)
// table.cell(statsTable, 0, 3, "Losses", text_color=color.white, bgcolor=stats_label_bg, text_size=size.normal)
// table.cell(statsTable, 1, 3, losses_text, text_color=color.white, bgcolor=color.new(color.red, 50), text_size=size.normal)
//
// // P&L
// string pnl_text = (today_pnl >= 0 ? "+" : "") + str.tostring(today_pnl, "#.##")
// color pnl_bg = today_pnl > 0 ? color.new(color.green, 30) : (today_pnl < 0 ? color.new(color.red, 30) : stats_value_bg)
// table.cell(statsTable, 0, 4, "P&L", text_color=color.white, bgcolor=stats_label_bg, text_size=size.normal)
// table.cell(statsTable, 1, 4, pnl_text, text_color=color.white, bgcolor=pnl_bg, text_size=size.normal)
