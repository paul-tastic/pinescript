//@version=5
strategy("Nexus Strategy Manual", overlay=true, initial_capital=10000, default_qty_type=strategy.fixed, default_qty_value=1)

// ============================================================================
// INPUTS - MANUAL ZONES
// ============================================================================
supply_top = input.float(0.0, "Supply Zone Top", group="Manual Zones")
supply_bottom = input.float(0.0, "Supply Zone Bottom", group="Manual Zones")
clear_supply = input.bool(false, "Disable Supply Zone", group="Manual Zones", tooltip="Check to temporarily disable supply zone without clearing values")

demand_top = input.float(0.0, "Demand Zone Top", group="Manual Zones")
demand_bottom = input.float(0.0, "Demand Zone Bottom", group="Manual Zones")
clear_demand = input.bool(false, "Disable Demand Zone", group="Manual Zones", tooltip="Check to temporarily disable demand zone without clearing values")

show_zones = input.bool(true, "Show Zones", group="Manual Zones", tooltip="Show/hide zone boxes on chart")

// ============================================================================
// INPUTS - TRADING WINDOW
// ============================================================================
trading_start_hour = input.int(9, "Trading Start Hour", minval=0, maxval=23, group="Trading Window", tooltip="Hour to start trading (NY time)")
trading_start_minute = input.int(30, "Trading Start Minute", minval=0, maxval=59, group="Trading Window", tooltip="Minute to start trading (NY time)")
trading_end_hour = input.int(16, "Trading End Hour", minval=0, maxval=23, group="Trading Window", tooltip="Hour to end trading (NY time)")
trading_end_minute = input.int(45, "Trading End Minute", minval=0, maxval=59, group="Trading Window", tooltip="Minute to end trading (NY time)")

// ============================================================================
// INPUTS - TRADE SETTINGS
// ============================================================================
risk_per_trade = input.float(500.0, "Risk Per Trade ($)", minval=1.0, group="Trade Settings", tooltip="Dollar amount to risk per trade")
max_setup_bars = input.int(100, "Max Setup Age (bars)", minval=1, group="Trade Settings", tooltip="Maximum number of bars before setup is invalidated")
grace_ticks = input.float(0.0, "Grace Ticks (SL Padding)", minval=0.0, step=0.25, group="Trade Settings", tooltip="Add extra ticks to stop loss for safety margin (maintains 2:1 RR)")

// ============================================================================
// INPUTS - ENTRY STRATEGIES (can enable multiple)
// ============================================================================
use_mss_ob = input.bool(true, "MSS OB", group="Entry Strategies", tooltip="Market Structure Shift Order Block - enters when price crosses opposite fractal level")
use_bpr_fvg = input.bool(false, "Balanced Price Range FVG", group="Entry Strategies", tooltip="Fair Value Gap within balanced price range")
bpr_fvg_min_ticks = input.float(2.0, "BPR FVG Min Size (ticks)", minval=0.0, step=0.25, group="Entry Strategies", tooltip="Minimum FVG size in ticks - smaller FVGs will be ignored")
use_inverted_fvg = input.bool(false, "Inverted FVG", group="Entry Strategies", tooltip="Inverted Fair Value Gap entry")
use_breaker_block = input.bool(false, "Breaker Block", group="Entry Strategies", tooltip="Breaker Block entry pattern")

// ============================================================================
// ZONE DETECTION
// ============================================================================
// Apply clear flags - if clear is checked, treat zone as not configured
bool supply_configured = not clear_supply and supply_top > 0 and supply_bottom > 0 and supply_top > supply_bottom
bool demand_configured = not clear_demand and demand_top > 0 and demand_bottom > 0 and demand_top > demand_bottom

// Check if candle touches zone (high/low overlap with zone range)
// Uses real-time high/low so it triggers immediately when zone is touched
bool in_supply = supply_configured and not (low > supply_top or high < supply_bottom)
bool in_demand = demand_configured and not (low > demand_top or high < demand_bottom)

// ============================================================================
// TRADING WINDOW CHECK
// ============================================================================
// Convert current time to minutes since midnight for easier comparison
int current_time_minutes = hour(time, "America/New_York") * 60 + minute(time, "America/New_York")
int trading_start_minutes = trading_start_hour * 60 + trading_start_minute
int trading_end_minutes = trading_end_hour * 60 + trading_end_minute

// Check if we're within trading window
bool in_trading_window = current_time_minutes >= trading_start_minutes and current_time_minutes <= trading_end_minutes


// ============================================================================
// SESSION HIGH/LOW TRACKING
// ============================================================================
// Session times (America/New_York):
// - Asian: 20:00 - 00:00 (previous day 8pm to midnight)
// - London: 03:00 - 12:00
// - Previous Day: 00:00 - 00:00 (full previous trading day)

// Track session highs and lows
var float asian_high = na
var float asian_low = na
var float london_high = na
var float london_low = na
var float prev_day_high = na
var float prev_day_low = na

// Track if sessions have been crossed (invalidated)
var bool asian_high_crossed = false
var bool asian_low_crossed = false
var bool london_high_crossed = false
var bool london_low_crossed = false
var bool prev_day_high_crossed = false
var bool prev_day_low_crossed = false

// Track lines for visual display
var line asian_high_line = na
var line asian_low_line = na
var line london_high_line = na
var line london_low_line = na
var line prev_day_high_line = na
var line prev_day_low_line = na

// Get current time
int hour_et = hour(time, "America/New_York")
int day_of_month = dayofmonth(time, "America/New_York")

// Track session high/low during their respective periods
// Asian session: 20:00 - 00:00 (8pm to midnight)
bool in_asian_session = hour_et >= 20 or hour_et < 0
if in_asian_session
    if na(asian_high) or high > asian_high
        asian_high := high
    if na(asian_low) or low < asian_low
        asian_low := low

        // do NOT reset asian hi/lo at NY midnight. instead of resetting at midnight, reset at next asian session
else if hour_et == 0 and minute(time, "America/New_York") == 0
    // Reset at midnight (start of new day)
    asian_high := na
    asian_low := na
    asian_high_crossed := false
    asian_low_crossed := false

// London session: 03:00 - 12:00
bool in_london_session = hour_et >= 3 and hour_et < 12
if in_london_session
    if na(london_high) or high > london_high
        london_high := high
    if na(london_low) or low < london_low
        london_low := low
else if hour_et == 3 and minute(time, "America/New_York") == 0
    // Reset at London open
    london_high := na
    london_low := na
    london_high_crossed := false
    london_low_crossed := false

// Previous Day high/low: track full previous day, reset at midnight
var float temp_day_high = na
var float temp_day_low = na
var int last_tracked_day = na

if barstate.isnew
    int current_day = dayofmonth(time, "America/New_York")

    // At start of new day (midnight ET), save yesterday's high/low as prev_day
    if not na(last_tracked_day) and current_day != last_tracked_day
        prev_day_high := temp_day_high
        prev_day_low := temp_day_low
        prev_day_high_crossed := false
        prev_day_low_crossed := false

        // Reset temp tracking for new day
        temp_day_high := high
        temp_day_low := low
    else
        // Continue tracking current day's high/low
        if na(temp_day_high) or high > temp_day_high
            temp_day_high := high
        if na(temp_day_low) or low < temp_day_low
            temp_day_low := low

    last_tracked_day := current_day

// Check for crosses and invalidate levels
if not asian_high_crossed and not na(asian_high) and high >= asian_high
    asian_high_crossed := true
if not asian_low_crossed and not na(asian_low) and low <= asian_low
    asian_low_crossed := true

if not london_high_crossed and not na(london_high) and high >= london_high
    london_high_crossed := true
if not london_low_crossed and not na(london_low) and low <= london_low
    london_low_crossed := true

if not prev_day_high_crossed and not na(prev_day_high) and high >= prev_day_high
    prev_day_high_crossed := true
if not prev_day_low_crossed and not na(prev_day_low) and low <= prev_day_low
    prev_day_low_crossed := true

// Session level lines removed - keep it simple

// ============================================================================
// ZONE VISUALIZATION - Draw zones from 09:00 to 16:00 current day
// ============================================================================
// Get current time info
int current_hour = hour(time, "America/New_York")
int current_minute = minute(time, "America/New_York")
bool is_new_day = ta.change(dayofmonth(time, "America/New_York")) != 0

// Track zone boxes
var box supply_zone_box = na
var box demand_zone_box = na
var int zone_start_bar = na

// At 09:00, create new zone boxes for the day
if current_hour == 9 and current_minute == 0 and is_new_day
    zone_start_bar := bar_index

    // Delete old boxes
    if not na(supply_zone_box)
        box.delete(supply_zone_box)
    if not na(demand_zone_box)
        box.delete(demand_zone_box)

    // Create supply zone box (only if show_zones is enabled)
    if show_zones and supply_configured
        supply_zone_box := box.new(bar_index, supply_top, bar_index + 1, supply_bottom,
                                   border_color=color.red,
                                   bgcolor=color.new(color.red, 90),
                                   border_width=1,
                                   extend=extend.none)

    // Create demand zone box (only if show_zones is enabled)
    if show_zones and demand_configured
        demand_zone_box := box.new(bar_index, demand_top, bar_index + 1, demand_bottom,
                                   border_color=color.blue,
                                   bgcolor=color.new(color.blue, 90),
                                   border_width=1,
                                   extend=extend.none)

// Update zone boxes to extend to current bar (between 09:00 and 16:00)
if show_zones and current_hour >= 9 and current_hour < 16
    if supply_configured and not na(supply_zone_box)
        box.set_right(supply_zone_box, bar_index + 1)
    if demand_configured and not na(demand_zone_box)
        box.set_right(demand_zone_box, bar_index + 1)
else if show_zones and current_hour == 16 and current_minute == 0
    // Stop extending at 16:00
    if supply_configured and not na(supply_zone_box)
        box.set_right(supply_zone_box, bar_index)
    if demand_configured and not na(demand_zone_box)
        box.set_right(demand_zone_box, bar_index)

// If show_zones is disabled, delete any existing boxes
if not show_zones
    if not na(supply_zone_box)
        box.delete(supply_zone_box)
        supply_zone_box := na
    if not na(demand_zone_box)
        box.delete(demand_zone_box)
        demand_zone_box := na

// Track zone entry - stays true while in zone OR while setup is active
var bool supply_triggered = false
var bool demand_triggered = false
var int supply_trigger_bar = -1
var int demand_trigger_bar = -1

// Track deepest penetration into zones (resets on fresh entry)
var float demand_lowest_low = na
var float supply_highest_high = na

// Track deepest HISTORICAL penetration (for validating new ENG OBs must be deeper)
var float demand_deepest_ever = na  // Deepest low ever reached in demand zone
var float supply_deepest_ever = na  // Highest high ever reached in supply zone

// Track if we're completely outside both zones (ready to reset)
var bool was_outside_zones = true

// Track if ENG OB is active (declare early so it can be used in zone logic)
var bool eng_ob_active = false
var bool eng_ob_is_bullish = false
var float eng_ob_deepest_level = na
var int eng_ob_bar_index = na
var float eng_ob_candle_high = na
var float eng_ob_candle_low = na
var box eng_ob_box = na  // Yellow box around ENG OB candle for visual debug

// Track ENTRY SIGNALS - generic for all entry strategies
var bool entry_signal_active = false  // Any entry strategy has triggered
var string active_entry_strategy = ""  // Which strategy triggered (for display/debug)
var bool entry_is_bullish = false  // Trade direction: true = long, false = short
var float entry_price = na  // Entry price (regardless of strategy)
var float entry_tp = na     // Take profit level
var float entry_sl = na     // Stop loss level

// Track MSS OB specific state (one of four entry strategies)
var float target_fractal_level_mss = na  // Fractal level for MSS OB strategy

// Track BPR FVG specific state
var bool bpr_fvg_active = false  // BPR FVG has been detected
var bool bpr_fvg_is_bullish = false  // True = bullish FVG (in supply), False = bearish FVG (in demand)
var float bpr_fvg_top = na  // Top of the FVG
var float bpr_fvg_bottom = na  // Bottom of the FVG
var float bpr_fvg_invalidation_level = na  // Highest/lowest of 3-candle pattern for invalidation
var int bpr_fvg_bar_index = na  // Bar index where FVG was detected
var box bpr_fvg_box = na  // Yellow box around FVG
var string bpr_fvg_invalidation_reason = ""  // Track why BPR FVG was cleared (for debugging)

// Track Inverted FVG specific state
// TODO: Add Inverted FVG variables when implementing

// Track Breaker Block specific state
// TODO: Add Breaker Block variables when implementing

// Track TP/SL indicator boxes - use arrays to persist multiple boxes throughout the day
var array<box> daily_tp_boxes = array.new<box>()
var array<box> daily_sl_boxes = array.new<box>()
var box tp_box = na  // Current active TP box
var box sl_box = na  // Current active SL box

// Track if we've already entered a trade for this setup
var bool trade_entered = false

// Track if limit order has been placed for current entry signal
var bool order_placed = false
var int order_placed_bar = -1  // Track which bar the order was placed on

// Track the bar on which the last trade exited (prevent same-bar re-entry)
var int last_exit_bar = -1

// Track bars to wait after exit before allowing new setups (cooldown period)
cooldown_bars = input.int(2, "Cooldown After Exit (bars)", minval=0, group="Trade Settings", tooltip="Number of bars to wait after trade exit before detecting new setups")

// ============================================================================
// DAILY PERFORMANCE TRACKING
// ============================================================================
var int today_trade_count = 0
var int today_wins = 0
var int today_losses = 0
var float today_pnl = 0.0
var int last_trade_day = na
var float last_position_entry = na  // Track entry price to calculate P&L

// Reset daily stats at midnight and clear old boxes at 20:00 (start of Asian session)
if barstate.isnew
    int current_day = dayofmonth(time, "America/New_York")
    int current_hour = hour(time, "America/New_York")
    int current_minute = minute(time, "America/New_York")

    // At midnight, reset daily stats
    if not na(last_trade_day) and current_day != last_trade_day
        today_trade_count := 0
        today_wins := 0
        today_losses := 0
        today_pnl := 0.0

    // At 09:00 NY time, reset deepest zone penetration tracking for the new trading day
    // Also invalidate any active setups from previous day
    if current_hour == 9 and current_minute == 0
        demand_deepest_ever := na
        supply_deepest_ever := na

        // Invalidate any active setups from previous day
        if eng_ob_active or entry_signal_active
            // Close any open positions and cancel pending orders
            strategy.close_all()
            strategy.cancel_all()

            eng_ob_active := false
            eng_ob_is_bullish := false
            eng_ob_deepest_level := na
            eng_ob_bar_index := na
            eng_ob_candle_high := na
            eng_ob_candle_low := na
            target_fractal_level_mss := na

            // Clear entry signals (all strategies)
            entry_signal_active := false
            active_entry_strategy := ""
            entry_price := na
            entry_tp := na
            entry_sl := na

            // Reset trade flags
            trade_entered := false
            order_placed := false
            order_placed_bar := -1

            // Delete yellow box
            if not na(eng_ob_box)
                box.delete(eng_ob_box)
                eng_ob_box := na

            // Delete TP/SL boxes
            if not na(tp_box)
                box.delete(tp_box)
                tp_box := na
            if not na(sl_box)
                box.delete(sl_box)
                sl_box := na

            // Clear BPR FVG state
            if not na(bpr_fvg_box)
                box.delete(bpr_fvg_box)
                bpr_fvg_box := na
            bpr_fvg_active := false
            bpr_fvg_is_bullish := false
            bpr_fvg_top := na
            bpr_fvg_bottom := na
            bpr_fvg_invalidation_level := na
            bpr_fvg_bar_index := na
            bpr_fvg_invalidation_reason := "9 AM reset"

    // At 20:00 (start of Asian session), clear all persisted boxes from the day
    if current_hour == 20
        // Delete all TP boxes - only if array has elements
        if array.size(daily_tp_boxes) > 0
            for i = 0 to array.size(daily_tp_boxes) - 1
                box.delete(array.get(daily_tp_boxes, i))
        array.clear(daily_tp_boxes)

        // Delete all SL boxes - only if array has elements
        if array.size(daily_sl_boxes) > 0
            for i = 0 to array.size(daily_sl_boxes) - 1
                box.delete(array.get(daily_sl_boxes, i))
        array.clear(daily_sl_boxes)

    last_trade_day := current_day

// Track when trade enters
if entry_signal_active and not trade_entered and strategy.position_size != 0
    last_position_entry := strategy.position_avg_price

// Track when trade exits and calculate P&L using strategy's closed trade P&L
var int last_closed_trades = 0
int current_closed_trades = strategy.closedtrades

if current_closed_trades > last_closed_trades
    // A new trade just closed - get the P&L from the most recent closed trade
    float trade_pnl = strategy.closedtrades.profit(strategy.closedtrades - 1)

    // Update daily stats
    today_trade_count += 1
    today_pnl += trade_pnl

    if trade_pnl > 0
        today_wins += 1
    else
        today_losses += 1

    last_closed_trades := current_closed_trades

// ============================================================================
// FORCE CLOSE AT TRADING WINDOW END - TOP LEVEL (runs every bar)
// ============================================================================
int check_hour = hour(time, "America/New_York")
int check_minute = minute(time, "America/New_York")
int check_time_mins = check_hour * 60 + check_minute
int end_time_mins = trading_end_hour * 60 + trading_end_minute

// Check if we're past trading end time and have an open position
if check_time_mins >= end_time_mins and strategy.position_size != 0
    // FIRST cancel all pending orders (including TP/SL exits)
    strategy.cancel_all()

    // THEN close the position
    if strategy.position_size > 0
        strategy.close("Long", comment="EOD Close")
    else if strategy.position_size < 0
        strategy.close("Short", comment="EOD Close")

// Check if currently outside both zones
bool outside_both_zones = not in_supply and not in_demand

if barstate.isnew
    // Clear trigger only if it's been more than 1 bar since entry AND no active setup
    // This keeps supply_triggered/demand_triggered true while a setup is tracking
    bool has_supply_setup = (eng_ob_active and not eng_ob_is_bullish) or (bpr_fvg_active and bpr_fvg_is_bullish)
    bool has_demand_setup = (eng_ob_active and eng_ob_is_bullish) or (bpr_fvg_active and not bpr_fvg_is_bullish)

    if bar_index - supply_trigger_bar > 1 and not has_supply_setup
        supply_triggered := false
    if bar_index - demand_trigger_bar > 1 and not has_demand_setup
        demand_triggered := false

    // Track when we're outside both zones
    // Only set was_outside_zones if there's NO active ENG OB setup
    if outside_both_zones and not eng_ob_active
        was_outside_zones := true

if in_supply
    supply_triggered := true
    supply_trigger_bar := bar_index

    // Reset deepest on fresh entry after being outside
    if was_outside_zones
        supply_highest_high := high
        was_outside_zones := false
    // Otherwise, track highest high in supply zone
    else if na(supply_highest_high) or high > supply_highest_high
        supply_highest_high := high

    // Track deepest EVER in supply zone (never resets, only gets deeper) - using CLOSE
    if na(supply_deepest_ever) or close > supply_deepest_ever
        supply_deepest_ever := close

if in_demand
    demand_triggered := true
    demand_trigger_bar := bar_index

    // Reset deepest on fresh entry after being outside
    if was_outside_zones
        demand_lowest_low := low
        was_outside_zones := false
    // Otherwise, track lowest low in demand zone
    else if na(demand_lowest_low) or low < demand_lowest_low
        demand_lowest_low := low

    // Track deepest EVER in demand zone (never resets, only gets deeper) - using CLOSE
    if na(demand_deepest_ever) or close < demand_deepest_ever
        demand_deepest_ever := close

// ============================================================================
// SETUP FLOW AND INVALIDATION RULES
// ============================================================================
// FLOW:
// 1. When AOI is entered, show "IN AOI"
// 2. If price leaves AOI without an ENG OB, return to "-"
// 3. If ENG OB forms, black diamond appears, ENG OB shows checkmark
//    - AOI status changes to "ACTIVE" (setup is now active)
//    - ENG OB stays checked until invalidated
// 4. Look BACKWARD for first opposite LTF fractal candle, place debug diamond above it
// 5. If price crosses fractal high (bullish) or low (bearish), MSS OB is formed
//    - Checkmark MSS OB row
//    - Draw entry OB from lowest candle in ENG OB setup (use that candle's high and low)
//    - Add debug row showing entry window
//    - Status changes to "AWAITING MSS OB ENTRY"
//
// INVALIDATION RULES:
// - ENG OB invalidated: if price goes deeper into zone than ENG OB candle before crossing fractal level (step 5)
// - MSS OB invalidated: if price touches opposite color zone (may add more criteria later)
//
// ============================================================================
// ENGULFING ORDER BLOCK DETECTION
// ============================================================================
bool is_bullish_engulfing = false
bool is_bearish_engulfing = false

// Only check for engulfing when in an AOI AND within trading window
if demand_triggered and bar_index > 0 and in_trading_window
    // Bullish engulfing: current candle close engulfs previous candle body
    bool current_bullish = close > open
    bool prev_bearish = close[1] < open[1]
    bool engulfs_body = close >= open[1]

    // Check if current or previous candle made the deepest low FOR THIS ZONE ENTRY
    bool is_deepest = low <= demand_lowest_low or low[1] <= demand_lowest_low

    // VALIDATION: ENG OB must be deeper than or equal to any previous ENG OB
    // The CLOSE of whichever candle made the deepest low must be lower than or equal to previous deepest close
    float deepest_candle_close = low <= low[1] ? close : close[1]
    bool is_deeper_than_previous = na(demand_deepest_ever) or deepest_candle_close <= demand_deepest_ever

    is_bullish_engulfing := current_bullish and prev_bearish and engulfs_body and is_deepest and is_deeper_than_previous

if supply_triggered and bar_index > 0 and in_trading_window
    // Bearish engulfing: current candle close engulfs previous candle body
    bool current_bearish = close < open
    bool prev_bullish = close[1] > open[1]
    bool engulfs_body = close <= open[1]

    // Check if current or previous candle made the highest high FOR THIS ZONE ENTRY
    bool is_deepest = high >= supply_highest_high or high[1] >= supply_highest_high

    // VALIDATION: ENG OB must be deeper than or equal to any previous ENG OB
    // The CLOSE of whichever candle made the highest high must be higher than or equal to previous deepest close
    float deepest_candle_close = high >= high[1] ? close : close[1]
    bool is_deeper_than_previous = na(supply_deepest_ever) or deepest_candle_close >= supply_deepest_ever

    is_bearish_engulfing := current_bearish and prev_bullish and engulfs_body and is_deepest and is_deeper_than_previous

bool engulfing_ob_detected = is_bullish_engulfing or is_bearish_engulfing

// NOTE: Trading window only prevents NEW setups from forming
// Existing setups remain active even outside trading window
// This allows setups to continue tracking but prevents new entries outside hours

// INVALIDATION: Setup expires after max_setup_bars (only if not in trade) or at trading end time
if eng_ob_active and not na(eng_ob_bar_index)
    bool should_invalidate_timeout = false
    string timeout_reason = ""

    // Check if setup has exceeded max bars (ONLY if not in a trade)
    if not trade_entered
        int bars_since_setup = bar_index - eng_ob_bar_index
        if bars_since_setup >= max_setup_bars
            should_invalidate_timeout := true
            timeout_reason := "Max bars (" + str.tostring(max_setup_bars) + ")"

    // Check if it's past trading end time (applies to ALL setups, including active trades)
    int current_hour = hour(time, "America/New_York")
    int current_minute = minute(time, "America/New_York")
    int current_time_mins = current_hour * 60 + current_minute
    int end_time_mins = trading_end_hour * 60 + trading_end_minute

    if current_time_mins >= end_time_mins
        should_invalidate_timeout := true
        string end_time_str = str.tostring(trading_end_hour) + ":" + (trading_end_minute < 10 ? "0" : "") + str.tostring(trading_end_minute)
        timeout_reason := timeout_reason == "" ? end_time_str + " NY time" : timeout_reason + " + " + end_time_str

    if should_invalidate_timeout
        label.new(bar_index, eng_ob_is_bullish ? low : high, "❌ TIMEOUT\n" + timeout_reason,
                 color=color.purple, textcolor=color.white,
                 style=eng_ob_is_bullish ? label.style_label_up : label.style_label_down,
                 size=size.small)

        // Close any open positions and cancel pending orders
        strategy.close_all()
        strategy.cancel_all()

        eng_ob_active := false
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level_mss := na

        // Clear entry signals (all strategies)
        entry_signal_active := false
        active_entry_strategy := ""
        entry_price := na
        entry_tp := na
        entry_sl := na

        // Reset trade flag
        trade_entered := false

        // Delete yellow box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

        // Delete TP/SL boxes
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

// INVALIDATION: Clear setup when zones are disabled
// Only invalidate if the disabled zone MATCHES the setup's zone
// Bullish setup (from demand) only invalidated by clear_demand
// Bearish setup (from supply) only invalidated by clear_supply
if eng_ob_active
    bool should_invalidate = false

    if eng_ob_is_bullish and clear_demand
        // Bullish setup invalidated by disabling demand zone
        should_invalidate := true
    else if not eng_ob_is_bullish and clear_supply
        // Bearish setup invalidated by disabling supply zone
        should_invalidate := true

    if should_invalidate
        eng_ob_active := false
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level_mss := na

        // Clear entry signals (all strategies)
        entry_signal_active := false
        active_entry_strategy := ""
        entry_price := na
        entry_tp := na
        entry_sl := na

        // Delete yellow box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

        // Delete TP/SL boxes
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

// INVALIDATION: Clear setup when entering the OPPOSITE zone (fresh zone entry)
// Bullish setup (from demand) invalidated by entering supply zone
// Bearish setup (from supply) invalidated by entering demand zone
if barstate.isnew and was_outside_zones
    if eng_ob_active and eng_ob_is_bullish and in_supply
        // Bullish setup invalidated by entering supply zone
        eng_ob_active := false
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level_mss := na

        // Clear entry signals (all strategies)
        entry_signal_active := false
        active_entry_strategy := ""
        entry_price := na
        entry_tp := na
        entry_sl := na

        // Delete yellow box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

        // Delete TP/SL boxes
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

    else if eng_ob_active and not eng_ob_is_bullish and in_demand
        // Bearish setup invalidated by entering demand zone
        eng_ob_active := false
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level_mss := na

        // Clear entry signals (all strategies)
        entry_signal_active := false
        active_entry_strategy := ""
        entry_price := na
        entry_tp := na
        entry_sl := na

        // Delete yellow box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

        // Delete TP/SL boxes
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

// When ENG OB forms, activate it and record deepest level + capture the OB candle
if is_bullish_engulfing
    eng_ob_active := true
    eng_ob_is_bullish := true
    eng_ob_deepest_level := demand_lowest_low
    target_fractal_level_mss := na  // Reset fractal search for new ENG OB

    // Determine which candle is the actual OB candle (the one that made the deepest low)
    // For bullish engulfing, the OB candle is whichever made the lowest low
    if low <= low[1]
        // Current candle made the deepest low - it's the OB candle
        eng_ob_bar_index := bar_index
        eng_ob_candle_high := high
        eng_ob_candle_low := low
    else
        // Previous candle made the deepest low - it's the OB candle
        eng_ob_bar_index := bar_index - 1
        eng_ob_candle_high := high[1]
        eng_ob_candle_low := low[1]

else if is_bearish_engulfing
    eng_ob_active := true
    eng_ob_is_bullish := false
    eng_ob_deepest_level := supply_highest_high
    target_fractal_level_mss := na  // Reset fractal search for new ENG OB

    // Determine which candle is the actual OB candle (the one that made the highest high)
    // For bearish engulfing, the OB candle is whichever made the highest high
    if high >= high[1]
        // Current candle made the highest high - it's the OB candle
        eng_ob_bar_index := bar_index
        eng_ob_candle_high := high
        eng_ob_candle_low := low
    else
        // Previous candle made the highest high - it's the OB candle
        eng_ob_bar_index := bar_index - 1
        eng_ob_candle_high := high[1]
        eng_ob_candle_low := low[1]

// INVALIDATION: Price goes deeper into zone than ENG OB candle (before MSS OB is crossed)
// Only invalidate if price is IN the zone and goes deeper than the OB candle
// TODO: Once MSS OB crossing detection is implemented, add condition to stop invalidation after cross
if eng_ob_active
    if eng_ob_is_bullish and demand_triggered and not na(eng_ob_candle_low)
        // Bullish setup invalidated if price makes new lower low than ENG OB candle's low WHILE IN DEMAND ZONE
        if low < eng_ob_candle_low
            eng_ob_active := false
            eng_ob_is_bullish := false
            eng_ob_deepest_level := na
            eng_ob_bar_index := na
            eng_ob_candle_high := na
            eng_ob_candle_low := na
            target_fractal_level_mss := na

            // Clear entry signals (all strategies)
            entry_signal_active := false
            active_entry_strategy := ""
            entry_price := na
            entry_tp := na
            entry_sl := na

            // Delete the yellow box when invalidated
            if not na(eng_ob_box)
                box.delete(eng_ob_box)
                eng_ob_box := na

            // Delete TP/SL boxes
            if not na(tp_box)
                box.delete(tp_box)
                tp_box := na
            if not na(sl_box)
                box.delete(sl_box)
                sl_box := na

    else if not eng_ob_is_bullish and supply_triggered and not na(eng_ob_candle_high)
        // Bearish setup invalidated if price makes new higher high than ENG OB candle's high WHILE IN SUPPLY ZONE
        if high > eng_ob_candle_high
            eng_ob_active := false
            eng_ob_is_bullish := false
            eng_ob_deepest_level := na
            eng_ob_bar_index := na
            eng_ob_candle_high := na
            eng_ob_candle_low := na
            target_fractal_level_mss := na

            // Clear entry signals (all strategies)
            entry_signal_active := false
            active_entry_strategy := ""
            entry_price := na
            entry_tp := na
            entry_sl := na

            // Delete the yellow box when invalidated
            if not na(eng_ob_box)
                box.delete(eng_ob_box)
                eng_ob_box := na

            // Delete TP/SL boxes
            if not na(tp_box)
                box.delete(tp_box)
                tp_box := na
            if not na(sl_box)
                box.delete(sl_box)
                sl_box := na

// INVALIDATION: Entry signal invalidated when price reaches opposite zone
// This invalidation applies even if we haven't left both zones
// Bullish entry invalidated by touching supply zone
// Bearish entry invalidated by touching demand zone
if entry_signal_active
    bool should_invalidate_entry = false

    if eng_ob_is_bullish and in_supply
        // Bullish entry invalidated by reaching supply zone
        should_invalidate_entry := true
    else if not eng_ob_is_bullish and in_demand
        // Bearish entry invalidated by reaching demand zone
        should_invalidate_entry := true

    if should_invalidate_entry
        // Clear the entire setup
        eng_ob_active := false
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level_mss := na

        // Clear entry signals (all strategies)
        entry_signal_active := false
        active_entry_strategy := ""
        entry_price := na
        entry_tp := na
        entry_sl := na

        // Delete the box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

        // Delete TP/SL boxes
        if not na(tp_box)
            box.delete(tp_box)
            tp_box := na
        if not na(sl_box)
            box.delete(sl_box)
            sl_box := na

// Track which candle made the deepest penetration (only show current)
var label deepest_demand_label = na
var label deepest_supply_label = na

// Update deepest marker when new deepest is found - place below/above candle to avoid covering it
if demand_triggered and not na(demand_lowest_low) and low == demand_lowest_low
    // Delete old label
    if not na(deepest_demand_label)
        label.delete(deepest_demand_label)
    // Create new label below the candle low
    deepest_demand_label := label.new(bar_index, low, "●", xloc=xloc.bar_index, yloc=yloc.price, color=color.new(color.white, 100), textcolor=color.blue, size=size.tiny, style=label.style_label_up, textalign=text.align_center)

if supply_triggered and not na(supply_highest_high) and high == supply_highest_high
    // Delete old label
    if not na(deepest_supply_label)
        label.delete(deepest_supply_label)
    // Create new label above the candle high
    deepest_supply_label := label.new(bar_index, high, "●", xloc=xloc.bar_index, yloc=yloc.price, color=color.new(color.white, 100), textcolor=color.orange, size=size.tiny, style=label.style_label_down, textalign=text.align_center)

// Plot diamonds for engulfing OB detection (smaller size)
plotshape(is_bullish_engulfing, title="Bullish Engulfing OB", style=shape.diamond, location=location.belowbar, color=color.black, size=size.tiny)
plotshape(is_bearish_engulfing, title="Bearish Engulfing OB", style=shape.diamond, location=location.abovebar, color=color.black, size=size.tiny)

// ============================================================================
// BPR FVG DETECTION
// ============================================================================
// FVG = Fair Value Gap = gap between candle 1 high/low and candle 3 low/high
// Bullish FVG: low[0] > high[2] (gap up)
// Bearish FVG: high[0] < low[2] (gap down)
// BPR = Balanced Price Range = FVG that forms in AOI

// Detect BPR FVG when in AOI and within trading window (no ENG OB requirement)
// Check if ANY of the 3 FVG candles touched the zone
// Don't detect new FVGs when we already have an active entry signal, active trade, or within cooldown
bool in_cooldown = last_exit_bar >= 0 and (bar_index - last_exit_bar) < cooldown_bars
if not bpr_fvg_active and not entry_signal_active and not trade_entered and not in_cooldown and bar_index >= 2 and in_trading_window
    // Bearish setup: detect bullish FVG in supply zone
    // Check if current candle OR previous 2 candles touched supply zone
    bool supply_touched_by_fvg_candles = false
    if supply_configured
        // Check current candle (candle 3)
        bool c0_in_supply = not (low > supply_top or high < supply_bottom)
        // Check candle 1 bar ago (candle 2)
        bool c1_in_supply = not (low[1] > supply_top or high[1] < supply_bottom)
        // Check candle 2 bars ago (candle 1)
        bool c2_in_supply = not (low[2] > supply_top or high[2] < supply_bottom)

        supply_touched_by_fvg_candles := c0_in_supply or c1_in_supply or c2_in_supply

    if supply_touched_by_fvg_candles
        // Bullish FVG: current low > high of 2 bars ago (gap up)
        bool has_bullish_fvg = low > high[2]

        if has_bullish_fvg
            // Calculate FVG size in ticks
            float fvg_size = low - high[2]
            float fvg_size_ticks = fvg_size / syminfo.mintick

            // Only activate if FVG meets minimum tick size requirement
            if fvg_size_ticks >= bpr_fvg_min_ticks
                bpr_fvg_active := true
                bpr_fvg_is_bullish := true
                bpr_fvg_bottom := high[2]  // Bottom of gap
                bpr_fvg_top := low  // Top of gap
                bpr_fvg_bar_index := bar_index

                // Invalidation level: highest high of the 3 candles involved
                bpr_fvg_invalidation_level := math.max(high[2], math.max(high[1], high))

    // Bullish setup: detect bearish FVG in demand zone
    // Check if current candle OR previous 2 candles touched demand zone
    bool demand_touched_by_fvg_candles = false
    if demand_configured
        // Check current candle (candle 3)
        bool c0_in_demand = not (low > demand_top or high < demand_bottom)
        // Check candle 1 bar ago (candle 2)
        bool c1_in_demand = not (low[1] > demand_top or high[1] < demand_bottom)
        // Check candle 2 bars ago (candle 1)
        bool c2_in_demand = not (low[2] > demand_top or high[2] < demand_bottom)

        demand_touched_by_fvg_candles := c0_in_demand or c1_in_demand or c2_in_demand

    if demand_touched_by_fvg_candles
        // Bearish FVG: current high < low of 2 bars ago (gap down)
        bool has_bearish_fvg = high < low[2]

        if has_bearish_fvg
            // Calculate FVG size in ticks
            float fvg_size = low[2] - high
            float fvg_size_ticks = fvg_size / syminfo.mintick

            // Only activate if FVG meets minimum tick size requirement
            if fvg_size_ticks >= bpr_fvg_min_ticks
                bpr_fvg_active := true
                bpr_fvg_is_bullish := false
                bpr_fvg_top := low[2]  // Top of gap
                bpr_fvg_bottom := high  // Bottom of gap
                bpr_fvg_bar_index := bar_index

                // Invalidation level: lowest low of the 3 candles involved
                bpr_fvg_invalidation_level := math.min(low[2], math.min(low[1], low))

// INVALIDATION: Price closes beyond invalidation level (deeper into zone)
if bpr_fvg_active and not entry_signal_active
    bool should_invalidate_fvg = false

    if bpr_fvg_is_bullish and supply_triggered
        // Bullish FVG invalidated if close goes higher than invalidation level
        if close > bpr_fvg_invalidation_level
            should_invalidate_fvg := true
            bpr_fvg_invalidation_reason := "Price beyond invalidation (" + str.tostring(close, format.mintick) + " > " + str.tostring(bpr_fvg_invalidation_level, format.mintick) + ")"
    else if not bpr_fvg_is_bullish and demand_triggered
        // Bearish FVG invalidated if close goes lower than invalidation level
        if close < bpr_fvg_invalidation_level
            should_invalidate_fvg := true
            bpr_fvg_invalidation_reason := "Price beyond invalidation (" + str.tostring(close, format.mintick) + " < " + str.tostring(bpr_fvg_invalidation_level, format.mintick) + ")"

    if should_invalidate_fvg
        bpr_fvg_active := false
        bpr_fvg_is_bullish := false
        bpr_fvg_top := na
        bpr_fvg_bottom := na
        bpr_fvg_invalidation_level := na
        bpr_fvg_bar_index := na

        // Delete FVG box
        if not na(bpr_fvg_box)
            box.delete(bpr_fvg_box)
            bpr_fvg_box := na

// INVALIDATION: Clear BPR FVG when zones are disabled
if bpr_fvg_active
    bool should_invalidate_fvg_zone = false

    if bpr_fvg_is_bullish and clear_supply
        should_invalidate_fvg_zone := true
        bpr_fvg_invalidation_reason := "Supply zone disabled"
    else if not bpr_fvg_is_bullish and clear_demand
        should_invalidate_fvg_zone := true
        bpr_fvg_invalidation_reason := "Demand zone disabled"

    if should_invalidate_fvg_zone
        bpr_fvg_active := false
        bpr_fvg_is_bullish := false
        bpr_fvg_top := na
        bpr_fvg_bottom := na
        bpr_fvg_invalidation_level := na
        bpr_fvg_bar_index := na

        // Delete FVG box
        if not na(bpr_fvg_box)
            box.delete(bpr_fvg_box)
            bpr_fvg_box := na

// INVALIDATION: Clear BPR FVG when entering opposite zone
if barstate.isnew and was_outside_zones and bpr_fvg_active
    bool should_invalidate_opposite = false

    if bpr_fvg_is_bullish and in_demand
        should_invalidate_opposite := true
        bpr_fvg_invalidation_reason := "Entered opposite zone (demand)"
    else if not bpr_fvg_is_bullish and in_supply
        should_invalidate_opposite := true
        bpr_fvg_invalidation_reason := "Entered opposite zone (supply)"

    if should_invalidate_opposite
        bpr_fvg_active := false
        bpr_fvg_is_bullish := false
        bpr_fvg_top := na
        bpr_fvg_bottom := na
        bpr_fvg_invalidation_level := na
        bpr_fvg_bar_index := na

        // Delete FVG box
        if not na(bpr_fvg_box)
            box.delete(bpr_fvg_box)
            bpr_fvg_box := na

// Visualize BPR FVG with colored outline (red for bearish, green for bullish) and yellow fill
if bpr_fvg_active
    // Create box on first detection
    if na(bpr_fvg_box)
        // Red outline for bullish FVG (bearish trade), green outline for bearish FVG (bullish trade)
        color outline_color = bpr_fvg_is_bullish ? color.red : color.green
        bpr_fvg_box := box.new(bpr_fvg_bar_index, bpr_fvg_top, bpr_fvg_bar_index + 1, bpr_fvg_bottom,
                               border_color=outline_color,
                               bgcolor=color.new(color.yellow, 90),
                               border_width=1,
                               extend=extend.none)
    else
        // Extend box to current bar
        box.set_right(bpr_fvg_box, bar_index + 1)

// ============================================================================
// ENTRY ZONE VISUALIZATION - Works for ALL entry strategies
// ============================================================================
// Standard visual flow for all 4 entry strategies:
// 1. YELLOW box = ENG OB detected (entry zone identified)
// 2. BLUE box = Entry signal active (limit order placed, awaiting fill)
// 3. GREEN/RED boxes = Trade entered (TP/SL shown when position is open)

// STEP 1: Create YELLOW box when ENG OB forms
if is_bullish_engulfing or is_bearish_engulfing
    // Delete old box
    if not na(eng_ob_box)
        box.delete(eng_ob_box)

    // Draw new box around the OB candle we just identified
    if not na(eng_ob_bar_index)
        int box_left = eng_ob_bar_index
        int box_right = eng_ob_bar_index + 1
        float box_top = eng_ob_candle_high
        float box_bottom = eng_ob_candle_low

        // Use yellow for ENG OB (entry zone)
        color box_color = color.yellow

        eng_ob_box := box.new(box_left, box_top, box_right, box_bottom,
                              border_color=box_color,
                              bgcolor=color.new(box_color, 90),
                              border_width=1,
                              extend=extend.none)

// STEP 2: Extend box and change to BLUE when entry signal activates
if (eng_ob_active or entry_signal_active) and not na(eng_ob_box)
    box.set_right(eng_ob_box, bar_index + 1)

    // Change to blue ONLY when MSS OB or other ENG OB-based strategies activate (not BPR FVG)
    if entry_signal_active and active_entry_strategy != "BPR FVG"
        box.set_border_color(eng_ob_box, color.blue)
        box.set_bgcolor(eng_ob_box, color.new(color.blue, 90))

// STEP 2: Extend BPR FVG box and change to BLUE when entry signal activates
if bpr_fvg_active and not na(bpr_fvg_box)
    box.set_right(bpr_fvg_box, bar_index + 1)

    // Change to blue when BPR FVG entry strategy activates (limit order placed)
    if entry_signal_active and active_entry_strategy == "BPR FVG"
        box.set_border_color(bpr_fvg_box, color.blue)
        box.set_bgcolor(bpr_fvg_box, color.new(color.blue, 90))

// ============================================================================
// LTF FRACTAL DETECTION (only when in AOI or active setup)
// ============================================================================
// Only detect fractals when we're in AOI or have an active setup
bool should_detect_fractals = supply_triggered or demand_triggered or eng_ob_active

// Fractal detection: 2-period lookback/forward (5 candle pattern)
bool is_bearish_fractal = false
bool is_bullish_fractal = false

if should_detect_fractals and bar_index >= 2
    // Bearish fractal: high is higher than 2 candles before and 2 candles after
    is_bearish_fractal := high[2] > high[4] and high[2] > high[3] and high[2] > high[1] and high[2] > high[0]

    // Bullish fractal: low is lower than 2 candles before and 2 candles after
    is_bullish_fractal := low[2] < low[4] and low[2] < low[3] and low[2] < low[1] and low[2] < low[0]

// Plot fractals for debugging (only when actively detecting)
plotshape(is_bearish_fractal, title="Bearish Fractal", style=shape.triangledown, location=location.abovebar, color=color.red, size=size.tiny, offset=-2)
plotshape(is_bullish_fractal, title="Bullish Fractal", style=shape.triangleup, location=location.belowbar, color=color.green, size=size.tiny, offset=-2)

// ============================================================================
// MSS OB STRATEGY - Fractal Detection
// ============================================================================
// When ENG OB forms, search BACKWARD for the most recent opposite fractal
// This runs once when target_fractal_level_mss is na (right after ENG OB forms)
if use_mss_ob and eng_ob_active and na(target_fractal_level_mss) and bar_index >= 6
    // Search backward up to 20 bars for the most recent opposite fractal
    // Fractal pattern needs i-2, i-1, i, i+1, i+2 so we can only look back where i+2 is valid
    // Maximum safe lookback considering historical buffer limit
    int max_safe_lookback = bar_index - 4  // Ensures i+2 doesn't exceed bar_index
    int lookback_limit = math.min(20, max_safe_lookback)

    if eng_ob_is_bullish and lookback_limit >= 2
        // Bullish setup: look for most recent bearish fractal (high point)
        for i = 2 to lookback_limit
            // Double-check bounds before accessing historical data
            // This prevents accessing offsets beyond the historical buffer
            if i + 2 <= bar_index and not na(high[i+2]) and not na(high[i+1]) and not na(high[i-1]) and not na(high[i-2])
                bool is_bearish_frac = high[i] > high[i+2] and high[i] > high[i+1] and high[i] > high[i-1] and high[i] > high[i-2]
                if is_bearish_frac
                    // Found the most recent bearish fractal
                    target_fractal_level_mss := high[i]
                    break
    else if lookback_limit >= 2
        // Bearish setup: look for most recent bullish fractal (low point)
        for i = 2 to lookback_limit
            // Double-check bounds before accessing historical data
            // This prevents accessing offsets beyond the historical buffer
            if i + 2 <= bar_index and not na(low[i+2]) and not na(low[i+1]) and not na(low[i-1]) and not na(low[i-2])
                bool is_bullish_frac = low[i] < low[i+2] and low[i] < low[i+1] and low[i] < low[i-1] and low[i] < low[i-2]
                if is_bullish_frac
                    // Found the most recent bullish fractal
                    target_fractal_level_mss := low[i]
                    break

// ============================================================================
// MSS OB STRATEGY - Entry Signal Detection
// ============================================================================
// Check if price has crossed the fractal level (wick or close through)
// Don't trigger new entries while a trade is active, on same bar as exit, or within cooldown
if use_mss_ob and eng_ob_active and not entry_signal_active and not trade_entered and not in_cooldown and not na(target_fractal_level_mss)
    bool fractal_crossed = false

    if eng_ob_is_bullish
        // Bullish setup: check if price crossed above the bearish fractal high
        fractal_crossed := high >= target_fractal_level_mss
    else
        // Bearish setup: check if price crossed below the bullish fractal low
        fractal_crossed := low <= target_fractal_level_mss

    if fractal_crossed
        // MSS OB entry signal triggered
        entry_signal_active := true
        active_entry_strategy := "MSS OB"
        entry_is_bullish := eng_ob_is_bullish

        // Set entry, TP, and SL based on the OB candle
        if eng_ob_is_bullish
            // Bullish: Entry at high of OB candle, SL at low (with grace ticks), TP at 2:1 RR
            entry_price := eng_ob_candle_high
            entry_sl := eng_ob_candle_low - grace_ticks  // Pad SL below the low
            float risk = entry_price - entry_sl
            entry_tp := entry_price + (risk * 2)  // 2:1 reward to risk
        else
            // Bearish: Entry at low of OB candle, SL at high (with grace ticks), TP at 2:1 RR
            entry_price := eng_ob_candle_low
            entry_sl := eng_ob_candle_high + grace_ticks  // Pad SL above the high
            float risk = entry_sl - entry_price
            entry_tp := entry_price - (risk * 2)  // 2:1 reward to risk

// ============================================================================
// BPR FVG STRATEGY - Entry Signal Detection
// ============================================================================
// Entry triggered when price CLOSES below FVG bottom (bearish) or above FVG top (bullish)
// Don't trigger new entries while a trade is active or within cooldown period
// IMPORTANT: Only check at bar close (barstate.isconfirmed) to wait for candle to fully close
if use_bpr_fvg and bpr_fvg_active and not entry_signal_active and not trade_entered and not in_cooldown and barstate.isconfirmed
    bool close_through_fvg = false

    if bpr_fvg_is_bullish
        // Bearish setup: wait for close BELOW FVG bottom (fully breached)
        close_through_fvg := close < bpr_fvg_bottom
    else
        // Bullish setup: wait for close ABOVE FVG top (fully breached)
        close_through_fvg := close > bpr_fvg_top

    if close_through_fvg
        entry_signal_active := true
        active_entry_strategy := "BPR FVG"
        entry_is_bullish := not bpr_fvg_is_bullish  // Inverse: bullish FVG = bearish trade

        if bpr_fvg_is_bullish
            // Bearish setup: Entry at bottom of FVG, SL at top (with grace ticks), TP at 2:1 RR
            entry_price := bpr_fvg_bottom
            entry_sl := bpr_fvg_top + grace_ticks  // Pad SL above the top
            float risk = entry_sl - entry_price
            entry_tp := entry_price - (risk * 2)  // 2:1 reward to risk
        else
            // Bullish setup: Entry at top of FVG, SL at bottom (with grace ticks), TP at 2:1 RR
            entry_price := bpr_fvg_top
            entry_sl := bpr_fvg_bottom - grace_ticks  // Pad SL below the bottom
            float risk = entry_price - entry_sl
            entry_tp := entry_price + (risk * 2)  // 2:1 reward to risk

        // DON'T clear BPR FVG state here - keep it for debug table display
        // It will be cleared when trade exits or is invalidated

// ============================================================================
// INVERTED FVG STRATEGY - Entry Signal Detection
// ============================================================================
// TODO: Implement Inverted FVG detection
if use_inverted_fvg and eng_ob_active and not entry_signal_active
    // Placeholder for Inverted FVG strategy
    bool inv_fvg_triggered = false  // TODO: Add actual detection logic

    if inv_fvg_triggered
        entry_signal_active := true
        active_entry_strategy := "Inverted FVG"
        // TODO: Set entry_price, entry_tp, entry_sl

// ============================================================================
// BREAKER BLOCK STRATEGY - Entry Signal Detection
// ============================================================================
// TODO: Implement Breaker Block detection
if use_breaker_block and eng_ob_active and not entry_signal_active
    // Placeholder for Breaker Block strategy
    bool breaker_triggered = false  // TODO: Add actual detection logic

    if breaker_triggered
        entry_signal_active := true
        active_entry_strategy := "Breaker Block"
        // TODO: Set entry_price, entry_tp, entry_sl

// ============================================================================
// GENERIC ENTRY EXECUTION - Works for all strategies
// ============================================================================
// When any entry signal becomes active, place the trade ONCE
if entry_signal_active and not trade_entered and not order_placed and not na(entry_price)
    // Calculate position size based on risk
    float risk_per_contract = math.abs(entry_price - entry_sl)
    float position_size = risk_per_trade / risk_per_contract

    // Place limit order at entry level
    if entry_is_bullish
        // Enter long position with limit order at entry level
        strategy.entry("Long", strategy.long, qty=position_size, limit=entry_price)
        strategy.exit("TP/SL Long", "Long", limit=entry_tp, stop=entry_sl)
    else
        // Enter short position with limit order at entry level
        strategy.entry("Short", strategy.short, qty=position_size, limit=entry_price)
        strategy.exit("TP/SL Short", "Short", limit=entry_tp, stop=entry_sl)

    // Mark that order has been placed for this signal
    order_placed := true
    order_placed_bar := bar_index

// ============================================================================
// TRADE EXECUTION - Track when limit order is filled
// ============================================================================
// STEP 3: Create GREEN/RED boxes when trade is entered (generic for all strategies)
if entry_signal_active and not trade_entered
    // Check if we now have an open position (limit order was filled)
    if strategy.position_size != 0
        trade_entered := true

        // Create TP and SL indicator boxes (only when trade is actually entered)
        // This completes the standard visual flow: YELLOW → BLUE → GREEN/RED
        // Delete old boxes first
        if not na(tp_box)
            box.delete(tp_box)
        if not na(sl_box)
            box.delete(sl_box)

        // Create new TP box (green) and SL box (red)
        if entry_is_bullish
            // Bullish: TP is above entry
            tp_box := box.new(bar_index, entry_tp, bar_index + 1, entry_price,
                             border_color=color.green,
                             bgcolor=color.new(color.green, 85),
                             border_width=1,
                             extend=extend.none)
            // SL is below entry
            sl_box := box.new(bar_index, entry_price, bar_index + 1, entry_sl,
                             border_color=color.red,
                             bgcolor=color.new(color.red, 85),
                             border_width=1,
                             extend=extend.none)
        else
            // Bearish: TP is below entry
            tp_box := box.new(bar_index, entry_price, bar_index + 1, entry_tp,
                             border_color=color.green,
                             bgcolor=color.new(color.green, 85),
                             border_width=1,
                             extend=extend.none)
            // SL is above entry
            sl_box := box.new(bar_index, entry_sl, bar_index + 1, entry_price,
                             border_color=color.red,
                             bgcolor=color.new(color.red, 85),
                             border_width=1,
                             extend=extend.none)

// Check if trade has exited (TP or SL hit)
if trade_entered and strategy.position_size == 0
    // FIRST: Cancel all pending orders to prevent re-entry from lingering limit order
    strategy.cancel_all()

    // Record the exit bar to prevent same-bar re-entry
    last_exit_bar := bar_index

    // Trade has exited - clear all setup variables
    eng_ob_active := false
    eng_ob_is_bullish := false
    eng_ob_deepest_level := na
    eng_ob_bar_index := na
    eng_ob_candle_high := na
    eng_ob_candle_low := na
    target_fractal_level_mss := na

    // Clear entry signals (all strategies)
    entry_signal_active := false
    active_entry_strategy := ""
    entry_is_bullish := false
    entry_price := na
    entry_tp := na
    entry_sl := na

    // Reset trade flag and order placement flag
    trade_entered := false
    order_placed := false
    order_placed_bar := -1

    // Persist TP/SL boxes for the day (don't delete, just stop extending)
    // Add them to daily arrays so they stay visible until 20:00
    if not na(tp_box)
        array.push(daily_tp_boxes, tp_box)
        tp_box := na
    if not na(sl_box)
        array.push(daily_sl_boxes, sl_box)
        sl_box := na

    // Delete eng_ob_box since it's just for active setup
    if not na(eng_ob_box)
        box.delete(eng_ob_box)
        eng_ob_box := na

    // Delete bpr_fvg_box since it's just for active setup
    if not na(bpr_fvg_box)
        box.delete(bpr_fvg_box)
        bpr_fvg_box := na

    // Clear BPR FVG state
    bpr_fvg_active := false
    bpr_fvg_is_bullish := false
    bpr_fvg_top := na
    bpr_fvg_bottom := na
    bpr_fvg_invalidation_level := na
    bpr_fvg_bar_index := na
    bpr_fvg_invalidation_reason := "Trade exited"

// ============================================================================
// INTRABAR TRADE CLEANUP - Handle trades that open and close within same candle
// ============================================================================
// If order was placed but trade never got marked as entered, and position is now closed,
// this means the trade opened and closed intrabar (before bar-close detection).
// Clean up the stuck state to allow new trades.
// ONLY run this if it's been at least 1 bar since order was placed (prevents same-bar cleanup)
if order_placed and not trade_entered and strategy.position_size == 0 and bar_index != last_exit_bar and (bar_index - order_placed_bar) >= 1
    // Cancel any pending orders
    strategy.cancel_all()

    // Record the exit bar to prevent same-bar re-entry
    last_exit_bar := bar_index

    // Only clear the strategy that actually placed the order
    // If MSS OB placed the order, clear ENG OB but leave BPR FVG intact
    // If BPR FVG placed the order, clear BPR FVG but leave ENG OB intact

    // Clear the entry signal that placed the order
    entry_signal_active := false
    entry_is_bullish := false
    entry_price := na
    entry_tp := na
    entry_sl := na
    order_placed := false
    order_placed_bar := -1

    // Clear strategy-specific state based on which strategy placed the order
    if active_entry_strategy == "MSS OB"
        // MSS OB placed the order - clear ENG OB but keep BPR FVG
        eng_ob_active := false
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level_mss := na

        // Delete eng_ob_box
        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na

    else if active_entry_strategy == "BPR FVG"
        // BPR FVG placed the order - clear BPR FVG state
        bpr_fvg_active := false
        bpr_fvg_is_bullish := false
        bpr_fvg_top := na
        bpr_fvg_bottom := na
        bpr_fvg_invalidation_level := na
        bpr_fvg_bar_index := na
        bpr_fvg_invalidation_reason := "Intrabar cleanup (BPR FVG)"

        // Delete bpr_fvg_box
        if not na(bpr_fvg_box)
            box.delete(bpr_fvg_box)
            bpr_fvg_box := na
    else
        // Unknown strategy or empty - clear everything to be safe
        eng_ob_active := false
        eng_ob_is_bullish := false
        eng_ob_deepest_level := na
        eng_ob_bar_index := na
        eng_ob_candle_high := na
        eng_ob_candle_low := na
        target_fractal_level_mss := na

        bpr_fvg_active := false
        bpr_fvg_is_bullish := false
        bpr_fvg_top := na
        bpr_fvg_bottom := na
        bpr_fvg_invalidation_level := na
        bpr_fvg_bar_index := na
        bpr_fvg_invalidation_reason := "Intrabar cleanup (unknown strategy)"

        if not na(eng_ob_box)
            box.delete(eng_ob_box)
            eng_ob_box := na
        if not na(bpr_fvg_box)
            box.delete(bpr_fvg_box)
            bpr_fvg_box := na

    // Clear the active strategy name last
    active_entry_strategy := ""

// Update TP/SL boxes to extend one bar at a time while trade is entered (only show when in trade)
if trade_entered and not na(tp_box) and not na(sl_box)
    box.set_right(tp_box, bar_index + 1)
    box.set_right(sl_box, bar_index + 1)

// ============================================================================
// DEBUG TABLE
// ============================================================================
var table debugTable = table.new(position.top_right, 2, 40, border_width=1)  // 40 rows: Added invalidation reason + zone trigger debug

// Determine AOI status based on flow rules
string aoi_status = "-"
color label_bgcolor = color.new(color.gray, 70)  // Light gray background for labels (left column)
color value_bgcolor = color.new(color.gray, 80)   // Lighter gray background for values (right column)

// Track which zone type we're working with for value column color
bool is_supply_setup = supply_triggered or (eng_ob_active and not eng_ob_is_bullish)
bool is_demand_setup = demand_triggered or (eng_ob_active and eng_ob_is_bullish)

if trade_entered and strategy.position_size != 0
    // Trade is active - in position
    aoi_status := "IN TRADE"
    value_bgcolor := eng_ob_is_bullish ? color.new(color.blue, 50) : color.new(color.red, 50)
else if entry_signal_active
    // Entry signal is active - awaiting entry
    aoi_status := "AWAITING ENTRY"
    value_bgcolor := eng_ob_is_bullish ? color.new(color.blue, 50) : color.new(color.red, 50)
else if eng_ob_active
    // Once ENG OB forms, status is ACTIVE (even if price leaves AOI)
    aoi_status := "ACTIVE"
    value_bgcolor := eng_ob_is_bullish ? color.new(color.blue, 50) : color.new(color.red, 50)
else if supply_triggered or demand_triggered
    // In AOI but no ENG OB yet
    aoi_status := "IN AOI"
    value_bgcolor := supply_triggered ? color.new(color.red, 50) : color.new(color.blue, 50)
else
    // Not in AOI and no active setup
    aoi_status := "-"
    value_bgcolor := color.new(color.gray, 80)

// Pad the status text to keep column width consistent
string padded_status = aoi_status == "-" ? "  -   " : aoi_status

table.cell(debugTable, 0, 0, "AOI Status", text_color=color.black, bgcolor=label_bgcolor, text_size=size.normal)
table.cell(debugTable, 1, 0, padded_status, text_color=color.black, bgcolor=value_bgcolor, text_size=size.normal)

// Engulfing OB status - show checkmark when active (only for MSS OB and other ENG OB-based strategies)
string eng_status = "-"
color eng_bgcolor = value_bgcolor
// Only show ENG OB as active if we're using a strategy that requires it (not BPR FVG)
if eng_ob_active and active_entry_strategy != "BPR FVG"
    eng_status := "✓"
    // Keep the same background as the overall value column

table.cell(debugTable, 0, 1, "Engulfing OB", text_color=color.black, bgcolor=label_bgcolor, text_size=size.normal)
table.cell(debugTable, 1, 1, eng_status, text_color=color.black, bgcolor=eng_bgcolor, text_size=size.normal)

// Entry Strategy - show which strategy triggered
string entry_strategy_text = "-"
color entry_strategy_bgcolor = value_bgcolor
if entry_signal_active
    entry_strategy_text := active_entry_strategy
table.cell(debugTable, 0, 2, "Entry Strategy", text_color=color.black, bgcolor=label_bgcolor, text_size=size.normal)
table.cell(debugTable, 1, 2, entry_strategy_text, text_color=color.black, bgcolor=entry_strategy_bgcolor, text_size=size.normal)

// Order Placed Flag
string order_placed_text = order_placed ? "✓ YES" : "✗ NO"
color order_placed_bg = order_placed ? color.new(color.green, 70) : color.new(color.red, 70)
table.cell(debugTable, 0, 3, "Order Placed", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 3, order_placed_text, text_color=color.black, bgcolor=order_placed_bg, text_size=size.small)

// Trade Entered Flag
string trade_entered_text = trade_entered ? "✓ YES" : "✗ NO"
color trade_entered_bg = trade_entered ? color.new(color.green, 70) : color.new(color.red, 70)
table.cell(debugTable, 0, 4, "Trade Entered", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 4, trade_entered_text, text_color=color.black, bgcolor=trade_entered_bg, text_size=size.small)

// Fractal Level - show target price for MSS OB (only when MSS OB strategy is enabled and active)
string fractal_level = "-"
if use_mss_ob and eng_ob_active
    if not na(target_fractal_level_mss)
        fractal_level := str.tostring(target_fractal_level_mss, format.mintick) + (eng_ob_is_bullish ? " (↑)" : " (↓)")
    else
        // Show "SEARCHING" if we have an active ENG OB but no fractal yet
        fractal_level := "SEARCHING"
table.cell(debugTable, 0, 5, "MSS Fractal", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 5, fractal_level, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)

// Position Size - debug to see strategy.position_size
string pos_size = str.tostring(strategy.position_size)
table.cell(debugTable, 0, 6, "Position Size", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 6, pos_size, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)

// Entry Price
string entry_price_text = "-"
if entry_signal_active and not na(entry_price)
    entry_price_text := str.tostring(entry_price, format.mintick)
table.cell(debugTable, 0, 7, "Entry Price", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 7, entry_price_text, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)

// Take Profit
string tp_price = "-"
if entry_signal_active and not na(entry_tp)
    tp_price := str.tostring(entry_tp, format.mintick)
table.cell(debugTable, 0, 8, "TP", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 8, tp_price, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)

// Stop Loss
string sl_price = "-"
if entry_signal_active and not na(entry_sl)
    sl_price := str.tostring(entry_sl, format.mintick)
table.cell(debugTable, 0, 9, "SL", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 9, sl_price, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)

// Bars Since Setup - show how many bars since ENG OB formed
string bars_since_setup = "-"
if eng_ob_active and not na(eng_ob_bar_index)
    bars_since_setup := str.tostring(bar_index - eng_ob_bar_index)
table.cell(debugTable, 0, 10, "Bars Since Setup", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 10, bars_since_setup, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)

// Supply Deepest - show deepest historical penetration into supply zone
string supply_deepest = "-"
if not na(supply_deepest_ever)
    supply_deepest := str.tostring(supply_deepest_ever, format.mintick)
table.cell(debugTable, 0, 11, "Supply Deepest", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 11, supply_deepest, text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)

// Demand Deepest - show deepest historical penetration into demand zone
string demand_deepest = "-"
if not na(demand_deepest_ever)
    demand_deepest := str.tostring(demand_deepest_ever, format.mintick)
table.cell(debugTable, 0, 12, "Demand Deepest", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 12, demand_deepest, text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)

// Supply zone levels - show DISABLED if disabled
string supply_zone = "-"
if clear_supply
    supply_zone := "DISABLED"
else if supply_configured
    supply_zone := str.tostring(supply_bottom, format.mintick) + " - " + str.tostring(supply_top, format.mintick)
table.cell(debugTable, 0, 13, "Supply Zone", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 13, supply_zone, text_color=color.black, bgcolor=value_bgcolor, text_size=size.small)

// Demand zone levels - show DISABLED if disabled
string demand_zone = "-"
color demand_zone_bgcolor = value_bgcolor
if clear_demand
    demand_zone := "DISABLED"
else if demand_configured
    demand_zone := str.tostring(demand_bottom, format.mintick) + " - " + str.tostring(demand_top, format.mintick)
    demand_zone_bgcolor := color.new(color.blue, 70)  // Lighter blue for better contrast
table.cell(debugTable, 0, 14, "Demand Zone", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 14, demand_zone, text_color=color.black, bgcolor=demand_zone_bgcolor, text_size=size.small)

// Session levels - show level or "X" if crossed
// Asian High
string asian_high_text = "-"
color asian_high_bg = label_bgcolor
if not na(asian_high)
    if asian_high_crossed
        asian_high_text := "✗ CROSSED"
        asian_high_bg := color.new(color.gray, 50)
    else
        asian_high_text := str.tostring(asian_high, format.mintick)
        asian_high_bg := color.new(color.red, 70)
table.cell(debugTable, 0, 15, "Asian High", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 15, asian_high_text, text_color=color.black, bgcolor=asian_high_bg, text_size=size.small)

// Asian Low
string asian_low_text = "-"
color asian_low_bg = label_bgcolor
if not na(asian_low)
    if asian_low_crossed
        asian_low_text := "✗ CROSSED"
        asian_low_bg := color.new(color.gray, 50)
    else
        asian_low_text := str.tostring(asian_low, format.mintick)
        asian_low_bg := color.new(color.green, 70)
table.cell(debugTable, 0, 16, "Asian Low", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 16, asian_low_text, text_color=color.black, bgcolor=asian_low_bg, text_size=size.small)

// London High
string london_high_text = "-"
color london_high_bg = label_bgcolor
if not na(london_high)
    if london_high_crossed
        london_high_text := "✗ CROSSED"
        london_high_bg := color.new(color.gray, 50)
    else
        london_high_text := str.tostring(london_high, format.mintick)
        london_high_bg := color.new(color.red, 70)
table.cell(debugTable, 0, 17, "London High", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 17, london_high_text, text_color=color.black, bgcolor=london_high_bg, text_size=size.small)

// London Low
string london_low_text = "-"
color london_low_bg = label_bgcolor
if not na(london_low)
    if london_low_crossed
        london_low_text := "✗ CROSSED"
        london_low_bg := color.new(color.gray, 50)
    else
        london_low_text := str.tostring(london_low, format.mintick)
        london_low_bg := color.new(color.green, 70)
table.cell(debugTable, 0, 18, "London Low", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 18, london_low_text, text_color=color.black, bgcolor=london_low_bg, text_size=size.small)

// Previous Day High
string prev_high_text = "-"
color prev_high_bg = label_bgcolor
if not na(prev_day_high)
    if prev_day_high_crossed
        prev_high_text := "✗ CROSSED"
        prev_high_bg := color.new(color.gray, 50)
    else
        prev_high_text := str.tostring(prev_day_high, format.mintick)
        prev_high_bg := color.new(color.red, 70)
table.cell(debugTable, 0, 19, "Prev Day High", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 19, prev_high_text, text_color=color.black, bgcolor=prev_high_bg, text_size=size.small)

// Previous Day Low
string prev_low_text = "-"
color prev_low_bg = label_bgcolor
if not na(prev_day_low)
    if prev_day_low_crossed
        prev_low_text := "✗ CROSSED"
        prev_low_bg := color.new(color.gray, 50)
    else
        prev_low_text := str.tostring(prev_day_low, format.mintick)
        prev_low_bg := color.new(color.green, 70)
table.cell(debugTable, 0, 20, "Prev Day Low", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 20, prev_low_text, text_color=color.black, bgcolor=prev_low_bg, text_size=size.small)

// ============================================================================
// ENG OB VALIDATION CHECKS (for debugging)
// ============================================================================
// Calculate all validation checks for display
bool check_supply_triggered = supply_triggered
bool check_bar_index = bar_index > 0
bool check_trading_window = in_trading_window
bool check_current_bearish = close < open
bool check_prev_bullish = close[1] > open[1]
bool check_engulfs_body = close <= open[1]
bool check_is_deepest = high >= supply_highest_high or high[1] >= supply_highest_high
float check_deepest_candle_close = high >= high[1] ? close : close[1]
bool check_is_deeper = na(supply_deepest_ever) or check_deepest_candle_close >= supply_deepest_ever

// Add divider row
color divider_color = color.new(color.orange, 30)
table.cell(debugTable, 0, 21, "ENG OB VALIDATION", text_color=color.black, bgcolor=divider_color, text_size=size.small)
table.cell(debugTable, 1, 21, "", text_color=color.black, bgcolor=divider_color, text_size=size.small)

// 1. Supply Triggered
color check_color_1 = check_supply_triggered ? color.new(color.green, 70) : color.new(color.red, 70)
table.cell(debugTable, 0, 22, "1. In Supply", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 22, check_supply_triggered ? "✓" : "✗", text_color=color.black, bgcolor=check_color_1, text_size=size.small)

// 2. Trading Window
color check_color_2 = check_trading_window ? color.new(color.green, 70) : color.new(color.red, 70)
table.cell(debugTable, 0, 23, "2. Trading Window", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 23, check_trading_window ? "✓" : "✗", text_color=color.black, bgcolor=check_color_2, text_size=size.small)

// 3. Current Bearish
color check_color_3 = check_current_bearish ? color.new(color.green, 70) : color.new(color.red, 70)
table.cell(debugTable, 0, 24, "3. Current Bearish", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 24, check_current_bearish ? "✓" : "✗", text_color=color.black, bgcolor=check_color_3, text_size=size.small)

// 4. Prev Bullish
color check_color_4 = check_prev_bullish ? color.new(color.green, 70) : color.new(color.red, 70)
table.cell(debugTable, 0, 25, "4. Prev Bullish", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 25, check_prev_bullish ? "✓" : "✗", text_color=color.black, bgcolor=check_color_4, text_size=size.small)

// 5. Engulfs Body
color check_color_5 = check_engulfs_body ? color.new(color.green, 70) : color.new(color.red, 70)
table.cell(debugTable, 0, 26, "5. Engulfs Body", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 26, check_engulfs_body ? "✓" : "✗", text_color=color.black, bgcolor=check_color_5, text_size=size.small)

// 6. Is Deepest
color check_color_6 = check_is_deepest ? color.new(color.green, 70) : color.new(color.red, 70)
table.cell(debugTable, 0, 27, "6. Is Deepest", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 27, check_is_deepest ? "✓" : "✗", text_color=color.black, bgcolor=check_color_6, text_size=size.small)

// 7. Deeper Than Previous
color check_color_7 = check_is_deeper ? color.new(color.green, 70) : color.new(color.red, 70)
string deeper_text = check_is_deeper ? "✓" : "✗"
if not na(supply_deepest_ever)
    deeper_text := deeper_text + " (" + str.tostring(check_deepest_candle_close, format.mintick) + " vs " + str.tostring(supply_deepest_ever, format.mintick) + ")"
table.cell(debugTable, 0, 28, "7. Deeper Close", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 28, deeper_text, text_color=color.black, bgcolor=check_color_7, text_size=size.small)

// ============================================================================
// BPR FVG DEBUG
// ============================================================================
// Calculate BPR FVG checks for display
bool bpr_fvg_enabled = use_bpr_fvg
bool bpr_has_bar_index = bar_index >= 2
bool bpr_in_window = in_trading_window

// Check for FVG patterns
bool bpr_bullish_fvg_exists = bar_index >= 2 and low > high[2]
bool bpr_bearish_fvg_exists = bar_index >= 2 and high < low[2]

// Check if close through FVG conditions
bool bpr_close_through = false
if bpr_fvg_active
    if bpr_fvg_is_bullish
        bpr_close_through := close < bpr_fvg_bottom
    else
        bpr_close_through := close > bpr_fvg_top

// Add divider row
color bpr_divider_color = color.new(color.yellow, 30)
table.cell(debugTable, 0, 29, "BPR FVG DEBUG", text_color=color.black, bgcolor=bpr_divider_color, text_size=size.small)
table.cell(debugTable, 1, 29, "", text_color=color.black, bgcolor=bpr_divider_color, text_size=size.small)

// Determine if BPR FVG entry is active
bool bpr_entry_active = entry_signal_active and active_entry_strategy == "BPR FVG"

// 1. BPR FVG Enabled
color bpr_check_1 = (bpr_fvg_enabled or bpr_entry_active) ? color.new(color.green, 70) : color.new(color.red, 70)
table.cell(debugTable, 0, 30, "1. BPR Enabled", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 30, (bpr_fvg_enabled or bpr_entry_active) ? "✓" : "✗", text_color=color.black, bgcolor=bpr_check_1, text_size=size.small)

// 2. BPR FVG Active - show success if FVG was found (even if entry is now active)
color bpr_check_2 = (bpr_fvg_active or bpr_entry_active) ? color.new(color.green, 70) : color.new(color.red, 70)
table.cell(debugTable, 0, 31, "2. BPR Active", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 31, (bpr_fvg_active or bpr_entry_active) ? "✓" : "✗", text_color=color.black, bgcolor=bpr_check_2, text_size=size.small)

// 3. FVG Status (Found when BPR FVG is active OR entry is active - persists until invalidated or entered)
color bpr_check_3 = (bpr_fvg_active or bpr_entry_active) ? color.new(color.green, 70) : color.new(color.gray, 70)
string bpr_text_3 = "-"
if bpr_fvg_active or bpr_entry_active
    // Calculate FVG size in ticks for display
    float fvg_size = bpr_fvg_is_bullish ? (bpr_fvg_top - bpr_fvg_bottom) : (bpr_fvg_top - bpr_fvg_bottom)
    float fvg_ticks = fvg_size / syminfo.mintick
    bpr_text_3 := "Found (" + str.tostring(fvg_ticks, "#.#") + " ticks)"
table.cell(debugTable, 0, 32, "3. FVG", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 32, bpr_text_3, text_color=color.black, bgcolor=bpr_check_3, text_size=size.small)

// 4. Breached (Price closed through FVG - trade entry condition)
color bpr_check_4 = (bpr_close_through or bpr_entry_active) ? color.new(color.green, 70) : color.new(color.gray, 70)
string bpr_text_4 = (bpr_close_through or bpr_entry_active) ? "Breached" : "-"
table.cell(debugTable, 0, 33, "4. Breached", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 33, bpr_text_4, text_color=color.black, bgcolor=bpr_check_4, text_size=size.small)

// 5. FVG Levels - show even when entry is active
string bpr_levels = "-"
color bpr_levels_bg = value_bgcolor
if (bpr_fvg_active or bpr_entry_active) and not na(bpr_fvg_top) and not na(bpr_fvg_bottom)
    bpr_levels := str.tostring(bpr_fvg_bottom, format.mintick) + " - " + str.tostring(bpr_fvg_top, format.mintick)
    bpr_levels_bg := bpr_entry_active ? color.new(color.green, 70) : value_bgcolor
table.cell(debugTable, 0, 34, "5. FVG Levels", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 34, bpr_levels, text_color=color.black, bgcolor=bpr_levels_bg, text_size=size.small)

// 6. Invalidation Level - show even when entry is active
string bpr_inval = "-"
color bpr_inval_bg = value_bgcolor
if (bpr_fvg_active or bpr_entry_active) and not na(bpr_fvg_invalidation_level)
    bpr_inval := str.tostring(bpr_fvg_invalidation_level, format.mintick)
    bpr_inval_bg := bpr_entry_active ? color.new(color.green, 70) : value_bgcolor
table.cell(debugTable, 0, 35, "6. Inval Level", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 35, bpr_inval, text_color=color.black, bgcolor=bpr_inval_bg, text_size=size.small)

// 7. In Cooldown - show if we're in cooldown period
color bpr_check_7 = in_cooldown ? color.new(color.red, 70) : color.new(color.green, 70)
string bpr_text_7 = in_cooldown ? "✗ YES (blocked)" : "✓ NO"
if last_exit_bar >= 0
    int bars_since_exit = bar_index - last_exit_bar
    bpr_text_7 := bpr_text_7 + " (" + str.tostring(bars_since_exit) + " bars)"
table.cell(debugTable, 0, 36, "7. In Cooldown", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 36, bpr_text_7, text_color=color.black, bgcolor=bpr_check_7, text_size=size.small)

// 8. Close Price Check - show actual breach logic
string bpr_text_8 = "-"
color bpr_check_8 = color.new(color.gray, 70)
if bpr_fvg_active or bpr_entry_active
    string comparison = ""
    bool would_breach = false
    if bpr_fvg_is_bullish
        // Bullish FVG = bearish trade = wait for close < bottom
        would_breach := close < bpr_fvg_bottom
        comparison := str.tostring(close, format.mintick) + " < " + str.tostring(bpr_fvg_bottom, format.mintick)
    else
        // Bearish FVG = bullish trade = wait for close > top
        would_breach := close > bpr_fvg_top
        comparison := str.tostring(close, format.mintick) + " > " + str.tostring(bpr_fvg_top, format.mintick)

    bpr_text_8 := (would_breach ? "✓ " : "✗ ") + comparison
    bpr_check_8 := would_breach ? color.new(color.green, 70) : color.new(color.red, 70)
table.cell(debugTable, 0, 37, "8. Close Check", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 37, bpr_text_8, text_color=color.black, bgcolor=bpr_check_8, text_size=size.small)

// 9. Invalidation Reason - shows why BPR FVG was last cleared (for debugging)
string bpr_text_9 = bpr_fvg_invalidation_reason == "" ? "-" : bpr_fvg_invalidation_reason
color bpr_check_9 = bpr_fvg_invalidation_reason == "" ? color.new(color.gray, 70) : color.new(color.yellow, 70)
table.cell(debugTable, 0, 38, "9. Last Clear", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 38, bpr_text_9, text_color=color.black, bgcolor=bpr_check_9, text_size=size.small)

// 10. Supply/Demand Triggered - shows zone trigger state
string bpr_text_10 = "-"
color bpr_check_10 = color.new(color.gray, 70)
if bpr_fvg_active or bpr_entry_active
    if bpr_fvg_is_bullish
        // Bullish FVG needs supply_triggered
        bpr_text_10 := supply_triggered ? "✓ Supply" : "✗ Supply"
        bpr_check_10 := supply_triggered ? color.new(color.green, 70) : color.new(color.red, 70)
    else
        // Bearish FVG needs demand_triggered
        bpr_text_10 := demand_triggered ? "✓ Demand" : "✗ Demand"
        bpr_check_10 := demand_triggered ? color.new(color.green, 70) : color.new(color.red, 70)
table.cell(debugTable, 0, 39, "10. Zone Trig", text_color=color.black, bgcolor=label_bgcolor, text_size=size.small)
table.cell(debugTable, 1, 39, bpr_text_10, text_color=color.black, bgcolor=bpr_check_10, text_size=size.small)

// ============================================================================
// DAILY STATS TABLE (HIDDEN FOR DEBUGGING)
// ============================================================================
// var table statsTable = table.new(position.bottom_right, 2, 5, border_width=1)
//
// color stats_label_bg = color.new(color.black, 20)
// color stats_value_bg = color.new(color.gray, 30)
//
// // Title row
// table.cell(statsTable, 0, 0, "TODAY'S STATS", text_color=color.white, bgcolor=color.new(color.blue, 30), text_size=size.normal)
// table.cell(statsTable, 1, 0, "", text_color=color.white, bgcolor=color.new(color.blue, 30), text_size=size.normal)
//
// // Trades count
// string trades_text = str.tostring(today_trade_count)
// table.cell(statsTable, 0, 1, "Trades", text_color=color.white, bgcolor=stats_label_bg, text_size=size.normal)
// table.cell(statsTable, 1, 1, trades_text, text_color=color.white, bgcolor=stats_value_bg, text_size=size.normal)
//
// // Wins
// string wins_text = str.tostring(today_wins)
// table.cell(statsTable, 0, 2, "Wins", text_color=color.white, bgcolor=stats_label_bg, text_size=size.normal)
// table.cell(statsTable, 1, 2, wins_text, text_color=color.white, bgcolor=color.new(color.green, 50), text_size=size.normal)
//
// // Losses
// string losses_text = str.tostring(today_losses)
// table.cell(statsTable, 0, 3, "Losses", text_color=color.white, bgcolor=stats_label_bg, text_size=size.normal)
// table.cell(statsTable, 1, 3, losses_text, text_color=color.white, bgcolor=color.new(color.red, 50), text_size=size.normal)
//
// // P&L
// string pnl_text = (today_pnl >= 0 ? "+" : "") + str.tostring(today_pnl, "#.##")
// color pnl_bg = today_pnl > 0 ? color.new(color.green, 30) : (today_pnl < 0 ? color.new(color.red, 30) : stats_value_bg)
// table.cell(statsTable, 0, 4, "P&L", text_color=color.white, bgcolor=stats_label_bg, text_size=size.normal)
// table.cell(statsTable, 1, 4, pnl_text, text_color=color.white, bgcolor=pnl_bg, text_size=size.normal)
